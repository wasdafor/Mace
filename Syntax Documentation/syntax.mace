/*
The MACE syntax file
====================

This file will explain all syntax used in v1.0

First we will define the syntax that makes it possible to convert this file easily to an HTML page.
No tags are used inside other tags.

The shortcodes are:
//chapter
Your chapter here


//title
Your title here


//subtitle
Your subtitle here


//text
Your text here


//code
Your code here


//comment
Your comment here (this text should not be compiled to html)

//tablehead
Your table titles here

//table
Your table elements here saperate collums by a comma

__Your label here__

*/

//start

//chapter
Namespaces

//title
Creating Namespaces (namespace)

//text
The __namespace__ keyword is used to create a __namespace__
To create a __namespace__ write the __namespace__ keyword, followed by the name of the namespace with opening and closing curly brackets,
When defining fields, methods and classes they are automatically __static__, so the __static__ keyword is not required.

//code
namespace MyNamespace
{
    // Your classes and static fields.
}

//text
Namespace with classes, methods and fields

//code
namespace MyNamespace
{
    int myInt = 0;

    void myMethod()
    {

    }

    class MyClass
    {
    
    }
}

//title
Using Namespaces (using)

//text
The __using__ keyword is used to use a namespace. 
To use a namespace write __using__ followed by the path where the namespace is located ending with a __;__.
All public elements in the namespace can be directly accessed.

//code
using ./MyNamespace;
// Print public element from MyNamespace.
print(myElement);

//subtitle
Using elements

//text
The __,__ can be used to use specific elements of a namespace.
To use specific elements add your elements separated by commas.
Next, write __from__, followed by the path and your namespace ending with a __;__.
To access an element of a namespace, use the name of the elements.

//code
using myFirstElement, mySecondElement from ./MyNamespace;

print(myFirstElement);
print(mySecondElement);

//subtitle
Naming a namespace (as)

//text
The __as__ keyword can used to name a namespace. 
To name your namespace write __as__ after your namespace path followed by a given namespace name.
To access an element of a named namespace, write the given name followed by an element.

//code
using ./MyNamespace as MyNamedNamespace;
// Print public element from MyNamespace named MyNamedNamespace.
print(MyNamedNamespace.myFirstElement);

using myFirstElement, mySecondElement from ./MySecondNamespace as MySecondNamedNamespace;

print(MySecondNamedNamespace.mySecondElement);

//subtitle
Renaming elements (as)

//text
The __as__ keyword can used to rename namespace elements. 
To rename your namespace elements, write __as__ after the element followed with your new name;
To access a renamed element of a namespace, use the renamed name of the elements.

//code
using myFirstElement as myFirstRenamedElement, mySecondElement as mySecondRenamedElement from ./MyNamespace;

print(myFirstRenamedElement);
print(mySecondRenamedElement);

using myFirstElement as myFirstRenamedElement from ./MySecondNamespace as MySecondNamedNamespace;

print(MySecondNamedNamespace.myFirstRenamedElement);

//title
Using system namepaces (system)

//text
The __system__ keyword is used to use any namespace from the mace system namespaces.
To use the system namepaces, write __system__ before your __using__ statement. 
This wil start your namespace path in the system directory. This means that adding the ./ prefix in your namespace path is not required.

//code
system using Networking/RequestManager;
// Print return value from the getURL method from RequestManager.
print(getURL("https://google.com"));

//chapter
Classes

//title
Creating Classes (class)

//text
To create a class write __class__ followed by the name of the class and __{}__.
You can define any fields or methods in a class.
To create an instance of a class use the class name followed by __()__ ending with a __;__.
You can only define a class in a namespace.
Classes will automatically be private.

//code
namespace MyNamespace
{
    class MyClass
    {
       
    }

    class MySecondClass
    {
       int myInt = 0;

       void myMethod()
       {

       }
    }
}

Myclass myClass = MyClass();
MySecondClass mySecondClass = MySecondClass();

//title
Inheritance (extend)

//text
To inherit a class from another class use the a __extend__ after the name of the child class followed by the name of the class you want to inherit from.
When a class inherits from another class you can access the fields and methods of the parent class.

//code
class MyClass
{
    public int myInt = 0;

    public void myMethod(int value)
    {

    }
}

class MySecondClass extend MyClass
{
    MySecondClass()
    {
        myMethod(myInt);
    }
}

//title
Abstraction (abstract)

//text
Write __abstract__ before your class, field or method to make it abstract.
When a class, field or method is abstract it means that it cannot be used on its own.

//subtitle
Classes

//text 
When a class is abstract the class can only be inherited by another class.
This means that you can not create an instance of an abstract class.

//code
abstract class MyClass
{
    public int myInt = 0;

    public void myMethod(int value)
    {

    }
}

class MySecondClass extend MyClass
{
    MySecondClass()
    {
        myMethod(myInt);
    }
}

//subtitle
Fields and methods

//text
Only abstract classes and interfaces can contain abstract fields and methods. 
When a field or method is abstract this means that they need to be implemented in the child class.
To implement an abstract field or method write __override__ before the field or method.
It is important that the field you want to implement has the same access modifier, type and identifier as the one you want to override.
If a field is an abstract field it may have a default value.
When the child class defines the field it overrides the value, if the child class only declares the field the default value of the parent class.
The same applies for methods, the implemented method needs to have the same access modifier, return type, identifier and parameters as the method you want to override.
If a method is an abstract field it may have a body.
When the child class defines the method it overrides the code in the body of the abstract class, if the child class only declares the method, the code of the parent class is run.
Note that definition of a field or method must happen, either or both in the parent and child class.

//code
abstract class MyClass
{
    public abstract int myInt = 0;

    abstract string myString = 'Value';

    protected abstract double myDouble;

    public abstract void myMethod(int value)
    {
        print(value);
    }

    abstract void mySecondMethod(string value)
    {
        print(value);
    }

    protected abstract void myThirdMethod(double value);
}

class MySecondClass extend MyClass
{
    public override int myInt;

    override string myString 'Overwritten value';

    protected override double myDouble = 3.3;
    
    public override void myMethod(int value);
    
    override void mySecondMethod(string value)
    {
        print(value + "Overwritten");
    }

    protected override void myThirdMethod(double value)
    {
        print(value);
    }
}

//title
Sealing (sealed)

//text
When a class is __sealed__, the class cannot be used as a super class.
The class cannot be inherited by another class.
A sealed class cannot contain abstract fields or methods.

//code
sealed class MyClass
{
    int myInt;

    void myMethod(int value)
    {

    }
}

//title
Static (static)

//text
When a class is __static__, the class cannot be used as a super class.
The class cannot be inherited by another class.
A static class can only contain static fields or methods.
A static class cannot be instanciated.

//code
static class MyClass
{
    static int myInt;

    static void myMethod(int value)
    {

    }
}

//title
Super class (super) and This class (this)

//text
When using the same identifier in the child class as in the parent class, the child class will override the parent identifier.
Use __super__ to only access the fields and methods of the parent class.
Use __this__ to only access the fields and methods of the current class.

//code
class MyClass
{
    public int myInt = 0;

    public void myMethod(int value)
    {

    }
}

class MySecondClass extend MyClass
{
    MySecondClass()
    {
        myMethod();
        super.myMethod(myInt);
        this.myMethod(myInt);
    }

    public void myMethod(int value)
    {

    }
}

//title
Interfaces (interface)

//text
To create an interface write __interface__ followed by the name of the interface, the keyword __implement__ and __{}__.
You can define any fields or methods in an interface.
Note that an interfaces can contain only abstract fields and methods.
Fields cannot be defined and methods cannot have a body.
Interfaces can be compared to blueprints for clasess.
You can only define an interface in a namespace.

//code
interface MyInterface
{
    abstract int myInt;

    abstract void myMethod();
}

class MyClass implement MyInterface
{
    override int myInt = 0;

    override void myMethod()
    {

    }
}

//title
Constructor

//text
To create a constructor write the class name followed by a function body.
Named constructors can be created by writing the constructor followed by an access operator and your constructor name.
The code of a constructor will be run when you create an instance of the class.

//code
class MyClass
{
    MyClass()
    {
        // Your constructor code.
    }

    MyClass.MyNamedConstructor()
    {
        // Your named constructor code.
    }
}

MyClass myClass = MyClass();
myClass = MyClass.MyNamedConstructor();

//text
A constructor can call another constructor by using a __:__ after the parameter body followed by __this__.
If you want to call a named constructor use the access operator and your constructor name after the this keyword.

//code
class MyClass
{
    MyClass() : this.MySecondNamedConstructor(){
        // Your constructor code.
    }

    MyClass.MyNamedConstructor() : this()
    {
        // Your named constructor code.
    }

    MyClass.MySecondNamedConstructor()
    {
        // Your named second constructor code.
    }
}

//title
Destructor (~)

//text
A destructor is optional, but if created it will be run when a instance of a object is deleted.
No parameters can be added to the destructor parameter body.

//code
class MyClass
{
    ~MyClass()
    {
        
    }
}

//title
Methods

//subtitle
Short assignment

//text
Short assignment of fields in class methods or constructors can be accomplished by using a different syntax in the parameter body.
When using short assignment the parameters are assigned to the variables in the class automatically.
Short assignment can also be used with the super class.
Note that code can still be added to the body of the method as shown below and that the parameters can still be used inside the body.

//code
class MyClass
{
    int myInt = 0;
    string myString = "Hello World!"

    MyClass(this.myInt, this.myString)
    {
        // Your constructor code.
    }

    myMethod(this.myInt, this.myString)
    {
        myString += " Goodbye!"
        // Your method code.
    }
}

//code
class MyClass
{
    int myInt = 0;
}

class MySecondClass extend MyClass
{
    int mySecondInt;
    MySecondClass(this.mySecondInt, super.myInt)
    {
        // Your constructor code.
    }
}

//text
To have a constant or read only variable in your class, but you want to initialize it in the constructor, use the keyword __initialize__.
The variable can also be initialized via short assignment.
The variable can only be overwritten in the constructor scope. 

//code
class MyClass
{
    initialize const int myInt;
    initialize readonly string myString = "Hello World!";

    MyClass(this.myInt, myString)
    {
        this.myString = myString;
        // Your constructor code.
    }
}

//subtitle
Getters (get) and Setters (set)

//text
Getters and setters are methods that will be run when the specific field is accessed.
The keywords __public__, __private__ and __protected__ can be added to getters and setters.
These access modifiers override the default getters and setters of the fields.
Note that in the example the integer was initialially private, but has become public because of the getter and setter.

//code
class MyClass
{
    private int myInt;

    MyClass(this.myInt)
    {
        // Your constructor code.
    }

    public get myInt()
    {
        return myInt + 1;
    }

    protected set myInt(int myInt)
    {
        this.myInt = myInt - 1;
    }
}

//title
Lambda funtions

//TODO

//chapter
Variables

//text
Mace has the following primitive data types.
Define variables by writing the following structure; a variable keyword or object type, a unique identifier, an equal sign, your expression and a semicolon.

//tablehead
Primitive`  Meaning

//table
string`     Stores any array of characters.
char`       Stores any singular character.
int`        Stores any whole number between -2,147,483,648 and 2,147,483,647.
double`     Stores any floating point number, between -1.7*10^308 and 1.7*10^308.
bool`       Stores true or false.
percent`    Stores a faction.

//title
Strings (string)

//text
A string is an object that stores an array of characters.
You can define a string by using __''__ or __""__.

//code
string myString = "Hello World!";
myString = 'Hello World!';

//subtitle
Concatenation

//text
To concatenate two strings use the plus operator.
You can concatenate literal strings and string variables.

//code
string myString = 'Hello' + "World!";

string myDoubleString = myString + myString;

//subtitle
Escape characters (\)

//text
Use escape characters to use characters that would normaly have a different meaning or to give a character a different meaning.
To use escape character use __\__.
Escape characters can be used in a string or char.

//tablehead
Escape chapter` Meaning

//table
\n`             New line
\b`             Backspace
\t`             Tab
\$`             A literal __$__
\\`             A literal __\__
\'`             A literal __'__
\"`             A literal __"__

//code
string myNewLine = 'This is on line one,\nAnd this on line two';
string myBackspace = 'This removes the last character from this string\b';
string myTab = 'This adds a tab\tin this string';
string myDollarSign = 'This escapes the use of the \$ for using interpolation';
string myBackslash =  'This escapes the use of the \\ for escaping characters';
string mySingleQuote = 'This escapes the use of the \' for creating a string or char';
string myDoubleQuote = "this escapes the use of the \" for creating a string or char";

//subtitle
Interpolation

//text
To use string interpolation use a __$__ or use __${}__.
When only using the __$__ you need to have a space between the variable and the next part of the string 

//code
string myName = 'Jack';

string myString = 'Hello $myName how are you doing?'

myString = 'Hello ${myName + "how"} are you doing?'

//subtitle
Indexing

//text
Read a character from a string by using __[]__.
Indexing starts at index 0.

//code
string myString = 'Hello World!';
print(myString[0]);

//title
Characters (char)

//text
A __char__ is a primitive that stores just one character.
You can define a __char__ by using __''__ or __""__.

//code
char myChar = "H";
myChar = '!';

//subtile
Concatenation

//text
If you want to concatenate two characters you need to store them in a __string__.

//code
string myTwoChars = 'H' + "!";

//subtile
Escape characters (\)

//text
To use escape characters in a string use __\__.
Escape characters can be used in a string or char.

//code
char mySingleQuoteChar = '\'';
char myDoubleQuoteChar = "\"";

//title
Integers (int)

//text
An __int__ is a primitive that can store any whole number between -2,147,483,648 and 2,147,483,647.

//code
int myInt = 13135;
myInt;

//subtitle
Int with a different base

//text
When using a number from a different base use one of the following prefixes.

//tablehead
Prefix` Meaning`    Base

//table
0b`     Binary`     2
0o`     Octal`      8
0x`     Hexadecimal`16

//code
int myBinaryInt = 0b01010;
int myOcalInt = 0o37461;
int myHexadecimalInt = 0x3D24AF;

//subtitle
Indexing

//text
To get a digit from an __int__, access the __int__ in the same way as how you would get a __char__ from a string.
Indexing starts at index 0.
https://www.geeksforgeeks.org/find-first-last-digits-number/#:~:text=To%20find%20first%20digit%20of%20a%20number%20we%20divide%20the,left%20with%20the%20first%20digit.
^aproach 2

//code
int myInt = 13135;
print(myInt[0]);

//title
Doubles (double)

//text
A __double__ is a primitive that can store any floating point number, between -1.7*10^308 and 1.7*10^308 with a precision of 15 digits.
To define a __double__ use a dot where the decimal digits should be.
Note that a __double__ is not perfectly precise when used in calculations.

//code
double myDouble = 13135.13135;
print(myDouble);

//text
Literal int values and numbers from different bases are allowed to be assigned to a double.

//code
double myIntegerDouble = 312;
double myBinaryDouble = 0b01010;
double myOcalDouble = 0o37461;
double myHexadecimalDouble = 0x3D24AF;

//subtitle
Exponent of 10 (e)

//text
multiply a number to 10 to the power of any integer number by use the suffix __e__.
You can use a positive or negative integer exponent.

//code
double myInt = 4.3e5;
myInt = 3.8e-2;

//title
Booleans (bool)

//text
A __bool__ is a primitive that can store either a zero or a one.
Because there are only two states, the 0 is also equal to __false__, and the 1 is equal to __true__;
All datatypes that are empty or null are false if casted to an boolean.
If they contain a value they are true.

//tablehead
Datatype`       Empty value

//table
int`            0
double`         0.0
string`         ''
string[]`       []
Map<string,int>`{}
Set<string>`    Set.empty
List<string>`   []

//code
bool myBool = true;
myBool = (bool)0

//chapter
Operators

//title
Arithmetic

//text
Arithmetic operators are mostly used so to apply mathematical equations to values.
Some of these operators can be used on strings, arrays, maps, sets and lists.

//tablehead
Operator`   Name`                       Example

//table
+`          Addition`                   myInt + 5
++`         Increment`                  ++myInt    
-`          Negatation or Subtraction`  myInt - 5    
--`         Decrement`                  --myInt    
*`          Multiplication`             myInt * 5
/`          Division`                   myInt / 5
^`          Exponentiation`             myInt ^ 5
!`          Factorization`              myInt!
%`          Modulation`                 myInt % 5          

//subtitle
Addition (+)

//text
The __+__ operator is used when any two numbers need to be added to each other.

//code
int myInt = 1 + 3;

//text
The __+__ can also be used to concatenate strings, arrays, sets, maps or lists.
Concatenating strings, arrays, sets, maps or lists will add the values together and return a new string, array, sets, maps or lists.

//code
string myString = 'Hello' + 'World!';
int[] myArray = [1,3] + [2,4];
Map<string,int> myMap = {'firstValue': 1} + {'secondValue': 2};
Set<int> mySet = {1,4,2} + {2,3,8};
List<int> myList = [1,3] + [2,4];

//subtitle
Increment (++)

//text
The __++__ operator is used to increment a number variable by 1 before using it;

//code
int myInt = 0;
myInt = ++myInt;

//subtitle
Negatation or Subtraction (-)

//text
The __-__ operator is used when a number needs to be negated or two numbers need to be subtracted from each other.

//code
int myInt = -1;
myInt = 4 - 3;
myInt = 3 -4;

//text
The __-__ operator can also be used to subtract strings, arrays, maps, sets or lists.
When subtracting a string from another string, the order of the characters is important.
Note here that only one substring that is equal to the righthand string will be removed.
When subtracting an array from another array, the order of the elements is important. The same applies for lists.
Note here that all the elements in the righthand array will be removed from the lefthand array if they exist.
When subtracting a map from another map, the order of the elements is not important. The same applies for lists.
Searching and removing will start at the end.

//code
string myString = 'Hello World!' - 'World!';
int[] myArray = [1,2,4,3] - [2,4];
Map<string,int> myMap = {'firstValue': 1, 'secondValue': 2} - {'firstValue': 1};
Set<int> mySet = {1,4,2} - {2,3,8};
List<int> myList = [1,2,4,3] - [2,4];

//subtitle
Decrement (--)

//text
The __--__ operator is used to decrement a number variable by 1 before using it;

//code
int myInt = 0;
myInt = --myInt;

//text
The __--__ operator can also be used to subtract strings, arrays or lists.
When applying this operator, the last element will be removed.

//code
string myString = --"Hello world!"
int[] myArray = --[1,2,3,4];
List<int> myList = --[1,2,3,4];

//subtitle
Multiplication (*)

//text
The __*__ operator is used when any two numbers need to be multiplied.

//code
int myInt = 3 * 4;

//text
The __*__ operator can also be used to multiply strings, sets or arrays.
Multiplying a string, set or array will repeat the values inside and return a new string, set or array.
Note you must use an integer value when multiplying with a number.
When multiplying an array or a set with another array or set, the result will be a cartesian product.

//code
string myString = 'Hello World!' * 2;
int[] myArray = [1,2,3,4] * 2;
Set<int> mySet = {1,2,3,4} * {1,2,3,4};

//subtitle
Division (/)

//text
The __/__ operator is used when any two numbers need to be divided by each other.

//code
int myInt = 4 / 2;

//text
The __/__ operator can also be used to divide strings, arrays or lists.
Dividing a string, array or list by a value will count the occurrences of the given value and returns an int.
Note that the order matters.

//code
int countString = 'Hello World!' / 'l';
int[] countArray = [1,2,3,4,2,3] / [2,3];
List<int> countList = [1,2,3,4,2,3] / [2,3];

//subtitle
Exponentiation (^)

//text
The __^__ operator is used when a number needs to be exponented by an other number.

//code
int myInt = 3 ^ 2;

//subtitle
Factorization (!)

//text
The __!__ operator is used when the factorial needs te be found of a number.

//code
int myInt = 5!;

//subtitle
Modulation (%)

//text
The __%__ operator is used when the remainder of a number needs te be found after subtraction by an other number just before it becomes negative.

//code
int myInt = 5 % 2;

//text
The __%__ operator can also be used to modulate strings or arrays.
modulating a string or array will remove all the occurrences of the value(s) on the righthand side from the lefthand side and return a new string or array.
Note that the order matters.

//code
string myString = 'Hello World!' % 'l';
int[] myArray = [1,2,3,4,2,3] % [2,3];
List<int> myList = [1,2,3,4,2,3] % [2,3];

//title
Assignment

//text
Assignment operators are used to assign or for reassigning a value to a variable.
Some of these operators can be used on strings, arrays, sets and maps.
For all the arithmetic assignment operators check out the arithmetic or null safety chapter.


//tablehead
Operator`   Name`                                   Example`           Same as

//table
=`          Assignment`                             myInt = 0;`        myInt = 0;
+=`         Addition assignment`                    myInt += 5;`       myInt = myInt + 5; 
++`         Increment assignment`                   myInt++;`          myInt = ++myInt; or myInt = myInt + 1;
-=`         Negatation or Subtraction assignment`   myInt -= 5;`       myInt = myInt - 5; 
--`         Decrement assignment`                   myInt--;`          myInt = --myInt; or myInt = myInt - 1;
*=`         Multiplication assignment`              myInt *= 5;`       myInt = myInt * 5; 
/=`         Division assignment`                    myInt /= 5;`       myInt = myInt / 5; 
^=`         Exponentiation assignment`              myInt ^= 5;`       myInt = myInt ^ 5; 
!!`         Factorization`                          myInt!!;`          myInt = myInt!; 
%=`         Modulation assignment`                  myInt %= 5;`       myInt = myInt % 5;
??=`        Null-coalescing assignment`             myInt =?? 5;`      myInt = myInt ?? 5; or myInt = myInt == null ? 5 : myInt;  

//subtitle
Assignment (=)

//text
The __=__ is used to assign a literal value or variable to a variable.

//code
int myInt = 0;
int mySecondInt = myInt + 5;

//title
Comparison

//text
Comparison operators are used to compare two values with each other to return a bool.

//tablehead
Operator`   Name`                       Example

//table
==`         Equal to`                   myInt == 6
!=`         Not equal to`               myInt != 6
>`          Greater than`               myInt > 6
>=`         Greater than or equal to`   myInt >= 6
<`          Less than`                  myInt < 6
<=`         Less than or equal to`      myInt <= 6

//title
Logical

//text
Logical operators are used to compare two bools with each other to return a bool.

//tablehead
Operator,   Name,           Example

//table
&&`         Logical and`    true && true     
||`         Logical or`     false && true
!`          Logical not`    !false

//title
Logical Comparison

//text
Logical Comparison operators are used to compare two values with each other.
These operators are different to normal comparison because Logical Comparison operators let you chain multiple comparison operations to the same value.

//tablehead
Operator`   Name`                           Example`            Same as

//table
&==`        And equal to`                   myInt > 5 &== 7`    myInt > 5 && myInt == 7
&!=`        And not equal to`               myInt > 5 &!= 7`    myInt > 5 && myInt != 7 
&>`         And greater than`               myInt < 7 &> 5`     myInt < 5 && myInt > 7 
&>=`        And greater than or equal to`   myInt < 7 &>= 5`    myInt < 5 && myInt >= 7 
&<`         And less than`                  myInt > 5 &< 7`     myInt > 5 && myInt < 7 
&<=`        And less than or equal to`      myInt > 5 &<= 7`    myInt > 5 && myInt <= 7
|==`        Or equal to`                    myInt > 5 |== 3`    myInt > 5 || myInt == 3
|!=`        Or not equal to`                myInt > 5 |!= 3`    myInt > 5 || myInt != 3
|>`         Or greater than`                myInt < 7 |> 5`     myInt < 5 || myInt > 7
|>=`        Or greater than or equal to`    myInt < 7 |>= 5`    myInt < 5 || myInt >= 7
|<`         Or less than`                   myInt > 5 |< 3`     myInt > 5 || myInt < 3
|<=`        Or less than or equal to`       myInt > 5 |< 3`     myInt > 5 || myInt < 3             

//title
Null safety

//text
Null safety operators are used to manage null values in you program to avoid runtime errors.

//tablehead
Operator`   Name`                   Example

//table
?`          Nullability indicator`  int? myInt = null;
?`          Null-aware`             myObject?.toString(); or myArray?[1]; or myMap?['key'];
??`         Null-coalescing`        myString ?? 'Default value';

//chapter
Control statements

//text
Control statements ar statements that direct the flow of you code to a desired path.

//title
Branching

//text
Branching statements are used when you want to branch your code in a well defined path.

//subtitle
If (if)

//text
The __if__ keyword is used when a specific block of code can only be executed under a specfied conditition.
To create an __if__ statement write __if__ followed by __()__ ending with __{}__.
The body of an if statement only gets executed when the expression inside the __()__ is evaluated to __true__.

//code
if(myBoolean){
    //Code that executes when myBoolean is true.
}

if(myInt > 5){
    //Code that executes when myInt is greater than 5.
}

//subtitle
Else (else)

//text
The __else__ keyword is used when a specfied block of code can only be executed when the parent if expression is evaluated to false.
To create an __else__ statement write __else__ following __{}__.
Note that any __else__ statement must me bounded to an if, else if, while or for statement.

//code
if(myBoolean){
    //Code that executes when myBoolean is true.
}
else{
    //Code that executes when myBoolean is false.
}

//text
The __else__ statement can also be bounded to any else if statement.
Note that the else statement only gets executed when the if and all the else if expressions are evaluated to false. 

//code
if(myBoolean){
    //Code that executes when myBoolean is true.
}
else if(mySecondBoolean){
    //Code that executes when myBoolean is false and mySecondBoolean is true.
}
else{
    //Code that executes when myBoolean is false and mySecondBoolean is false.
}

//text
The __else__ statement can also be bounded to any for or while loop.
Note that the else statement only gets executed when the loop ends without using break.

//code
for(int value in values){
    //Code that executes for every value of values.
}
else{
    //Code that executes when the loop ended.
}

while(myBoolean){
    //Code that executes for as long as myBoolean is true.
}
else{
    //Code that executes when the loop ended.
}

//subtitle
Else if (else if)
The __else if__ keywords are used when a specfied block of code can only executed when the parent if expression is returned to false and another expression is evaluated to true.
To create an __else if__ statement write __else if__ followed by __()__ ending with __{}__.
Note that any __else if__ statement must me bounded to an if or else if statement.

//code
if(myBoolean){
    //Code that executes when myBoolean is true.
}
else if(mySecondBoolean){
    //Code that executes when myBoolean is false and mySecondBoolean is true.
}

//text
The __else if__ statements can be stacked as many times as you would like.

//code
if(myBoolean){
    //Code that executes when myBoolean is true.
}
else if(mySecondBoolean){
    //Code that executes when myBoolean is false and mySecondBoolean is true.
}
else if(myThirdBoolean){
    //Code that executes when myBoolean is false and mySecondBoolean is false and myThirdBoolean is true.
}

//subtitle
Switch (switch), (case), (default), (break)

//text
The __switch__ keyword is used to check a certian value for many cases.
To create a __switch__ statement write __switch__ followed by __()__ ending with __{}__.
Inside the __()__ enter any value.

The __case__ keyword is used to define a block of code that gets executed when the value from the switch is equal to the value(s) in the switch statement.
To create a case write __case__ followed by __()_ ending with __{}__ inside the __{}__.
Inside the __()__ enter any value with the same type as the value from the switch statement.
Any number of case statement is allowed.

//code
switch(myInt)
{
    case(5){
        //Code that executes when myInt is 5.
    }
    case(6){
        //Code that executes when myInt is 6.
    }
}

//text
The __,__ can be used to define multiple values in one switch statement.
These comma separated values work like an logical or operator.

//code
switch(myInt)
{
    case(5,6){
        //Code that executes when myInt is 5 or 6.
    }
}

//text
The __break__ keyword can be used to break out of the switch statement and stops checking any other cases.

//code
switch(myInt)
{
    case(5){
        //Code that executes when myInt is 5.
        break;
    }
    case(6){
        //Code that executes when myInt is 6.
        break;
    }
}

//text
The __default__ keyword can be used to define a block of code that ony gets executed when no cases where executed.
Note that break is not needed.
//Misschien else gebruiken na de switch net zoals bij een loop?

//code
switch(myInt)
{
    case(5){
        //Code that executes when myInt is 5.
        break;
    }
    case(6){
        //Code that executes when myInt not is 5 and is 6.
        break;
    }
    default{
        //Code that executes when myInt not is 6 and not is 5.
    }
}

//title
Looping

//title
Error handling

//title
Null safety handling
