/*
The MACE syntax file
====================

This file will explain all syntax used in v1.0

Spaces, tabs and curly brackets are consistent throughout the file.
After classes and switches comes an enter followed by curly brackets.
After all other code scopes come curly brackets without an enter.

First we will define the syntax that makes it possible to convert this file easily to an HTML page.
No tags are used inside other tags.

The shortcodes are:

//chapter
Your chapter here


//title
Your title here


//subtitle
Your subtitle here


//text
Your text here


//code
Your code here


//comment
Your comment here (this text should not be compiled to html)

//tablehead
Your table titles here, seperate collums by a `

//table
Your table elements here, seperate collums by a `

__Your label here__
*/

//start

//chapter
Entry files and boundary folder

//title
Entry files

//text
The entry file of a program is the file from where the program its code first starts executing.
Mace utilizes a special file naming convention so you can start programming quickly without the need of configuration.
To create an entry file, the file must have the following naming structure: __in.yourEntryName.mace__.
When a file is marked as entry file of the program it cannot be imported by other parts of the program.
Mace programs can have any number of entry files, but they can only have one boundary.

//title
Configuration file

//text
If your program needs more configuration or is depening on exernal packages a configuration file is required.
To create this file add a json file at the root of your program with the followed name: __mace.config.json__.
The folder where the configuration file is placed in will become the boundary folder of the program.
The following json template must be added to your configuration file for it to be a valid configuration file.

//code
{
    "name": "YourPackageName"
}

//title
Boundary folder

//Text
The boundary folder of the program indicates in which folder, space imports will be searched.
This boundary folder will automatically be inferred depening on the location of your entry or configuration files.
For mace to infer this boundary folder it will start searching from within the folder where your mace file that utilizes space imports resides.
Mace will keep searching up in the folder structure from this initial folder until it finds a configuration file.
When mace finds a configuration file the boundary folder will be the parent folder of this configuration file.
When mace does not find a configuration file it will utilize the parent folder of the first entry file it has founds.
If both types of files are not found you can not utilize space imports to import parts of your program.

//chapter
Spaces and imports

//title
Folder spaces

//text
Folder spaces are used to organize your program into smaller importable pieces of code.
A folder space(In short just space) is just a fancy name for any folder in your project containing __.mace__ files.
All the top level members defined in __.mace__ files will be part of the so called space scope.
Any file will be part of the orgin space and optional extended space.
The orgin space is the direct parent folder of any __.mace__ file and cannot be overwritten.

The following members can be defined as top level space members:

//table
class
extension class
enum
functions
variables
types

//subtitle
Extended space (space)

//text
The __space__ keyword can be used to define the extended space of any file file.
This can be achieved by writing the __space__ keyword followed by the path to the space.
The relative path of the space will always start two folder levels up from the original file.
Note that the extended space must always be a direct parent of the orgin space.  

//code
// File location: MyProject -> MySpace -> MySecondSpace -> myFile.mace
// Relative path starts two folders up in the MyProject folder.

// Defining the api folder as extended space.
space "find:MyProject/MySpace";

// Defining the myProject folder as extended space.
space 'find:MyProject';

//subtitle
Access modifiers

When defining multiple namespaces with the same identifier, the members of these namespaces will be merged.
Use access modifiers to define where the members of the namespace can be accessed, members will be private by default.

//table head
Access modifier`        Can be access where?

//table
__public__`             Inside any space.
__private__`            Only inside the current file.
__protected__`          Inside the current space and sub spaces.

//title
Importing files and spaces (import)

//text
The __import__ keyword is used to import the members from a file or space.
This can be achieved by writing the __import__ keyword followed by a string path to your file or space.
The import path can be a relative path from the current folder or a compleet absolute path. 
The members from the imported file or space can now be directly access by using their identifiers.
imported members are always private by default, even when importing specific members.
Note that import statements can only be specfied at the top of __.mace__ files.
//Maybe these imports are impored using ref by default?

//code
import './myFile.mace';
print(myMember);

import './MySpace';
print(mySecondMember);

//text
The __in__ keyword can be used to store the imported members into a custom alias.
This can be achieved by writing the __in__ keyword after the import path followed by the alias identifier.
The imported members can now be accessed via the alias using the __.__ operator.
Note that the alias is a class literal containing the imported members.

//code
import './myFile.mace' in userData;
print(myAlias.myFirstMember);

//subtitle
Specific members (in, ..)

//text
The __{}__ brackets and the __in__ keyword can be used to import only specific members from a file or space.
This can be achieved by writing the __in__ keyword after the import path followed by commas seperated members between the __{}__ brackets.
The specificly imported members can now be directly accessed using their identifier.

//code
import './myFile.mace' in {myMember, mySecondMember};
print(myMember, mySecondMember);

//text
The __=__ operator can be used to bind a custom alias to a specificly imported member.
This can be achieved by writing the __=__ operator after any imported member followed by the alias identifier.
The specificly imported member can now be accessed via its alias.

//code
import './myFile.mace' in {myMember = myMemberAlias, mySecondMember = mySecondMemberAlias};
print(myMemberAlias, mySecondMemberAlias);

//text
The code for importing members is utilizing the class literal unpacking syntax.
This unlocks the possibility to import nested members or even hide members.
The range operator can also be used to import the know members that are not specfied.

//code
import './myFile.mace' in {myMember, myArray = [myArrayElement], myHiddenMember=, ..myRestMembers};
print(myMember, myArrayElement, myRestMembers);

//subtitle
Mace library imports

//text
The special __mace:__ url scheme can be used to import build in mace library files or spaces.

//code
import 'mace:Math' in math;
print(math.pi);

//chapter
Data Structures
//Is nog niet uigewerkt het idee is dat hier 3 structure modifiers komen abstract moet parent class zijn open kan parent class zijn en geinstantieerd worden en sealed kan alleen geinstantieerd worden.
//En dan dit geld ook voor static classes en enums met natuurlijk wat wijzigen op die logiaca.

//text
Data structures are pieces of code that are used to store, comare, and manipulate data.
These structures can in most cases be used to create custom logic in the form of code.
Mace has the following data structures that can be created by the programmer.

//tablehead
Name`               Example

//table
Classes`            class MyClass{}
Static classes`     static class MyClass{}
Enums`              enum MyEnum{}   

When a data structure is defined without specifing a data structure modifier the __open__ data structure modifier will be used by default.
These data structures can only be defined inside of a __namespace__.

//title
Classes

//text
A __class__ is a labeled block of code that is a blueprint for a data and function object.
The following members can be defined inside of a __class__:

//table
Variables
Methods
Getters
Setters
Class methods

Use access modifiers to define where the class members can be accessed, members will be public by default.

//tablehead
Access modifier`        Can be accessed where?

//table
__public__`             Inside or outside of the class.
__private__`            Only inside the class itself.
__protected__`          Inside the class itself or derived classes.

The members of a class can always be accessed in the class itself no matter the protection level of its access modifier.
These members can be directly access by using its identifier and instance members can optionaly be access using the __this__ keyword.
A __class__ can be created by using the followed syntax.

//code
class MyClass
{
    // Your class members.
}

// Class with members.
class MySecondClass
{
    Int myInt = 13135;
    String myString = 'Hello World!';

    Void myMethod(){
        print(myInt, this.myString);
    }
}

//text
The class represents the blueprint of an object to create this object write the class identifier followed by __()__ brackets.
The instance of the class can now be treated as value and can be stored in a variable.
The members of the object can now be accessed by using the access operator (__.__).
Note that only __open__ and __sealed__ classes can be instanciated.

//code
class MyClass
{
    Int myInt = 13135;
    String myString = 'Hello World!';
}

// Directly accessing the myInt variable.
Int myInt = MyClass().myInt;

// Indirectly accessing the myString variable via the myClass variable.
MyClass myClass = MyClass();
String myString = myClass.myString;

//title
Inheritance (extend, super)

//text
The __extend__ keyword is used to inherit the members from one or more data structures into a new data structure also called the derived data structure.
This can be achieved by writing the __extend__ keyword after the derived data structure its identifier, followed by comma seperated data structure identifiers.
Only __public__, __protected__ and __private protected__ inherited structure members can be accessed in the derived data structure. 
These inherited members are now part of the new data structure and can be accessed like any other member.
Data structures can only inherit data structures with the same type and if they are not sealed.

//subtitle
Classes

//text
The inherited members from the parent classes can be access using the __super__ keyword.

//code
class MySecondClass
{ 
    Int myInt = 13135; 
    Int myString = "Hello World!";
}

class MyClass extend MySecondClass
{
    init(){
        // Printing the intance members myInt and myString from MySecondClass.
        print(myInt, super.myString);
    }
}

MyClass myClass = MyClass();

// Printing the intance members myInt and myString from MySecondClass using an instance variable.
print(myClass.myInt, myClass.myString);

//subtitle
Static classes

//text
The derived __static class__ is a completly new __static class__ and is detached from the parent __static class__.
This implies that the inherited members from the parents are different from the members in the derived __static class__.
Members from specific static parent classes can still be accessed using type casting.

//code
static class MySecondClass
{
    String myString = "Hello World!";
}

static class MyClass extend MySecondClass
{
    Int myInt = 13135;
}

// Printing the member myString from MySecondClass and myInt from myClass.
print(MyClass.myInt, MyClass<MySecondClass>.myString);

//subtitle
Enums

//text
The derived __enum__ is a completly new __enum__ and is detached from the parent __enum__.
This implies that the members from the parents are difference from the members from the derived __enum__.
Members from specific parent enums can still be accessed using type casting.

//code
enum MySecondEnum
{
    MyEnumValue
}

enum MyEnum extend MySecondEnum
{
    MySecondEnumValue
}

// Printing the member myString from MySecondClass and myInt from myClass.
print(MyEnum.MySecondEnumValue, MyEnum<MySecondEnum>.MyEnumValue);

//title
Abstraction (abstract)

//text
An __abstract__ data structure is almost the same as an __open__ data structure but it must be inherited.
These data structures can optionaly contain __abstract__ members that must be implemented in the derived data structure.
The members of an __abstract__ data structure can be accessed like normal if they are accessed inside of the data structure.
Because these data structures can contain unimplemented members, these members can only be accessed outside of the data structure using the derived data structure.
To create an __abstract__ data structure write the __abstract__ keyword before your data structure definition and after its access modifier.

//subtitle
Members

//text
Any data structure class member can me marked __abstract__ when the member is abstract it cannot have an implementation.


//subtitle
Classes

//text 
When a __class__ is __abstract__ the __class__ cannot be instanciated and must be inherited.

//code
abstract class MyClass
{
    Int myInt = 13135;
    abstract String myString;
}

class MySecondClass extend MyClass
{
    implement String myString = 'Hello World!';
}

// Results in an error.
MyClass myClass = MyClass();

// Printing the member myInt from MyClass and the implemented member myString.
MySecondClass mySecondClass = MySecondClass();
print(mySecondClass.myInt, mySecondClass.myString);

//subtitle
Static classes

//text
When a __static class__ is __abstract__ the members can only be accessed via the derived __static class__.

//code
abstract static class MyClass
{
    Int myInt = 13135;
    abstract String myString;
}

static class MySecondClass extend MyClass
{
    implement String myString = 'Hello World!';
}

// Results in an error.
print(MyClass.myInt);

// Printing the member myInt from MyClass and the implemented member myString.
print(MySecondClass.myInt, MySecondClass.myString);

//subtitle
Enums

//text
When an __enum__ is __abstract__ the members can only be accessed via the derived __enum__.

//code
abstract enum MyEnum
{
    MyEnumValue = 13135;
    abstract MySecondEnumValue;
}

enum MySecondEnum extend MyEnum
{
    implement MySecondEnumValue = 'Hello World!';
}

// Results in an error.
print(MyEnum.MyEnumValue);

// Printing the member MyEnumValue from MyEnum and the implemented member MySecondEnumValue.
print(MySecondEnum.MyEnumValue, MySecondEnum.MySecondEnumValue);


//title
Implement (abstract, implement)

//text
An abstract member is a class member that can be overwritten or must be implemented in the fist non abstract child class.
Only abstract or open classes can contain abstract members.
When an abstract member is defined in a open class the member must have a default implementation while this is not required in an abstract class.
An abstract member is created by writing the __abstract__ keyword before the class member and after its access modifier.
The following members can be marked as abstract:

//tablehead
Member`         Unimplemented state`                    Example

//table
Variables`      Uninitialized`                          abstract String myString;
Methods`        Bodyless and without auto assignment`   abstract Void myMethod();
Constructors`   Bodyless and without auto assignment`   abstract MyClass();        

//code
class MyClass
{
    public abstract String myString = 'Hello World!';

    public abstract Void myMethod(){
        // Your abstract method code.
    }
}

The __implement__ keyword is used to implement or overwrite an abstract member from the super class in the child class.
The acces modifier of the abstract member cannot be modified on implementation and does not have to be defined in the the child class.
Members only have to be implemented when the abstract member has no default implementation else optionaly overwrite the current implementation.
Note that the implementation is defined in the child class but the member is still part of the original class.
Note that abstract members with no default implementation are only required to be implemented in non abstract classes.

The implemented variable must have the same type and identifier as the original abstract member.
The implemented method must have the same return type, identifier and parameter body as the abstract member.

//code
abstract class MyClass
{
    public abstract Int myInt = 0;

    private abstract String myString = 'Value';

    protected abstract Void myMethod(Int myValue){
        print(value);
    }

    private protected abstract Void mySecondMethod(Int myValue);
}

class MySecondClass extend MyClass
{
    implement Int myInt;

    implement String myString = 'Overwritten value';

    protected implement Double myDouble = 3.3;
    
    public implement Void myMethod(Int value);
    
    implement Void mySecondMethod(String value){
        print(value + "Overwritten");
        // Your overwritten method code.
    }

    protected implement Void myThirdMethod(Double value){
        print(value);
        // Your overwritten method code.
    }
}

//text
When an abstract member is implemented the implemented member is still part of its original class.
If the member already had a default implementation then the original implementation will be overwritten.
It is also impossible to create an instance of a class that has unimplemented members anywhere in the inheritance tree.
These rules unlock the possibility to still acces abstract members from their original class (object) even when the object is casted.

//code
abstract class MyClass
{
    public void myMethod();
}

class MySecondClass extend MyClass
{
    // Defining an implemention for the method myMethod that becomes part of the MyClass class.
    implement void myMethod(){
        print('Hello World!');
    }
}

MySecondClass mySecondClass = MySecondClass();
mySecondClass.myMethod(); 
// Prints: Hello World!

//Casting the open class to the abstract class
MyClass myClass = mySecondClass<MyClass>; 
myClass.myMethod(); 
// Calling myMethod its implemention defined in MySecondClass and part of MyClass and prints: Hello World!

//text
When implementing an abstract member that already has an implementation, the original implementation will be overwritten and inaccessible.
The new implentation will be part of the member its original class and can be accessed from their original class (object) even when the object is casted.

//code
class MyClass
{
    public abstract void myMethod(){
        print('Hello World!');
    }
}

class MySecondClass extend MyClass
{
    implement void myMethod(){
        print('Implement Hello World!');
    }
}

MySecondClass mySecondClass = MySecondClass();
mySecondClass.myMethod(); 
// Prints: Implement Hello World!

//Casting the open class to the abstract class
MyClass myClass = mySecondClass<MyClass>; 
myClass.myMethod(); 
// Calling myMethod its implemention defined in MySecondClass and part of MyClass and prints: Implement Hello World!

//text
When you are inheriting from two class that have the same abstract member they can be implemented using their class as alias.
Note the class alias may be used even when the members do not have the same identifier.

//code
abstract class MyClass
{
    void myMethod();
    void mySecondMethod();
}

abstract class MySecondClass
{
    void myMethod();
}

class MyThirdClass extend MyClass, MySecondClass
{
    implement void MyClass.myMethod(){}
    implement void MySecondClass.myMethod(){}

    implement void MyClass.mySecondMethod(){}
}

//title
Sealing (sealed)

//text
The __sealed__ keyword is used to create a class that can not be inherited.
Note that sealed classes cannot contain abstract members.
This can be achieved by writing the __sealed__ keyword before the class definition.

//code
sealed class MyClass
{
    Int myInt = 13135;

    Void myMethod(Int value){
        // Your method code.
    }
}

//title
Static (static)

//text
A __static__ class is a class that can only contain static members, can not be instanciated and can only inherit other static classes.
When a static class is created without specifing a structure modifier the static class will automatically be an open static class.
Static members are members that are a part of the class itself and not of an individual object instance, these members can be added to any class.
When a value of a static variable changes the change will occur in every instance of this class.
Note that a static method cannot access non static members.
Note that a static member cannot be abstract.

//code
static class MyClass
{
    public static Int myInt = 13135;

    public static Void myMethod(Int value){
        print(myInt, value);
    }
}

//sublitle
Sealing (sealed)

//text
The __sealed__ keyword can be used to create an enum that cannot be inherited.
This can be achieved by writing the __sealed__ keyword before your enum definition and after the access modifier.

sealed static class MyClass{
    String myString = 'Hello World!';
}

//subtitle
Abstraction (abstract, implement)

//text
An abstract static class is a static class that must be inherited to be able to access its members
The members form these classes can 

//text
Static members can be accessed using their class identifier and the dot operator (__.__).

//code
MyClass.myMethod(MyClass.myInt);

//title
Super class (super) and this class (this)

//text
When having defined a class member with the same identifier in the child class as in the parent class, the child class will override the parent identifier.
Use the __this__ keyword to access the current instance of the class.
Use the __super__ keyword to access the current instance of the class its the inherited classes.

//code
class MyClass
{
    public Int myInt = 13135;

    public Void myMethod(Int value){
        // Your method code.
    }
}

class MySecondClass extend MyClass
{
    init(){
        // Calling myMethod in MySecondClass.
        myMethod();

        // Calling myMethod in MyClass.
        super.myMethod(myInt);

        // Calling myMethod in MySecondClass.
        this.myMethod(myInt);
    }

    public Void myMethod(Int value){
        // Your method code.
    }
}

//title
Class extension (extend)

//text
The __extend__ keyword can be used to add members to an already defined class.
To create a class extension write __extend__ followed by a class name and ending with __{}__.
extension classes work almost the same as normal classes and can only be defined inside a namespace.
The constructor and the destructor of the original class can not be overwritten/redefined/overloaded.
Multiple extensions can be created for the same class.
Optionally use the __super__ keyword to access public members from the original class or from extensions.

//code
extend String
{
    public Char[] myArray = "Hello World!";
    public String{} toSet(){
        // Your code to convert a string to a set.
    }
}

String myString = 'Hello World!';
print(myString.toSet(), myString.myArray);

//text
The extended members can also be used in inheritance.

//code
class MyClass
{
    public Int myInt = 13135;
}

extend MyClass
{
    public Void printMyInt(){
        print(this.myInt);
    }
}

class MySecondClass extend MyClass
{
    init(){
        // Calling inherited extension method inside the class.
        printMyInt();
    }
}

// Calling inherited extension method via a class instance.
MySecondClass mySecondClass = MySecondClass();
mySecondClass.printMyInt();

//title
Constructor

//text
Constructors can be used to run a method when an instance of a class is created.
To create a constructor write the __init__ keyword followed by __()__ ending with __{}__.
To create a named constructor write __.__ followed by the name of the constructor after the __init__ keyword of a normal constructor.

//code
class MyClass
{
    init(){
        // Your constructor code.
    }

    init.MyNamedConstructor(){
        // Your named constructor code.
    }
}

// Your constructor used.
MyClass myClass = MyClass();
// Your named constructor used.
myClass = MyClass.MyNamedConstructor();

//subtitle
Linked (:)

//text
Linked constructors can be used to call other constructors via a constructor.
To call a linked constructor write __:__ after the parameter body of any constructor followed by the __init__ keyword and ending with __()__.
For a named constructor write __.__ followed by the name of the constructor after the __init__ keyword of a normal linked constructor.

//code
class MyClass
{
    init() : init.MySecondNamedConstructor(){
        // Your constructor code.
    }

    init.MyNamedConstructor() : init(){
        // Your named constructor code.
    }

    init.MySecondNamedConstructor(){
        // Your second named constructor code.
    }
}

//title
Destructor (~)

//text
The destructor can be used to run a method when an instance of a object is deleted.
Adding a destructor to a class is not required.
No parameters can be added to the destructor parameter body.

//code
class MyClass
{
    ~init{
         // Your destructor code.
    }
}

//title
Methods

//subtitle
Initialize (init) //Still in progress not improving yet

//text
To create a constant or read only variable in your class, but you want to initialize it in the constructor, use the keyword __init__.
The variable can also be initialized via short assignment.
The variable can only be overwritten in the constructor scope. 

//code
class MyClass
{
    init const Int myInt;
    init readonly String myString = "Hello World!";

    init(this.myInt, myString){
        this.myString = myString;
        // Your constructor code.
    }
}

//subtitle
Getters (get) and Setters (set)

//text
Getters and setters are methods that will be run when the specific field is accessed.
To create a setter or getter write the following structure; __get__ or __set__, a variable declaration for the setter, __{}__.
Access modifiers can be added to the getter and setter. These access modifiers override the (default) access modifiers of the field.
Getters and setters can only be defined directly beneath their field in the same (extension) class.
When defining the getter a value with the same type as the field must be returned.
When defining the setter one parameter of any type is required.
Note that in the example the integer was initialially private, but has become public because of the getter and setter.
//This will not work because of recursion maybe i can do something with the get and set keywords.

//code
class MyClass
{
    private Int myInt = 13135;

    public get{
        return myInt + 1;
    }

    public set Int value{
        this.myInt = value - 1;
    }
}

//text
If only the access modifiers of a field needs to be changed the shorthand can be used.
To write the access modifier shorthand hand write any access modifier followed by get or set.
You are not required to use both the getter and setter on the same field. If one is omitted it becomes private.

//code
class MyClass
{
    private set public get Bool? myBoolean;
}

//text
The __only__ keyword can be used to create read only or write only fields.
When using the only keyword the getter or setter can only be used by itself.

//code
class MyClass
{
    public get only String? myString;
            
    public set only Bool? myBoolean;
}

//subtitle
Class methods

//text
Classes have a couple of custom method that can be used to achieve more custom functinallity.
To declare a class method write the following structure; any type, __this__, Any parameters and assignment parameter, __{}__.
Mace has the followed class methods.

//tablehead
Name`           parameters`             example

//table
Call`           Tuple`                  Void this(){}
Index read`     Array`                  Void this[]{} 
Set`            Set`                    Void this{}{}
Index write`    Array and assignment`   Void[]String value{}
Access read`    Label`                  Void this Label value{}
Access write`   Label and assigning`    this Label value String secondValue{}      

//code
class MyClass
{
    Void this(String myParameter){
        // Your object call code.
    }

    Void this[String myParameter]{
        // Your object index method code.
    }

    Void this{String myParameter}{
        // Your object set method code.
    }

    this[String myParameter] String value{
        // Your object index write method code.
    }

    Void this Label.accessor{
        // Your object access read method code.
    }

    this Label.accessor String value{//Still needs syntax work
        // Your object access write method code.
    }
}

//chapeter
Enumerations (enum)

//text
The __enum__ keyword is used to create an __enum__.
To create an __enum__ write __enum__ followed by the name of the enum ending with __{}__.
When an enum is created without specifing a structure modifier the enum will automatically be an open enum.
enums can be compared with a static classes that only contain constant fields.
The fields inside of an enum are comma separated.
Note that no keywords can be added to the fields inside an enum.
Enums can only be defined inside of a namespace.

//code
enum MyEnum
{
    MyFirstEnumValue,
    MySecondEnumValue,
    MyThirdEnumValue
}

//text
To access an enum write the enum name followed by the field name.

//code
MyEnum myEnum = MyEnum.MyFirstEnumValue;

if(myEnum == MyEnum.MySecondEnumValue){
    // Your code.
}

//title
Inheritance (extend)

//text
The __extend__ keyword can be used to inherit enum fields from other enums.
To inherit fields from other enums write __extend__ after the child enum followed by comma separated enum names.
Note that the enum type must be the same type as the child enum and no fields can have the same identifier.

//code
enum MyEnum
{
    MyEnumValue,
}

enum MySecondEnum extend MyEnum
{
    // The field of MyEnum is inherited in this enum.
    MySecondEnumValue
}

//subtitle
Abstraction (abstract)

//text
The __abstract__ keyword can be used to create an enum that can only be inherited.
This can be achieved by writing the __abstract__ keyword before your enum definition and after the access modifier.
The values of an abstract enum cannot be accessed using its own type but can only be access via the child enum.

//code
abstract enum MyEnum
{
    MyEnumValue
}

enum MySecondEnum extend MyEnum
{
    MySecondEnumValue
}


MyEnum myEnum = MySecondEnum.MyEnumValue;

//subtitle
Sealing (sealed)

//text
The __sealed__ keyword can be used to create an enum that cannot be inherited.
This can be achieved by writing the __sealed__ keyword before your enum definition and after the access modifier.

//code
sealed enum MyEnum
{
    MyEnumValue
}


//chapter
Functions

//title
Data types

//text
To store a method in a variable use the method data type.

//code
class GoogleMaps
{
    Void Func(GoogleMapsController googleMapsController) onInit;

    public GoogleMaps(this.onInit){
        System.sleep(5);
        onInit(GoogleMapsController());
    }
}

class GoogleMapsController
{
    Void goToXY(){

    }
}

GoogleMaps googleMaps = GoogleMaps((GoogleMapsController googleMapsController){
    googleMapsController.goToXY();
});

//title
Lambda funtions

//text
There are multiple ways to define a method.

//code
Int addTwoNumbers0(Int a, Int b){
    return a + b;
}
Int addTwoNumbers1(Int a, Int b) => a + b;
Int Func(Int a, Int b) addTwoNumbers2 = (Int a, Int b) {return a + b};
Int Func(Int a, Int b) addTwoNumbers3 = (Int a, Int b) => a + b;

//title
Function extension (extend)

//text
The __extend__ keyword can be used to bind any number of functions to an already existing function.
This can be achieved by writing __extend__ followed by the function identifier and ending with a parameter and code body.
The binded function must have the same parameter body as the original function.
When the function gets called the original function will be called first then the binded functions will be called.
Note that function extensions can not have a return type.

//code
Void myMethod(Int myInt){
    print('Hello World!');
}

extend myMethod(){
    print('Extended code');
}

myMethod();
/*
    myMethod prints:
    Hello World!
    Extended code
*/

//text
The __as__ keyword can be used to bind a method definition to a method extension.
This can be achieved by writing __as__ after the extended method identifier followed by a new method identifier.
When calling the bined method the code from the extend method will not be called.

//code
Void myMethod(Int myInt){
    print('Hello World!');
}

extend myMethod as mySecondMethod(){
    print('Extended code');
}

myMethod();
/*
    myMethod prints:
    Hello World!
    Extended code
*/

mySecondMethod();
// Prints: 'Extended code'

//text
Nested functions or function variables can also be extended by referencing their object.

//code
class MyClass
{
    Void myMethod(){
        // Your method code.
    }
}

MyClass myClass = MyClass();
extend myClass.myMethod(){
    // Your extended method code.
}

//code
Void Func() myMethod = (){
    // Your method code.
};

extend myMethod(){
    // Your extended method code.
}

//chapter
Primitive variables

//text
Mace has the following primitive data types.
To declare a variable write a variable type followed by a unique identifier;
To define a declared variable write a __=__ followed by a value of the type of the variable after the variable name.

//tablehead
Primitive`  Meaning

//table
String`     Stores any array of characters.
Char`       Stores any singular character.
Byte`       Stores any whole number between -128 and 127
Short`      Stores any whole number between -32,768 and 32,767    
Int`        Stores any whole number between -2,147,483,648 and 2,147,483,647.
Long`       Stores any whole number between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807.
Float`      Stores any floating point number, between           
Double`     Stores any floating point number, between -1.7*10^308 and 1.7*10^308.
Bool`       Stores true or false.
Type`       Stores any type

//title
Strings (String)

//text
A __String__ is an object that stores an array of characters.
You can define a __String__ by using __''__ or __""__.

//code
String myString = "Hello World!";
myString = 'Hello World!';

//subtitle
Concatenation

//text
To concatenate two strings use the plus operator.
You can concatenate literal strings and string variables.

//code
String myString = 'Hello ' + "World!";
// myString becomes: 'Hello World!'
String myDoubleString = myString + myString;
// myDoubleString becomes: 'Hello World!Hello World!'

//subtitle
Escape characters (\)

//text
Use escape characters to use characters that would normaly have a different meaning or to give a character a different meaning.
To use escape character use __\__.
Escape characters can be used in a __String__ or __Char__.

//tablehead
Escape chapter` Meaning

//table
\n`             New line
\b`             Backspace
\t`             Tab
\$`             A literal __$__
\\`             A literal __\__
\'`             A literal __'__
\"`             A literal __"__

//code
String myNewLine = 'This is on line one,\nAnd this on line two';
/*
// When printed:
'This is on line one,
And this on line two'
*/      
String myBackspace = 'This removes the last character from this string\b';
// When printed: 'This removes the last character from this strin'
String myTab = 'This adds a tab\tin this string';
// When printed: 'This adds a tab   in this string'
String myDollarSign = 'This escapes the use of the \$ for using interpolation';
// myDollarSign becomes: 'This escapes the use of the $ for using interpolation'
String myBackslash = 'This escapes the use of the \\ for escaping characters';
// myBackslash becomes: 'This escapes the use of the \ for escaping characters'
String mySingleQuote = 'This escapes the use of the \' for creating a string or char';
// mySingleQuote becomes: 'This escapes the use of the ' for creating a string or char'
String myDoubleQuote = "this escapes the use of the \" for creating a string or char";
// myDoubleQuote becomes: 'this escapes the use of the " for creating a string or char'

//subtitle
Interpolation

//text
String interpolation can be used to add values to a string literal.
Mace has the following methods to interpolate values into a string:

//tablehead
Syntax`     Functionallity

//table
__$__`      Interpolate a single value
__$()__`    Interpolate an expression
__${}__`    Interpolate the return of an anonymous function

When only interpolating one value a whitespace must be added between the value and the next part of the String.

//code
String myName = 'Jack';

//Intoperlatating a single value
String myString = 'Hello $myName how are you doing?';
// myString becomes: 'Hello Jack how are you doing?'

//Intoperlatating an expression
myString = 'Hello $(myName + " how") are you doing?';
// myString becomes: 'Hello Jack how are you doing?'

//Intoperlatating the return of an anonymous function
myString = 'Hello ${String how = ' how'; return myName + how} are you doing?';
// myString becomes: 'Hello Jack how are you doing?'

//subtitle
Indexing

//text
Read a character from a __String__ by using __[]__.
Indexing starts at index zero.

//code
String myString = 'Hello World!';
Char myChar = myString[6];
// myChar becomes: 'W'

//title
Characters (Char)

//text
A __Char__ is a primitive that stores just one character.
You can define a __Char__ by using __''__ or __""__.

//code
Char myChar = "H";
myChar = '!';

//subtitle
Concatenation

//text
If you want to concatenate two characters you need to store them in a __String__.

//code
String myTwoChars = 'H' + "!";
// myTwoChars becomes: 'H!'

//subtitle
Escape characters (\)

//text
To use escape characters in a __String__ use __\__.
Escape characters can be used in a __String__ or __Char__.

//code
Char mySingleQuoteChar = '\'';
// mySingleQuoteChar becomes: '''
Char myDoubleQuoteChar = "\"";
// myDoubleQuoteChar becomes: '"'

//title
Integers (Short), (Int), (Long)

//text
An __Int__ is a primitive that can store any whole number between -2,147,483,648 and 2,147,483,647.

//code
Int myInt = 13135;

//subtitle
Int with a different base

//text
When using a number from a different base use one of the following prefixes.

//tablehead
Prefix` Meaning`    Base

//table
0b`     Binary`     2
0o`     Octal`      8
0x`     Hexadecimal`16

//code
Int myBinaryInt = 0b01010;
// myBinaryInt becomes: 20
Int myOctalInt = 0o37461;
// myOctalInt becomes: 16177
Int myHexadecimalInt = 0xD24AF;
// myHexadecimalInt becomes: 861359

//subtitle
Indexing

//text
To get a digit from an __Int__, access the __Int__ in the same way as how you would get a __Char__ from a __String__.
Indexing starts at index 0.

//code
Int myInt = 13135;
Int myIndexedInt = myInt[2];
// myInexedInt becomes: 1

//title
Doubles (Double,Float)

//text
A __Double__ is a primitive that can store any floating point number, between -1.7*10^308 and 1.7*10^308 with a precision of 15 digits.
To define a __Double__ use a dot where the decimal digits should be.
Note that a __Double__ is not perfectly precise when used in calculations.

//code
Double myDouble = 13135.13135;

//text
Literal Int values and numbers from different bases are allowed to be assigned to a __Double__.

//code
Double myIntegerDouble = 13135;
// myIntegerDouble becomes: 13135.0
Double myBinaryDouble = 0b01010;
// myBinaryDouble becomes: 20.0
Double myOctalDouble = 0o37461;
// myOctalDouble becomes: 16177.0
Double myHexadecimalDouble = 0xD24AF;
// myHexadecimalDouble becomes: 861359.0

//subtitle
Exponent of 10 (e)

//text
multiply a number to 10 to the power of any integer number by use the suffix __e__.
You can use a positive or negative integer exponent.

//code
Double myDouble = 4.3e5;
// myDouble becomes: 430000.0
myDouble = 3.8e-2;
// myDouble becomes: 0.038

//title
Booleans (Bool), (true), (false)

//text
A __Bool__ is a primitive that can store either a zero or a one.
Because there are only two states, the 0 is also equal to __false__, and the 1 is equal to __true__;
All datatypes that are empty or null are false if casted to an boolean.
If they contain a value they are true.

//tablehead
Datatype`       Empty value

//table
Int`            0
Double`         0.0
String`         '' or ""
String[]`       []
String()`       ()
String{}`       {}
(String:Int){}` {}

//code
Bool myBoolean = true;
myBoolean = <Bool>0
// myBoolean becomes: false

myBoolean = <Bool>13135
// myBoolean becomes: true

//chapter
Operators

//title
Arithmetic

//text
Arithmetic operators are mostly used so to apply mathematical equations to values.
Some of these operators can be used on other objects like String, arrays and tuples.

//tablehead
Operator`   Name`                       Example

//table
+`          Addition`                   myInt + 5
++`         Prefix Increment`           ++myInt    
++`         Postfix Increment`          myInt++   
-`          Negation or Subtraction`    myInt - 5    
--`         Prefix Decrement`           --myInt    
--`         PostFix Decrement`          myInt--  
*`          Multiplication`             myInt * 5
/`          Division`                   myInt / 5
**`         Exponentiation`             myInt ** 5
%`          Modulation`                 myInt % 5          

//subtitle
Addition (+)

//text
The __+__ operator is used when any two numbers need to be added to each other.

//code
Int myInt = 1 + 3;
// myInt becomes: 4

//text
The __+__ can also be used to concatenate strings, arrays, sets, maps or tuples.
Concatenating strings, arrays, sets, maps or tuples will add the values together and return a new __String__, array, set, map or tuple.

//code
String myString = 'Hello ' + 'World!';
// myString becomes: 'Hello World!'
Int[] myArray = [1,3] + [2,4];
// myArray becomes: [1,3,2,4]
Int() myTuple = (1,3) + (2,4);
// myTuple becomes: (1,3,2,4)
Int{} mySet = {1,4,2} + {2,3,8};
// mySet becomes: {1,4,2,3,8}
Map<String,Int> myMap = {'firstValue': 1} + {'secondValue': 2};
// myMap becomes: {'firstValue': 1, 'secondValue': 2}

//subtitle
Prefix Increment (++)

//text
The __++__ operator is used to first increment a number by one then returning the new value.

//code
Int myInt = 13135;
print(++myInt)
// Prints: 13136
// myInt becomes: 13136

//subtitle
PostFix Increment (++)

//text
The __++__ operator is used to first return the value of a number then incrementing the value by one.

//code
Int myInt = 13135;
print(myInt++)
// Prints: 13135
// myInt becomes: 13136

//subtitle
Negation or Subtraction (-)

//text
The __-__ operator is used when a number needs to be negated or two numbers need to be subtracted from each other.

//code
Int myInt = -1;
myInt = 4 - 3;
// myInt becomes: 1
myInt = 3 -4;
// myInt becomes: -1

//text
The __-__ operator can also be used to subtract strings, arrays, maps, sets or tuples.
The order of the elements matter when the object is orderd else the order does not matter.
Searching and removing will start at the end.

//code
String myString = 'Hello World!' - ' World!';
// myString becomes: 'Hello'
Int[] myArray = [1,2,4,3] - [2,4];
// myArray becomes: [1,3]
Int() myTuple = (1,2,4,3) - (2,4);
// myTuple becomes: (1,3)
Int{} mySet = {1,4,2} - {2,3,8};
// mySet becomes: {1,4}
Map<String,Int> myMap = {'firstValue': 1, 'secondValue': 2} - {'firstValue': 1};
// myMap becomes: {'secondValue': 2}

//subtitle
Prefix Decrement (--)

//text
The __--__ operator is used to decrement a number by one then returning the new value.

//code
Int myInt = 13135;
print(--myInt)
// Prints: 13134
// myInt becomes: 13134

//subtitle
PostFix Decrement (--)

//text
The __--__ operator is used to first return the value of a number then decrementing the value by one.

//code
Int myInt = 13135;
print(myInt--)
// Prints: 13135
// myInt becomes: 13134

//subtitle
Multiplication (*)

//text
The __*__ operator is used when any two numbers need to be multiplied.

//code
Int myInt = 3 * 4;
//myInt becomes: 12

//text
The __*__ operator can also be used to multiply strings, sets or arrays.
Multiplying a __String__, tuple or array will repeat the values inside and return a new __String__, tuple or array.
Note you must use an integer value when multiplying with a number.
When multiplying a set with another set, the result will be a cartesian product.

//code
String myString = 'Hello World!' * 2;
// myString becomes: 'Hello World!Hello World!'
Int[] myArray = [1,2,3,4] * 2;
// myArray becomes: [1,2,3,4,1,2,3,4]
Int() myTuple = (1,2,3,4) * 2;
// myTuple becomes: (1,2,3,4,1,2,3,4)
Int{} mySet = {1,2,3,4} * {5,6,7,8};
// mySet becomes: {(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,5),(4,6),(4,7),(4,8)}

//subtitle
Division (/)

//text
The __/__ operator is used when any two numbers need to be divided by each other.

//code
Int myInt = 4 / 2;
// myInt becomes: 2

//text
The __/__ operator can also be used to any orderd object.
Dividing an orderd object by a value the count of the occurrences of the given value will be returned.
Values can not be counted multiple times even if patterns overlap.
Note that the order matters.

//code
Int countString = 'Hello World!' / 'l';
// countString becomes: 3
Int countArray = [1,2,3,4,2,3] / [2,3];
// countArray becomes: 2
countArray = [3,3,3] / [3,3];
// countArray becomes: 1
Int countTuple = (1,2,3,4,2,3) / (2,3);
// countTuple becomes: 2

//subtitle
Exponentiation (**)

//text
The __**__ operator is used when a number needs to be exponented by an other number.

//code
Int myInt = 3 ** 2;
// myInt becomes: 9

//subtitle
Modulation (%)

//text
The __%__ operator is used when the remainder of a number needs te be found after subtraction by an other number just before it becomes negative.

//code
Int myInt = 5 % 2;
// myInt becomes: 1

//text
The __%__ operator can also be used to modulate strings or arrays.
Modulating a __String__ or array will remove all the occurrences of the value(s) of the right hand side from the left hand side and return a new __String__ or array.
Values can not be removed multiple times even if patterns overlap.
Note that the order matters.

//code
String myString = 'Hello World!' % 'l';
// myString becomes: 'Heo Word!'
Int[] myArray = [1,2,3,4,2,3] % [2,3];
// myArray becomes: [1,4]
myArray = [3,3,3] % [3,3];
// myArray becomes: [3]
Int() myTuple = (1,2,3,4,2,3) % (2,3);
// myTuple becomes: (1,4)

//title
Bitwise depended

//text
Depended bitwise operators can be used to manipulate two bit sequences in relation to each other.
The result will be a combination of the two via specific rules.

//tablehead
Operator`   Name

//table
&`          Bitwise AND
|`	        Bitwise OR
^`	        Bitwise XOR

//subtitle
Bitwise AND (&)

//text
The __&__ operator is used to check if both bits are one. 
If both bits are one, a one will be returned in the new bit sequence.
If one or both bits are zero, a zero will be returned in the new bit sequence.

//code
Int myInt = 0b00000000000000000000000000001100 & 0b00000000000000000000000000001010;
// myInt becomes: 0b00000000000000000000000000001000 which is 8

myInt = 12 & 10;
// myInt becomes: 8

//text
The __&__ operator can also be used to get the intersect of two strings, arrays, tuples, sets or types.
Note that the order does not matter.

//code
String myString = '1235' & '245';
// myString becomes: '25'

Int[] myArray = [1,2,3,5] & [2,4,5];
// myArray becomes: [2,5]

Int() myTuple = (1,2,3,5) & (2,4,5);
// myTuple becomes: (2,5)
 
Int{} mySet = {1,2,3,5} & {2,4,5};
// mySet becomes: {2,5}

type MyType =  (String | Double) & (Int | Double)
// MyType becomes: Double

//subtitle
Bitwise OR (|)

//text
The __|__ operator is used to check if one or both bits are one. 
If one or both bits are one, a one will be returned in the new bit sequence.
If both bits are zero, a zero will be returned in the new bit sequence.

//code
Int myInt = 0b00000000000000000000000000001100 | 0b00000000000000000000000000001010;
// myInt becomes: 0b00000000000000000000000000001110 which is 14

myInt = 12 | 10;
// myInt becomes: 14

//text
The __|__ operator can also be used to get the union of two strings, arrays, tuples, sets or types.

//code
String myString = '1235' | '245';
// myString becomes: '12345'

Int[] myArray = [1,2,3,5] | [2,4,5];
// myArray becomes: [1,2,3,4,5]

Int() myTuple = (1,2,3,5) | (2,4,5);
// myTuple becomes: (1,2,3,4,5)
 
Int{} mySet = {1,2,3,5} | {2,4,5};
// mySet becomes: {1,2,3,4,5}

type MyType = String | Int;
// MyType becomes: String | Int

//subtitle
Bitwise XOR (^)

//text
The __^__ operator is used to check if one of both bits is one. 
If one of both bits is one, a one will be returned in the new bit sequence.
If one or both bits are zero, a zero will be returned in the new bit sequence.

//code
Int myInt = 0b00000000000000000000000000001100 ^ 0b00000000000000000000000000001010;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 ^ 10;
// myInt becomes: 6

//text
The __^__ operator can also be used to get the symmetric difference of two strings, arrays, tuples, sets or types.

//code
String myString = '1235' ^ '245';
// myString becomes: '134'

Int[] myArray = [1,2,3,5] ^ [2,4,5];
// myArray becomes: [1,3,4]

Int() myTuple = (1,2,3,5) ^ (2,4,5);
// myTuple becomes: (1,3,4)
 
Int{} mySet = {1,2,3,5} ^ {2,4,5};
// mySet becomes: {1,3,4}

type MyType = (String | Double) ^ (Int | Double);
// MyType becomes: String | Int


//title
Bitwise independed

//text
Independed bitwise operators can be used to manipulate a single bit sequence.

//tablehead
Operator`   Name

//table
~`	        Bitwise NOT
>>`	        Bitwise signed right shift
<<`	        Bitwise signed left shift
>>>`        Bitwise unsigned right shift
<<<`        Bitwise unsigned left shift

//subtitle
Bitwise NOT (~)

//text
The __~__ operator is used to flip the bits of the operand. 

//code
Int myInt = ~0b00000000000000000000000000001100;
// myInt becomes: 0b11111111111111111111111111110011 which is -13

myInt = ~12;
// myInt becomes: -13

//subtitle
Bitwise signed right shift (>>)

//text
The __>>__ operator is used to shift every bit in a bit sequence a given amount of places to the right.
The most right bits will be lost and the empty spaces after the MSB at the left are filled with zeros if the MSB is a zero and with ones of the MSB is a one.

//code
Int myInt = 0b00000000000000000000000000001100 >> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 >> 2;
// myInt becomes: 3

myInt = 0b11111111111111111111111111110100 >> 1;
// myInt becomes: 0b11111111111111111111111111111010 which is -6

myInt = -12 >> 2;
// myInt becomes: -3

//subtitle
Bitwise signed left shift (<<)

//text
The __<<__ operator is used to shift every bit in a bit sequence a given amount of places to the left.
The most left bits after the MSB will be lost and the empty spaces at the right are filled with zeros.

//code
Int myInt = 0b00000000000000000000000000001100 << 1;
// myInt becomes: 0b00000000000000000000000000011000 which is 24

myInt = 12 << 2;
// myInt becomes: 48

myInt = 0b11111111111111111111111111110100 << 1;
// myInt becomes: 0b11111111111111111111111111101000 which is -24

myInt = -12 << 2;
// myInt becomes: -48

//subtitle
Bitwise unsigned right shift (>>>)

//text
The __>>>__ operator is used to shift every bit in a bit sequence a given amount of places to the right.
The most right bits will be lost and the empty spaces at the left are filled with zeros.

//code
Int myInt = 0b00000000000000000000000000001100 >>> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 >>> 2;
// myInt becomes: 3

myInt = 0b11111111111111111111111111110100 >>> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 2147483642

myInt = -12 >>> 2;
// myInt becomes: 1073741821

//text
The __>>>__ operator can also be used to remove characters from the end of strings or items from the end of arrays or tuples.

//code
String myString = '12345' >>> 1;
// myString becomes: '1234'

Int[] myArray = [1,2,3,4,5] >>> 1;
// myArray becomes: [1,2,3,4]

Int() myTuple = (1,2,3,4,5) >>> 1;
// myTuple becomes: (1,2,3,4)

//subtitle
Bitwise unsigned left shift (<<<)

//text
The __<<<__ operator is used to shift every bit in a bit sequence a given amount of places to the left.
The most left bits will be lost and the empty spaces at the right are filled with zeros.

//code
Int myInt = 0b00000000000000000000000000001100 <<< 1;
// myInt becomes: 0b00000000000000000000000000011000 which is 24

myInt = 12 <<< 2;
// myInt becomes: 28

myInt = 0b11111111111111111111111111110100 <<< 1;
// myInt becomes: 0b11111111111111111111111111101000 which is -24

myInt = -12 <<< 2;
// myInt becomes: -48

//text
The __<<<__ operator can also be used to remove characters from the start of strings or items from the start of arrays or tuples.

//code
String myString = '12345' <<< 1;
// myString becomes: '2345'

Int[] myArray = [1,2,3,4,5] <<< 1;
// myArray becomes: [2,3,4,5]

Int() myTuple = (1,2,3,4,5) <<< 1;
// myTuple becomes: (2,3,4,5)

//title
Null safety

//text
Null safety operators are used to manage null values in your program to avoid runtime errors.

//tablehead
Operator`   Name`                   Example

//table
?`          Nullability indicator`  Int? myInt = null;
?`          Optional chaining`      myObject?.toString(); or myArray?[1]; or myMap?['key'];
??`         Null-coalescing`        myString ?? 'Default value';

//subtitle
Nullability indicator (?)

//text
The __?__ operator can be used to indicate that a type is nullable.
To indicate that a type is nullable write a __?__ after the variable type.
When a variable has a nullable type the variable can store null.

//code
String myString = null;
// Results in an error because myString cannot be null.
String? myString = 'Hello World!';
// Indicating that myString can be null.

//text
To indicate that array members are nullable write any type followed by a __?__ ending with __[]__.

//code
Int[] myArray = null;
// Results in an error because myArray cannot be null.
Int[] myArray = [1,4,null];
// Results in an error because myArray cannot contain null values.

//code
Int[]? myArray = null;
// Indicating that myArray can be null.
Int?[] myArray = [1,4,null];
// Indicating that myArray can contain null values.

//text
To indicate that the return type of a method is nullable write any a __?__ after the return type.

//code
String myMethod(){
    return null;
}
// Results in an error because the return type of myMethod cannot be null.

//code
String? myMethod(){
    return null;
}
// Indicating that the return type of myMethod can be null.

//code
String Func() myMethod = null;
// Results in an error because myMethod cannot be null.
String Func() myMethod = (){
    return null;
}
// Results in an error because the return type of myMethod cannot be null.

//code
String Func()? myMethod = null;
// Indicating that myMethod can be null.
String? Func() myMethod = (){
    return null;
}
// Indicating that the return type of myMethod can be null.

//code
String Func() myMethod = {
    return null;
}
// Results in an error because the return type of myMethod cannot be null.

//code
String? Func() myMethod = {
    return null;
}
// Indicating that the return type of myMethod can be null.

//subtitle
Optional chaining (?)

//text
The __?__ operator can be used on nullable variables to indicate optional chaining.
When null occurs in a statement the statement will be exited while an expression also returns null.

//subtitle
Members

//text
To access an object member write any object variable followed by __?.__ ending with any member.

//code
Int? myInt = null;
String? myString = myInt?.toString();
// myString becomes: null.
myInt = 13135;
myString = myInt?.toString();
// myString becomes: '13135'.


//code
class MyClass
{
    Int? myInt;
}

MyClass myClass = null;
myClass?.myInt = 13135;
// Statement exits after myClass
myClass = MyClass();
myClass?.myInt = 13135;
// myClass.myInt becomes: 13135

//subtitle
Functions

//text
To call a function write any function variable followed by __?__ ending with any parameter body.
Any array, tuple or anonymous object parameter body can be used.

//code
String Func()? myMethod = null;
String? myString = myMethod?();
// myString becomes: null
myMethod = () {
    return 'Hello World!';
};
String? myString = myMethod?();
// myString becomes: 'Hello World!'

//code
class MyClass
{
    Void Func()? myMethod;
}

MyClass myClass = MyClass();

myClass.myMethod?();
// Statement exits after myClass
myClass.myMethod = (){
    print('Hello World!');
}
myClass.myMethod?();
// Statement prints: 'Hello World!'

//subtitle
Indexing

//text
To access index members write any variable followed by __?__ ending with __[]__.

//code
String[]? myArray = null;
myArray?[0] = 'Hello World!';
// Statement exits after myArray
myArray = [];
myArray?[0] = 'Hello World!';
// myArray[0] becomes: 'Hello World!'

//code
String[]? myArray = null;
String? myString = myArray?[0];
// myString becomes: null.
myArray = [];
myArray?[0] = 'Hello World!';
// myString becomes: 'Hello World!'

//subtitle
Null-coalescing (??)

//text
The __??__ operator can be used to add default values to nullable variables.

//code
String mySecondString = myString ?? 'Default value';
// mySecondString becomes the value of myString when myString is not null.
// When myString is null mySecondString becomes 'Default value'.

//title
Ternary (? :)

//text
The __? :__ operators are used to create an if statement that can ben used inside of expressions.
To use the ternary operator write to following structure; a boolean expression, __?__, an expression of any type, __:__, an expression of any type.

//code
myBoolean = false;
String myString = myBoolean ? 'True' : 'False';
// myString becomes: 'False'

//title
Assignment

//text
Assignment operators are used to assign or for reassigning a value to a variable.
For more information about combined assignment operators check their chapters.

//tablehead
Operator`   Name`                                       Combined operator`  Example`            Same as

//table
=`          Assignment`                                 None`               myInt = 0;`         None
+=`         Addition assignment`                        +`                  myInt += 5;`        myInt = myInt + 5; 
++`         Prefix Increment assignment`                ++`                 ++myInt;`           myInt = myInt + 1;
++`         PostFix Increment assignment`               ++`                 myInt++;`           myInt = myInt + 1;
-=`         Negation or Subtraction assignment`         -`                  myInt -= 5;`        myInt = myInt - 5; 
--`         Prefix Decrement assignment`                --`                 --myInt;`           myInt = myInt - 1;
--`         PostFix Decrement assignment`               --`                 myInt--;`           myInt = myInt - 1;
*=`         Multiplication assignment`                  *`                  myInt *= 5;`        myInt = myInt * 5; 
/=`         Division assignment`                        /`                  myInt /= 5;`        myInt = myInt / 5; 
**=`        Exponentiation assignment`                  **`                 myInt **= 5;`       myInt = myInt ** 5; 
%=`         Modulation assignment`                      %`                  myInt %= 5;`        myInt = myInt % 5;
&=`         Bitwise AND assignment`                     &`                  myInt &= 5;`        myInt = myInt & 5; 
|=`         Bitwise OR assignment`                      |`                  myInt |= 5;`        myInt = myInt | 5; 
^=`         Bitwise XOR assignment`                     ^`                  myInt ^= 5;`        myInt = myInt ^ 5; 
~~`         Bitwise NOT assignment`                     ~`                  myInt~~;`           myInt = ~myInt;
>>=         Bitwise signed right shift assignment`      >>`                 myInt >>= 5;`       myInt = myInt >> 5; 
<<=`        Bitwise signed left shift assignment`       <<`                 myInt <<= 5;`       myInt = myInt << 5; 
>>>=        Bitwise signed right shift assignment`      >>>`                myInt >>>= 5;`      myInt = myInt >>> 5;  
<<<=`       Bitwise unsigned left shift assignment`     <<<`                myInt <<<= 5;`      myInt = myInt <<< 5; 
??=`        Null-coalescing assignment`                 ??`                 myInt ??= 5;`       myInt = myInt ?? 5; or myInt = myInt == null ? 5 : myInt;
&&=`        Logical AND assignment`                     &&`                 myBoolean &&= true;`myBoolean = myBoolean && true;
||=`        Logical OR assignment`                      ||`                 myBoolean ||= true;`myBoolean = myBoolean || true;
^^=`        Logical XOR assignment`                     ^^`                 myBoolean ^^= true;`myBoolean = myBoolean ^^ true;
!!`         Logical NOT assignment`                     !`                  myBoolean!!;`       myBoolean = !myBoolean;

//subtitle
Assignment (=)

//text
The __=__ is used to assign a literal value or variable to a variable.

//code
Int myInt = 0;
Int mySecondInt = myInt + 5;
// mySecondInt becomes: 5

//title
Comparison

//text
Comparison operators are used to compare two values with each other to return a boolean.

//tablehead
Operator`   Name`                       Example

//table
==`         Equal to`                   myInt == 6
!=`         Not equal to`               myInt != 6
>`          Greater than`               myInt > 6
>=`         Greater than or equal to`   myInt >= 6
<`          Less than`                  myInt < 6
<=`         Less than or equal to`      myInt <= 6

//subtitle
Equal to (==)

//text
The __==__ operator can be used to check if two values are equal.

//code
if(myInt == 5){
    // Code that executes when myInt is equal to 5.
}

//subtitle
Not equal to (!=)

//text
The __!=__ operator can be used to check if two values are not equal.

//code
if(myInt != 5){
    // Code that executes when myInt is not equal to 5.
}

//subtitle
Greater than (>)

//text
The __>__ operator can be used to check if the left operand is greater than the right operand.

//code
if(myInt > 5){
    // Code that executes when myInt greater than 5.
}

//text
The __>__ operator can also be used on two strings, arrays, tuples or sets to check if the left operand is a proper superset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
Bool myBoolean = '12' > '2';

myBoolean = [1,2] > [2];

myBoolean = (1,2) > (2,);

myBoolean = {1,2} > {2};

//subtitle
Greater than or equal to (>=)

//text
The __>=__ operator can be used to check if the left operand is greater than or equal to the right operand.

//code
if(myInt >= 5){
    // Code that executes when myInt greater than or equal to 5.
}

//text
The __>=__ operator can also be used on two strings, arrays, tuples or sets to check if the left operand is a superset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
Bool myBoolean = '12' >= '2';
myBoolean = '12' >= '12';

myBoolean = [1,2] >= [2];
myBoolean = [1,2] >= [1,2];

myBoolean = (1,2) >= (2,);
myBoolean = (1,2) >= (1,2);

myBoolean = {1,2} >= {2};
myBoolean = {1,2} >= {1,2};

//subtitle
Less than (<)

//text
The __<__ operator can be used to check if the left operand is less than the right operand.

//code
if(myInt < 5){
    // Code that executes when myInt less than 5.
}

//text
The __<__ operator can also be used on two strings, arrays, tuples or sets to check if the left operand is a proper subset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
Bool myBoolean = '2' < '12';

myBoolean = [2] < [1,2];

myBoolean = (2,) < (1,2);

myBoolean = {2} < {1,2};

//subtitle
Less than or equal to (<=)

//text
The __<=__ operator can be used to check if the left operand is less than or equal to the right operand.

//code
if(myInt <= 5){
    // Code that executes when myInt less than or equal to 5.
}

//text
The __<=__ operator can also be used on two strings, arrays, tuples or sets to check if the left operand is a subset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
Bool myBoolean = '2' <= '12';
myBoolean = '12' <= '12';

myBoolean = [2] <= [1,2];
myBoolean = [1,2] <= [1,2];

myBoolean = (2,) <= (1,2);
myBoolean = (1,2) <= (1,2);

myBoolean = {2} <= {1,2};
myBoolean = {1,2} <= {1,2};

//title
Logical

//text
Logical operators are used to compare two booleans with each other to return one boolean.

//tablehead
Operator`   Name`           Example

//table
&&`         Logical AND`    true && true     
||`         Logical OR`     false || true
^^`         Logical XOR`    false ^^ true
!`          Logical NOT`    !false

//subtitle
Logical AND (&&)

//text
The __&&__ operator is used to evaluate two boolean expressions. When both expressions are evaluated to true the logical AND expression is evaluated to true.
To use the logical AND operator, write a boolean expression followed by __&&__ and ending with another boolean expression.

//code
if(myBoolean && mySecondBoolean){
    // Code that executes when myBoolean and mySecondBoolean are true.
}

//subtitle
Logical OR (||)

//text
The __||__ operator is used to evaluate two boolean expressions. When at least one expression is evaluated to true the logical OR expression is evaluated to true.
To use the logical OR operator, write a boolean expression followed by __||__ and ending with another boolean expression.

//code
if(myBoolean || mySecondBoolean){
    // Code that executes when myBoolean and/or mySecondBoolean is true.
}

//subtitle
Logical XOR (^^)

//text
The __^^__ operator is used to evaluate two boolean expressions. When only one expression is evaluated to true the logical XOR expression is evaluated to true.
To use the logical XOR operator, write a boolean expression followed by __^^__ and ending with another boolean expression.

//code
if(myBoolean ^^ mySecondBoolean){
    // Code that executes when myBoolean or mySecondBoolean is true.
}


//subtitle
Logical NOT (!)

//text
The __!__ operator can be used to negate/invert a boolean value.
To use the logical not operator, write __!__ followed by a boolean expression.

//code
if(!myBoolean){
    // Code that executes when myBoolean is false.
}

//title
Logical Comparison

//text
Logical Comparison operators are used to compare two values with each other.
These operators are different to normal comparison because Logical Comparison operators let you chain multiple comparison operations to the same value.

//tablehead
Operator`   Name`                           Example`            Same as

//table
&==`        And equal to`                   myInt > 5 &== 7`    myInt > 5 && myInt == 7
&!=`        And not equal to`               myInt > 5 &!= 7`    myInt > 5 && myInt != 7 
&>`         And greater than`               myInt < 7 &> 5`     myInt < 5 && myInt > 7 
&>=`        And greater than or equal to`   myInt < 7 &>= 5`    myInt < 5 && myInt >= 7 
&<`         And less than`                  myInt > 5 &< 7`     myInt > 5 && myInt < 7 
&<=`        And less than or equal to`      myInt > 5 &<= 7`    myInt > 5 && myInt <= 7
&in`        And in collection or iterable`  myInt > 5 &in [5,6]`myIny > 5 && myInt in [5,6] 
|==`        Or equal to`                    myInt > 5 |== 3`    myInt > 5 || myInt == 3
|!=`        Or not equal to`                myInt > 5 |!= 3`    myInt > 5 || myInt != 3
|>`         Or greater than`                myInt < 7 |> 5`     myInt < 5 || myInt > 7
|>=`        Or greater than or equal to`    myInt < 7 |>= 5`    myInt < 5 || myInt >= 7
|<`         Or less than`                   myInt > 5 |< 3`     myInt > 5 || myInt < 3
|<=`        Or less than or equal to`       myInt > 5 |<= 3`    myInt > 5 || myInt < 3
|in         Or in collection or iterable`   myInt > 5 |in [1,2]`myInt > 5 || myInt in [1,2]
^==`        Xor equal to`                   myInt > 5 ^== 3`    myInt > 5 ^^ myInt == 3
^!=`        Xor not equal to`               myInt > 5 ^!= 3`    myInt > 5 ^^ myInt != 3
^>`         Xor greater than`               myInt < 7 ^> 5`     myInt < 5 ^^ myInt > 7
^>=`        Xor greater than or equal to`   myInt < 7 ^>= 5`    myInt < 5 ^^ myInt >= 7
^<`         Xor less than`                  myInt > 5 ^< 3`     myInt > 5 ^^ myInt < 3
^<=`        Xor less than or equal to`      myInt > 5 ^<= 3`    myInt > 5 ^^ myInt < 3   
^in         Xor in collection or iterable`  myInt > 5 ^in [5,6]`myInt > 5 ^^ myInt in [5,6]              

//chapter
Control statements

//text
Control statements are statements that direct the flow of your code to a desired path.

//title
Branching

//text
Branching statements are used when you want to branch your code in a well defined path.

//subtitle
If (if)

//text
The __if__ keyword is used to create a block of code that can only be executed under a specfied condition.
The code body of an if statement only gets executed when the input boolean expression is evaluated to __true__.

//code
if(myBoolean){
    // Code that executes when myBoolean is true.
}

if(myInt > 13135){
    // Code that executes when myInt is greater than 13135.
}

//subtitle
Else (else)

//text
The __else__ keyword is used to bind a block of code to one of the followed statements:

//table     
if
else if
for
while
do while

//text
An else statement binded to an __(else) if__ statement only gets executed when the previous __(else) if__ statement is evaluated to __false__.

//code
if(myBoolean){
    // Code that executes if myBoolean is true.
}
else{
    // Code that executes if myBoolean is false.
}

if(myBoolean){
    // Code that executes if myBoolean is true.
} 
else if(mySecondBoolean){
    // Code that executes if myBoolean is false and mySecondBoolean is true.
}
else{
    // Code that executes if both myBoolean and mySecondBoolean are false.
}

//text
An else statement binded to a __for__ or __(do) while__ statement will only be executed when the statement finishes execution without having encountered a __break__ statement.

//code
for(Int myInt in myArray){
    if(myInt == 13135){
        break;
    }
}
else{
    // Code that executes if myArray does not contain 13135.
}

Int i = 0;
while(i < myArray.length){
    if(myArray[i] == 13135){
        break;
    }
    i++;
}
else{
    // Code that executes if myArray does not contain 13135.
}

do{
    if(myInt == 1){
        break;
    }
    myInt /= 2;
}while(myInt > 1)
else{
    // Code that executes if myInt does not perfectly divide to 1.
}

//subtitle
Else if (else if)

//text
The __else if__ keywords are used to create a block of code that only gets executed when the previous __(else) if__ statement is evaluated to __false__ and the current __else if__ statement is evaluated to __true__.
The __else if__ statement can only be bounded to an __if__ or __else if__ statement and can be stacked as many times as needed.

//code
if(myBoolean){
    // Code that executes when myBoolean is true.
}else if(mySecondBoolean){
    // Code that executes when myBoolean is false and mySecondBoolean is true.
}

// Stacked else if statements.
if(myBoolean){
    // Code that executes when myBoolean is true.
}else if(mySecondBoolean){
    // Code that executes when myBoolean is false and mySecondBoolean is true.
}else if(myThirdBoolean){
    // Code that executes when both myBoolean and mySecondBoolean are false and myThirdBoolean is true.
}

//subtitle
Switch (switch), (on), (break), (continue)

//text
The __switch__ keyword is to create a block of code that can contain any number of __on__ statements.
The __on__ keyword is used to create a block of code that gets executed when the input value is equal to the input value from the __switch__ statement.
After the execution of the code body of an __on__ statement the __switch__ will stop further execution unless the __continue__ statement is used.
When an __on__ statement has no input body the statement acts like a default case and will always be executed if the __switch__ statement reaches this statement.
Note that this __on__ statement can only be defined once and can only be defined at the end of the __switch__ statement after the other __on__ statements.
A __switch__ statement can be created using the following syntax.

//code
switch(myInt)
{
    on(5){
        // Code that executes when myInt is 5.
    }
    on(6){
        // Code that executes when myInt is 6.
    }
    on{
        // Code that ececutes when myInt is not 5 or 6.
    }
}

//text
When an __on__ statement needs to be executed under a more complex condition the comparison and logical comparison operators can be used.
The __in__ operator can also be used to check if a collection contains the input value from the __switch__ statement.
These more complex expressions can created by extending the expression with logical comparison operators or by starting the expression with an __in__ or comparison operator.

//code
switch(myInt)
{
    on(5 |== 6){
        // Code that executes when myInt is 5 or 6.
    }
    on(> 6){
        // Code that executes when myInt is greater than 6.
    }
    on(in [1, 2, 3]){
        // Code that executes when myInt is 1, 2 or 3.
    }
}

//text
The __continue__ keyword can be used to continue checking __on__ statements when an __on__ statement already has found a match. 
Note that the code after the __continue__ statement does not get executed.

//code
switch(myInt)
{
    on(5 |== 6){
        // Code that executes when myInt is 5 or 6.
        continue;
    }
    on(6){
        // Code that executes when myInt is 6.
    }
}

//text
__switch__ statements can also besides __on__ statements contain any other code statement.
Note that the __on__ statements must stay in the top level of the __switch__ statement.

//code
switch(myInt)
{
    String myString = 'Hello World!';
    on(5){
        print(myString);
    }
    Double myDouble = 13135;
    on(6){
        print(myDouble);
    }
}

//title
Looping

//text
Loops are used to iterate over sequences of code that need to run for a specified amount of times.

//subtitle
For (for), (in)

//text
The __for__ keyword is used to define a block of code that can be executed multiple times.
Inside of the input of the __for__ loop you need to define how many times or over which collection or iterable you want to loop.
The __in__ keyword is used to bind a variable to a given collection of items you want to loop over.
For every iteration of the loop the next element in the iterable or collection will be stored in the binded variable.
This variable can now be accessed in the code body of the __for__ loop.

//code
Int[] myArray = [1, 3, 1, 3, 5];
for(Int myInt in myArray){
    print(myInt);
    // Code that executes for every value in myArray.
}

//text
Unpacking capabilities can be used on any of the collection or iterable values.

//code
(String:Int){} myMap = {'FirstValue':4, 'SecondValue':9};
for(String myKey:Int myValue in myMap){
    print(myKey, myValue);
    // Code that executes for every key value pair in myMap.
}

//text
If you want to loop over multiple collections or iterables in the same loop write your __in__ statements with commas seperated.
The for loop will execute its body the amount of iterations the smallest collection or iterable has.

//code
for(String myString in myArray, Int myIndex in ..){
    print(myString, myIndex);
    // Code that executes for every value in myArray and in the range from 0 to max int size.
}

//text
In some cases you want a loop to execute its body a precise amount of times without using a binded variable.
This can be achieve by writing a __for__ loop with any integer has input value.

//code
for(13135){
    // Code that executes exactly 13135 times.
}

//text
//Might remove because its functionality can be achieved with a while or for in loop.
The __for__ loop can also be used to loop a specificly specfied amount of times by defining two code statements and one boolean expression.
The first code statement will be executed once before the first iteration of the loop and is used to declare a variable.
The boolean expression will be executed before each iteration. When evaluated to __true__ the code block of the __for__ loop will be executed.
The second code statement will be executed at the end of every iteration and is used to modify the declared variable.

//code
for(Int i = 0; i < 10; i++){
    // Code that executes for as long as i is less than 10.
}

//subtitle
While (while), (do)

//text
The __while__ keyword is used to define a block of code that gets executed while a boolean expression is evaluated to __true__.
The boolean expression gets evaluated before every iteration, this means that when the expression is evaluated to __false__ on the first iteration the code never gets executed.

//code
while(myBoolean){
    // Code that executes as long as myBoolean is true.
}

//text
The __do__ keyword is used to move the code block from the __while__ loop above the __while__ loop so the code block always gets executed at least once.
The boolean expression gets evaluated after every iteration, this means that when the expression is evaluated to __false__ on the first iteration the code gets executed once.

//code
do{
    // Code that executes at least once, after which it executes as long as myBoolean is true.
}while(myBoolean)


//subtitle
Break and continue (break), (continue)

//text
The __break__ and __continue__ keywords can be used to control the flow of a __for__ or __(do) while__ loop.
The __break__ statement is used to exit out of a loop, this will ensure that the optionaly binded else statement will not be executed.
The __continue__ statement can be used to stop the current iteration of the loop and continue on to the next iteration.
Note that the code after a __break__ or __continue__ statement does not get executed.

//code
for(Int i = 0; i < 10; i++){
    // Code that executes for as long as i is less than or equal to 7.
    if(i == 5){
        continue;
    }
    else if(i == 7)
    {
        break;
    }
    // Code that executes for as long as i is less than 7 and not is 5.
}

//title
Error handling

//subtitle
Try catch (try), (catch)

//text
The __try__ and __catch__ keywords are used to catch and handle errors that can occur at runtime.
Use the __try__ keyword to create a block of code that can pass a trown error to the __catch__ statement.
Use the __catch__ keyword to bind a block of code to the __try__ statement to catch and handle its errors.
An __Exception__ object can be access in the catch statement to check what exacly went wrong, if the exception object is not used it may be omitted.
A __try catch__ statement can be created using the following syntax.

//code
try{
    // Code that gets checked for errors at runtime to pass them to the catch statement.
}catch(Exception e){
    // Code that executes when an error has occurred in the try statement.
}

// Omitted exception object.
try{
    // Code that gets checked for errors at runtime to pass them to the catch statement.
}catch{
    // Code that executes when an error has occurred in the try statement.
}

//title
Single line statements

//text
When a statement only has to execute a single line of code the __{}__ brackets may be omitted.

//code
if(myBoolean)
    print('true');
else
    print('false');    

//title
Control expressions

//text
Any control statement can also act like a function that gets called immediately, also called a control expression.
These expressions work exactly the same as a normal function that gets called immediately.
This means that the return type and the keywords __async__ and __stash__ can be defined before the expression. 
The __return__ and __yield__ statements can also be used to control the flow of the expression.
One exception for these expressions is that in case of the expression body syntax the __=>__ operator may be omitted.

A control expression can be created in a couple of different ways:
- Writing the __async__ or __stash__ keyword before the a control statement.

//code
async if(myBoolean){
    if(mySecondBoolean)
        return;
    // Code that executes if myBoolean is true and mySecondBoolean is false. 
}
else{
    if(myThirdBoolean)    
        return;
    // Code that executes if both myBoolean and myThirdBoolean are false.    
}

- Writing the return type of the expression before a control statement.
Void if(myBoolean){
    if(mySecondBoolean)
        return; // Returning out of the if statement.
    // Code that executes if myBoolean is true and mySecondBoolean is false. 
}
else{
    if(myThirdBoolean)    
        return; // Returning out of the else statement.
    // Code that executes if both myBoolean and myThirdBoolean are false. 
}

- Writing the control statement at a place where an expression is expected.
In this case the type does not have to be defined and can be inferred.
Int myString = if(myBoolean) 13135 else 53131;

//subtitle
(if), (else if), (else)

//text
Stacked __if__, __else if__, and __else__ expressions can only return a non nullable type if all the expressions return a non nullable value and the else expression is present.
Note that the return type or the keywords  __async__ and __stash__ can only be defined before the if expression and not the __else if__or __else__ expressions.

//code
Int myInt = if(myBoolean){
    return 13135;
}
else if(mySecondBoolean){
    return 53131;
}
else{
    return 13135 * 53131;
}

// Using expression body.
myInt = if(myBoolean) 13135 else if(mySecondBoolean) 53131 else 13135 * 53131;

//subtitle
(for), (while), (do while)

//text
The return statement in a loop expression will act slightly different, the return statement only returns one value and continues to the next iteration of the loop.
Because of this feature the loop will return its values with commas separated and can only be defined in a collection definition.
When the __else__ expression is binded to a loop t he value will return and added to the comma separated values.

//code
Int[] myArray = [
    for(5){
        return 13135;
    }
];

// Using expression body.
myArray = [for(5) 13135]

//code
Int[] myArray = [
    while(myBoolean){
        return 13135;
    }
]

// Using expression body.
myArray = [while(myBoolean) 13135];

//code
Int[] myArray = [
    do{
        return 13135;
    }while(myBoolean)
]

// Using expression body.
myArray = [do 13135 while(myBoolean)];

//text
The __yied__ keyword can be used to return one value and continue executing the current iteration of the loop.
This unlocks the possibility to return values multiple values and at different places in the __for__ loop or the optionaly binded __else__ expression.

//code
Int[] myArray [for(5){
    if(myBoolean){
        // If myBoolean is true 13135 will be returned but the loops continues to execute.
        yield 13135;
    }
    // The value 53131 will always be executed at the end of the loop.
    return 53131;
}]

//text
The __break return__ keywords can be used to return one value and break out of the loop to only return one value.
Note that when the __break return__ statement is used in the loop that you are not able to use the __return__ or __yield__ statements.
Except the return statement may be used in the optionaly binded __else__ expression and when returning a non nullable value this will ensure the return type of the loop expression to be non nullable.

//code
MyClass? myClass = for(myElement in myArray){
    if(myElement.myInt == 13135){
        break return myElement;
    }
}

//subtitle
(switch), (on)

//text
The __switch__ expression can only return a non nullable type if an empty(default) __on__ expression is present that returns a non nullable value.
When the return statement is called inside of an __on__ expression in a __switch__ expression the __switch__ will return the value and stops execution.

//code
Int myInt = switch(myString){
    on('1'){
        return 13135;
    }
    on('2'){
        return 53131;
    }
    on{
        return 13135 * 53131;
    }
};

// Using expression body.
myInt = switch(myString){
    on('1') 13135;
    on('2') 53131;
    on 13135 * 53131;
};

//text
The switch can only be written in expression body form if only on expressions are present.

Int myInt = switch(myString)
    on('1') 13135
    on('2') 53131
    on 13135 * 53131;

//subtitle
(try catch)

//text
The __try catch__ expression can only have a non nullable return type if both the __try__ and the __catch__ statements return a non nullable value.

//code
Int myInt = try{ 
    return myString<Int>;
}catch{
    return 13135;
};

// Using expression body.
myInt = try myString<Int> catch 13135;


//chapter
Types

//title
Literal types

//text
Literal types are build in types with a more generic or specific meaning.
Mace has the following literal types.

//table
class
enum
static class
open class
sealed class
abstract class
open enum
sealed enum
abstract enum
open static class
sealed static class
abstract static class
type

//subtitle
Class (class)

//text
The __class__ literal type can be used to store any class object.

//code
class MyClass {}

class MyClass = MyClass();

//subtitle
Enum (enum)

//text
The __enum__ literal type can be used to store any enum object.

//code
enum MyEnum
{
    MyEnumValue
}

enum MyEnum = MyEnum.MyEnumValue;


//subtitle
Type (type)

//text
The __type__ literal type is used to create custom types from currently existing types.
To create a custom type write the following structure; __type__, unique type name, __=__, type expression.
Custom types can only be defined inside a spaces, functions and classes.

//code
type MyType = String | Int;

//text
Custom types can be used at any place where a normal type can be used.

//code
type MyType = String | Int;
MyType myType = 13135;
// myType can now contain Int or String values.
myType = 'Hello World!'

//title
Type expressions

//text
Type expressions can be used to create more complex types.
These expressions can be used to create custom types, or they can be used at any place where a normal type can be used.
The following operators can be used in type expressions.

//tablehead
Operator`   Name`                   Example`                       Usage

//table
[]`         Array indicator`        String[] myArray`              Convert type to array type
()`         Tuple indicator`        String() myTuple`              Convert type to tuple type
{}`         Set indicator`          String{} mySet`                Convert type to tuple type        
?`          Nullability indicator`  String? myString`              Convert type to nullable type
*`          Pointer indicator`      String* myPointer`             Convert type to pointer type
&`          Reference indicator`    String& myReference`           Convert type to reference type
|`          Bitwise OR`             Int | String myIntString`      Create union of two types   
&`          Bitwise AND`            (Int | String) & Int myInt`    Create intersect of two types                 
^`          Bitwise XOR`            (Int | String) ^ Int myString` Create symmetric difference of two types

//subtitle
Array indicator ([])

//text
The __[]__ operator can be used to indicate that a type is an array type.
To create an array type write any type followed by __[]__.

//code
Int[] myArray = [1,2,3,4,5];

Int myInt = myArray[3];
// myInt becomes: 4

//text
The __[]__ operator can stacked to create multidimensional arrays.

//code
Int[][] = myMultidimensionalArray = [[1,2],[3,4]];

Int[] myArray = myMultidimensionalArray[0];
// myArray becomes: [1,2]
Int myInt = myMultidimensionalArray[0][1];
// myInt becomes: 2

//text
To specify the length of an array write any integer between the __[]__.

//code
Int[5] myArray = [1,2,3,4,5];

//code
Int[5] myArray = [1,2,3,4,5,6];
// Results in error.

//subtitle
Tuple indicator (())

//text
The __()__ operator can be used to indicate that a type is a tuple type.
To create an array type write any type followed by __()__.

//code
Int() myTuple = (1,2,3,4,5);

Int myInt = myTuple[3];
// myInt becomes: 4

//text
The __()__ operator can stacked to create multidimensional tuples.

//code
Int()() = myMultidimensionalTuple = ((1,2),(3,4));

Int() myTuple = myMultidimensionalTuple[0];
// myArray becomes: [1,2]
Int myInt = myMultidimensionalTuple[0][1];
// myInt becomes: 2

//text
To specify the length of a tuple write any integer between the __()__.

//code
Int(5) myTuple = (1,2,3,4,5);

//code
Int(5) myTuple = (1,2,3,4,5,6);
// Results in error.

//subtitle
Set indicator ({})

//text
The __{}__ operator can be used to indicate that a type is a set type.
To create an array type write any type followed by __{}__.

//code
Int{} mySet = {1,2,3,4,5};

//text
The __{}__ operator can stacked to create multidimensional sets.

//code
Int{}{} = myMultidimensionalSet = {{1,2},{3,4}};

//text
To specify the length of a set write any integer between the __{}__.

//code
Int{5} mySet = {1,2,3,4,5};

//code
Int{5} mySet = {1,2,3,4,5,6};
// Results in error.

//subtitle
Nullability indicator (?)

//text
The __?__ operator can be used to indicate that a type is a nullable type.
To create a nullable type write any type followed by __?__.

//code
String? myString = null;
// The type of myString becomes: String | Null
myString = 'Hello World!';

//subtitle
Pointer indicator (*)

//text
The __*__ operator can be used to indicate that a type is a pointer type.
To create a pointer type write any type followed by __*__.

//code
String myString = 'Hello World!';
String* myPointer = &myString;

String mySecondString = *myPointer;
// mySecondString becomes: 'Hello World!'

//text
The __*__ operator can be stacked to create chain pointers.

//code
String myString = 'Hello World!';
String* myPointer = &myString;
String** myChainPointer = &myPointer;

String* mySecondPointer = *myChainPointer;
// mySecondPointer becomes: the value of myPointer
String mySecondString = **myChainPointer;
// mySecondString becomes: 'Hello World!'

//subtitle
Reference indicator (&)

//text
The __&__ operator can be used to indicate that a type is a reference type.
To create a reference type write any type followed by __&__.

//code
String myString = 'Hello World!';

String& myReference = myString;
// myReference becomes: 'Hello World!' 

//subtitle
Bitwise OR (|)

//text
The __|__ operator can be used to get the union of two types.

//code
type MyType = Int | String;

MyType myIntString = 5
// myIntString can now contain Int or String values.
myIntString = 'Hello World!';

//subtitle
Bitwise AND (&)

//text
The __&__ operator can be used to get the intersect of two types.

//code
type MyType = (Int | Char | String) & (Double | Int | String);
// MyType becomes: Int | String

MyType myIntString = 5;
myIntString = 'Hello World!';
// myIntString can now contain Int or String values.

//subtitle
Bitwise XOR (^)

//text
The __^__ operator can be used to get the symmetric difference of two types.

//code
type MyType = (Double | Char | Int) ^ (Double | String | Char);
// MyType becomes: Int | String

MyType myIntString = 5;
// myIntString can now contain Int or String values.
myIntString = 'Hello World!';

//title
Generics (<>)

//text
Generic types are custom types that can be defined as parameters.
To declare generic types write the flowing structure; __<__, comma separated unique types, __>__.
To define generic types use the same structure with existing types as parameters.
When using a data structure with generic types the types may be omitted to use the type itself.
Generic types can be added to the following data structures.

//table
class
enum
type
function / method

//subtitle
Class (class)

//text
Generic types can be declared after the created class name.
Define the generic types after the class name when using the class type or when creating an instance of the class.
The generic types can be used inside the class or they can be used to define generic types from inherited classes or enums.

//code
class MyClass<MyGeneric>
{
    MyGeneric? myGeneric;
}

MyClass<String> myClass = MyClass<String>();
MyClass mySecondClass = MyClass<Int>()

//subtitle
Function / method (Func)

//text
Generic types can be declared before the __()__ when creating a method or function.
Define the generic types before the __()__ when calling a method or function or when using the method or function type.
The generic types can be used as return type, parameter type or inside the function or method.

//code
Void myMethod<MyGeneric>(){
    // Your method code.
}

Void Func<MyGeneric>() myMethod = {
    // Your method code.
};

//code
MyGeneric myMethod<MyGeneric>(MyGeneric myParameter){
    MyGeneric myGeneric = myParameter;
    return myGeneric;
}

MyGeneric Func<MyGeneric>(MyGeneric myParameter) myMethod = {
    MyGeneric myGeneric = myParameter;
    return myGeneric;
};

//subtitle
Type (type)

//text
Generic types can be declared after the created type name.
Define the generic types after the type name when using the type.
The generic types can be used in the type expression on the right hand side of the assignment.

//code
type MyType<MyGeneric> = Stack<MyGeneric> | String;

MyType<String> myType = Stack<String>();

//subtitle
Default type (=)

//text
The __=__ operator can be used to set a default type for a generic type.
To set a default type for a generic type write your generic type followed by __=__ ending with any type.
When a generic type has a default type the type can optionaly be omitted.

//code
class MyClass<MyGeneric = String>
{
   // Your class members.
}

MyClass myClass = MyClass();
// MyGeneric of myClass becomes: String
MyClass<Int> myClassSecond = MyClass<Int>()
// MyGeneric of myClassSecond becomes: Int

//subtitle
Constraint type

//text
Constraint types indicate that the generic type can only contain types of the constraint type.
To set a constraint type for a generic type write any type before your generic type.

//code
class JsonValue<(String | Int) JsonType>
{
    initialize JsonType value;
    JsonType(JsonType value){
        this.value = value;
    }
}

JsonValue<String> jsonStringValue = JsonValue<String>('Hello World!');
// jsonStringValue.value becomes: 'Hello World!'
JsonValue<Int> jsonIntValue = JsonValue<Int>(13135);
// jsonIntValue.value becomes: 13135

JsonValue<Bool> jsonBoolValue = JsonValue<Bool>(true);
// Results in error.

//title
Auto (auto)

//text
The __auto__ keyword can be used to use reference an expected type.
When defining any value the value is required to have a declared type.
This type can be referenced with the __auto__ keyword.

//code
Map<String,Int> myMap = auto();
Map mySecondMap = auto<String,Int>();

//code
Void Func() myMeyhod = auto(){};
Void Func(String myString) mySecondMethod = auto(String myString){};

//code
Int[] myArray = auto[];
[Int,String] mySecondArray = auto[13135, 'Hello World!']

//subtitle
Return

//text
The auto keyword can also be used to declare variables inside of functions this will referencing the return type of the function.

//code
Map<String,Int> myMethod(){
    auto myMap = auto();

    return myMap;
}

//code
[String myString,Int myInt] myMethod(){
    auto myArray = [13135, 'Hello World!'];

    return myArray;
}

//title
Type casting

//text
The __<>__ operator can be used to cast any value to a given type.
To cast a value write any value followed by any type between __<>__ brackets.

//code
Int myInt = 13135;
String myString = myInt<String>;
// myString becomes: '13135'

//code
String myString = '13135';
Int myInt = myString<Int>;
// myInt becomes: 13135

//subtitle
Defining

//text
Type casting methods can be declared in the class that needs to be casted to a different type.
To declare a type cast method write the following structure; __this__, __<__, type to cast to __>__, __{}__.
A value of the given type cast type must be returned.

//code
class MyClass
{
    this<String>{
        // You type casting code
        return 'Hello World!';
    }
}

MyClass myClass = MyClass();
String myString = myClass<String>;
// myString becomes: 'Hello World!';

//title
References and Pointers

//tablehead
Operator`   Name

//table
&`          Reference or Address-of operator
*`          Pointer or Dereference operator

//chapter
References

//text
The __&__ can be used to create a reference to a variable.
To create a reference write any datatype followed directly by __&__.
The reference can be used in the same way as a variable because it points to the same value at the same address.
Note that because the variable and the reference point to the same value, if the value of the variable is changed, the value of the reference is also changed.

//code
Int myInt = 0;
Int& myIntReference = myInt;
// myIntReference becomes: 0
myInt = 3;
// myIntReference becomes: 3

//text
A reference can be used in methods as a parameter.
This allowes manipulation of variables without creating new/temporary values.

//code
Int myInt = 0;
Void addTwo(Int& myIntReference){
    myIntReference += 2;
}
addTwo(myInt);
// myInt becomes: 2

//subtitle
Address-of operator

//text
The __&__ can also be used to get the address of a variable.

//chapter
Pointers

//text
The __*__ can be used to create a pointer to an address of a variable.
To create a pointer write any datatype followed directly by __*__.
Note that because the pointer points to an address, when assigning a pointer, an address must be given.

//code
Int myInt = 0;
Int* myPointer = &myInt;
// myPointer becomes: 0x61feb4

//subtitle
Dereference operator

//text
The __*__ can also be used to get the value of a given address.
The dereference operator makes it possible to work with pointers until the value is needed.
Note that if the value is a pointer as well, that pointer will be returned.

//code
Int myInt = 0;
Int* myPointer = &myInt;
Int mySecondInt = *myPointer;
myInt = 3;
// mySecondInt becomes: 0

//text
To create a pointer to another pointer use the corresponding amount of __*__.

//code
Int myInt = 0;
Int* myPointer = &myInt;
Int** myDoublePointer = &myPointer;
Int*** myTriplePointer = &myDoublePointer;
Int mySecondInt = ***myTriplePointer;
// mySecondInt becomes: 0

//chapter
Short assignment

//text
Short assignment can be used to replace variable declaration for an already declared variable.
When using short assignment the actual parameters or unpacking values are automatically assigned to the variables.
The keywords __this__ or __super__ may be used when using short assigning in classes.
Short assignment can be used in the following places:

//table
Parameter body
Array unpacking
Anonymous object unpacking

//title
Parameter body

//code
class MyClass
{
    String? myString;
    Int? myInt;

    init(this.myString, myInt){
        // Your constructor code.
    }

    Void myMethod(myString, this.myInt){
        // Your method code.
    }
}

MyClass myClass = MyClass(13135,'Hello World!');
// myClass.myInt becomes: 13135
// myClass.myString becomes: 'Hello World!'

myClass.myMethod(53131,'Updated value!');
// myClass.myInt becomes: 53131
// myClass.myString becomes: 'Updated value!'

//text
When only using short assignment in a function or constructor parameter body the body may be omitted.

class MyClass
{
    String? myString;
    Int? myInt;

    init(this.myString, myInt);

    Void myMethod(myString, this.myInt);
}

//title
Collection unpacking

//code
Int? myInt;
String? myString;

[myInt, myString] = [13135,'Hello World!'];
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//title
Set unpacking

//code
Int? myInt;
String? myString;

{myInt, myString} = {myInt:13135,myString:'Hello World!'};
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//chaper
Collections

//text
Collections can be used to store a sequence of values inside of one variable.
Mace has the following collection types.

//tablehead
Name`               Type`           Literal value

//table
Array`              Int[]`  	    Int[][] or []
Tuple`              Int()`          Int()() or ()
Set`                Int{}`          Int{}{} or {}

//title
Array ([])

//text
The __[]__ operator can be used to store a mutable orderd sequence of values.
Array elements can be added, updated or removed.

//code
Int[] myArray = [1,3,1,3,5];

myArray.add(9);
// myArray becomes: [1,3,1,3,5,9]

myArray[1] = 6;
// myArray becomes: [1,6,1,3,5,9]

myArray.remove[3];
// myArray becomes: [1,6,1,5,9]


//title
Tuple (())

//text
The __()__ operator can be used to store an immutable orderd sequence of values.
Tuple elements cannot be added, updated or removed.

//code
Int() myTuple = (1,3,1,3,5)

//subtitle
Single element

//text
To create a tuple or a tuple type with only one element write __(__ followed by any value or type and ending with __,)__.
The trailing comma is used to indicate the the type or value is a tuple and not the value or type between the __()__ brackets.

//code
(Int) myInt = (13135);
// myInt becomes: 13135

(Int,) myTuple = (13135,)

//title
Set ({})

//text
The __{}__ operator can be used to store a mutable unorderd sequence of unique values.
Set elements can be added, updated or removed.

//code
Int{} mySet = {1,3,1,3,5};
// mySet becomes: {1,3,5}

mySet.add(9);
// mySet becomes: {1,5,3,9}

mySet.remove(3);
// mySet becomes: {1,5,9}

mySet.replace(9,2);
// mySet becomes: {1,5,2}

//title
Type element

//text
Collection types can contain type elements.
To define type elements write comma seperated types inside of the collection type brackets.
The type elements indicate that the collection can only contain elements of those types at the specfied position.
The specfied position is only required for arrays and tuples not for sets.

//code
[Int,String] myArray = [13135,'Hello World!'];

(Int,String) myTuple = (13135,'Hello World!');

{Int,String} mySet = {'Hello World!',13135};

//subtitle
Element repeater

//Prototyping

//Maybe when the .. is used after an element its purpose is repeating the element.
//And when the .. is used before an element it is used to collect elements.
//It might be usefull to think about the functionallity of empty values what purpose do they serve can they be used for patern matching?

//code (Dynamic array)
Int[] myArray = [1,3,1,3,5];
Int[][..myUnpackArray] = myArray;

//code (other Dynamic array)
[Int..] myArray;
[..Int[] myUnpackArray] = myArray;

//code (sized array)
Int[..16] myArray;
Int[][16..myUnpackArray] = myArray;

//code (other sized array)
[Int..16] myArray;
[16..Int[] myUnpackArray] = myArray;

//code (multi type sized array)
Int[..8,String..8] myArray;
Int[][8..myIntegers,8..String[] myStrings] = myArray;

//code (other multi type sized array)
[Int..8,String..8] myArray;
..8[Int,String] myArray;
[8..Int[] myIntegers,8..String[] myStrings] = myArray;

//code
[Int..8,String..8] myArray;
[[8..Int] myIntegers,[8..String] myStrings] = myArray;

//code
[Int..8,String..8,Bool..8] myArray;
[[8..Int] myIntegers,[8..String,8..Bool] myboolStrings] = myArray;
[[8..Int] myIntegers,8..[String,Bool] myboolStrings] = myArray;

//code
[Int..8 myIntegers,String..8 myStrings,Bool..8 myBooleans] myArray;
//Easy
[Int[] myIntegers,String[] myStrings,Bool[] myBooleans] = myArray;
//Renaming
[myIntegers..Int[] Integers,myStrings..String[] Strings,myBooleans..Bool[] Booleans] = myArray;
//nested
[Int..8,[Bool..8,String..8] myStringIntegers] = myArray;
[8..Int[] myIntegers,myStringIntegers..[8..Bool[] myBooleans,8..String[] myStrings]]

Int[..16] myArray = [1,23,423,4,3,3,4,23,4,3,4,3,4,3,4,34,2,34]
[5:2..Int myIntegers] = myArray;
myArray..1:4;
myArray..1:5:-1;
myArray<1:4,value == test>;

//use dot when needed
myObject{
    print(myMember);
    String myMember = 'Hello World!';
    print(.myMember);
}

//use arrow functions
String myString = myObject => myMember + myFirstMember;

//use Int plus dot to acces parents
myObject.myNestedObject.myString = myObject.myString;
myObject.myNestedObject.myInt = myObject.myInt;
myObject.myNestedObject.myBoolean = myObject.myBoolean;

myObject.myNestedObject{
    myString = myObject.myString;
    myInt = myObject.myInt;
    myBoolean = myObject.myBoolean;
}

myObject{
    myNestedObject{
        myString = <1>.myString;
        myInt = <1>.myInt;
        myBoolean = <1>.myBoolean;
    }
}

<obj>
myObject{
    myNestedObject{
        myString = obj.myString;
        myInt = obj.myInt;
        myBoolean = obj.myBoolean;
    }
}

for(i in array){
    for(j in array){
        break;
        continue;
        <1>.break;
        <1>.continue;
    }
}

<loop>
for(i in array){
    for(j in array){
        break;
        continue;
        loop.break;
        loop.continue;
    }
}

Void myFunction(){
    Void mySecondFunction(){
        return;
        <1>.return;
    }
}

<fun>
Void myFunction(){
    Void mySecondFunction(){
        return;
        fun.return;
    }
}

String[Int[,<1>,<1> | Bool],]

//code (patern matching)
//Maybe empty values in comperisan will be ignored?
String myString = 'Hello World!';
if(myString == ('H', .., ..'World!')){
}

if(myString[0] == 'H' && myString[-1:-7] == 'World!'){

}

[Int,String] myArray = [13135,'Hello World!'];
[,String myString] = myArray;

//text
The element repeater can be used to indicate that a collection element must be repeated a specfied amount of times
To create a repeated collection element write the following structure before the element; __<__, any integer or __...__, __>__.
The element repeater can not be used inside set values because sets can not contain duplicate values.

//code
[Int..2,String] myArray = [13135,53131,'Hello World!'];
[Int..2,String] mySecondArray = [13135..2,'Hello World!'];
// mySecondArray becomes: [13135,13135,'Hello World!']

(Int..2,String) myTuple = (13135,53131,'Hello World!');
(Int..2,String) mySecondTuple = (13135..2,'Hello World!');
// mySecondTuple becomes: (13135,13135,'Hello World!')

{Int..2,String} mySet = {13135,'Hello World!',53131};
{Int..2,String} mySecondSet = {'Hello World!',13135..2};
// Results in error a set can not contain duplicate values.

//text
The ellips operator __...__ can be used to indicate a Dynamic repeater size between zero and the array size limit.
Any amount of ellips type elements can be added but the (sub)types must be different.
No type elements of the same (sub)type can be added in the same collection type.

//code
[Bool..,Int..,String] myArray = [true,false,13135,53131,1,3,'Hello World!'];

(Bool..,Int..,String) myTuple = (true,false,13135,53131,1,3,'Hello World!');

{Bool..,Int..,String} mySet = {true,13135,false,53131,'Hello World!',1,3};

//text
When the __...__ operator is used inside of a collection value the element will be repeated the minimal amount of times (the type element is declared for).

//code
[Int..,String] myArray = [13135..,'Hello World!'];
// myArray becomes: ['Hello World!']
[Int..3,String] mySecondArray = [13135..,'Hello World!'];
// mySecondArray becomes: [13135,13135,13135,'Hello World!']

(Int..,String) myTuple = (13135..,'Hello World!');
// myTuple becomes: ('Hello World!')
(Int..3,String) mySecondTuple = (13135..,'Hello World!');
// mySecondTuple becomes: (13135,13135,13135,'Hello World!')

//title
Defualt types and values

//text
Default types can be added before the collection brackets.
The default type can be applied to the following type elements.

//tablehead
Element`            example

//table
Empty`              [,Int] 
Labeled`            [myString,Int]    
Repeated`           [..5,Int]
Repeated labeled`   [..5 myStrings,Int]

//text
In the following examples the second variable declaration indicates how the variable would be defined without the default type.

//code
[Int,Int myInt,Int..3,Int..7 mySecondInt] mySecondArray = [];
Int[,myInt,..3,..7 mySecondInt] myArray = [];

(Int,Int myInt,Int..3,Int..7 mySecondInt) mySecondTuple = ();
Int(,myInt,..3,..7 mySecondInt) myTuple = ();

{Int,Int myInt,Int..3,Int..7 mySecondInt} mySecondSet = {};
Int{,myInt,..3,..7 mySecondInt} mySet = {};


//text
When no type elements are declared the default type will be added with ellips repetition.

//code
[Int..] mySecondArray = [];
Int[] myArray = [];

(Int..) mySecondTuple = ();
Int() myTuple = ();

{Int..} mySecondSet = {};
Int{} mySet = {};

//title
Labels

//text
labels can be added to collection type elements.
When a labels are added you can access the values by using their label.

//code
[Int myInt,String myString] myArray = [13135,'Hello World!'];

(Int myInt,String myString) myTuple = (13135,'Hello World!');

{Int myInt,String myString} mySet = {'Hello World!',13135};

Int myInt = myArray.myInt;
// myInt becomes: 13135
String myString myArray.myString;
// myString becomes: 'Hello World!'

//text
If the type element is repeated the label will return the specfied collection.

//code
[Int.. myIntegers,String myString] myArray = [13135,53131,'Hello World!'];

(Int.. myIntegers,String myString) myTuple = (13135,53131,'Hello World!');

{Int.. myIntegers,String myString} mySet = {13135,'Hello World!',53131};

Int[] myArray = myIntegers.myIntegers;
// myIntegers becomes: [13135,53131]
String myString myArray.myString;
// myString becomes: 'Hello World!'

//Unpacking example
[..Int[] myIntegers,String myString] = myArray;

//title
Omitted values

//text
When assigning a collection some elements can be omitted.
For orderd collections the position of the empty element matters also elements can only be omitted at the end of the collection.
For unorderd collections elements can only be empty if a type or type and label are given.
The following type members can be used.

//tablehead
Name`                   example

//table
Nullability indicator`  Int?
Defualt fallback`       Int!
Defualt value`          Int = 5

//subtitle
Nullability indicator (?)

//code
[Bool,Int?,String] myArray = [true,,'Hello World!'];
// myArray becomes: [true,null,'Hello World!']

(Bool,Int?,String) myTuple = (true,,'Hello World!');
// myTuple becomes: (true,null,'Hello World!')

{Bool,Int?,String} mySet = {'Hello World!',Int?,true};
// mySet becomes: {'Hello World!',null,true}

//subtitle
Defualt fallback (!)

//code
[Bool,Int!,String] myArray = [true,,'Hello World!'];
// myArray becomes: [true,0,'Hello World!']

(Bool,Int!,String) myTuple = (true,,'Hello World!');
// myTuple becomes: (true,0,'Hello World!')

{Bool,Int!,String} mySet = {'Hello World!',Int!,true};
// mySet becomes: {'Hello World!',0,true}

//subtitle
Defualt value (=)

//code
[Bool,Int = 13135,String] myArray = [true,,'Hello World!'];
// myArray becomes: [13135,'Hello World!']

(Bool,Int = 13135,String) myTuple = (true,,'Hello World!');
// myTuple becomes: (true,13135,'Hello World!')

{Bool,Int = 13135,String} mySet = {'Hello World!',Int,true};
// mySet becomes: {'Hello World!',13135,true}

//text
When a defualt type is added to a repeated type element the defualt type must be of the collection type given.
When no collection type is given the type will of of the collection itself.

//missing example

//chapter
Labels (Label)

//text
The __label__ keyword is used to store variable names.

//code
Label myLabel = labelValue;
// myLabel becomes: labelValue
myLabel = myLabel;
// myLabel becomes: labelValue

//text
The __$__ can be used to store the Label from an existing variable.

//code
Label myLabel = labelValue;
// myLabel becomes: labelValue
myLabel = $myLabel;
// myLabel becomes: myLabel

//title
Get values

//text
The __$__ operator can be used to get the value from a variable with the value of a label.
Note that type casting is required.

//code
String myString = 'Hello World!';
Label myLabel = $myString;

String myLabelString = myLabel$<String>;
// myLabelString becomes: 'Hello World!'

//text
The members of and object can also be access.

//code
class MyClass
{
    String myString = 'Hello World!';
    Int myInt = 13135;
}

MyClass myClass = MyClass();

Label myLabel = myString;
String myString = myClass.myLabel$<String>;
// myString becomes: 'Hello World!'

myLabel = myInt;
Int myInt = myClass.myLabel$<Int>;
// myInt becomes: 13135

//title
Label class methods

//text
The Label class method can be used to catch member accessing if the member does not exist in the class.

//code
class MyClass
{
    this Label{
        if(value = $stringMember){
            return 'Hello World!';
        }
        else if(value = $intMember){
            return 13135;
        }
    }
}

MyClass myClass = MyClass();
String myString = myClass.stringMember<String>;
//myString becomes: 'Hello World!'
Int myInt = myClass.intMember<Int>;
// myInt becomes: 13135

//chapter
Key and value pairs (:)

//text
The __:__ operator can be used to create a key value pair.
To create a key value pair write any type followed by __:__ and ending with another type.
When creating a key value pair variable __()__ need to be added around the type to differentiate the syntax from unpacking.
The key can be accessed by the key member.
The value can be access trough the value member, index method or label method.

//code
(String:String) myKeyValuePair = 'Key':'Value';
String myKey = myKeyValuePair.key;
// myKey becomes: 'Key'
String myValue = myKeyValuePair.value;
// myValue becomes: 'Value'

//code
(String:String) myKeyValuePair = 'Key':'Value';
myValue String = myKeyValuePair['Key'];
// myValue becomes: 'Value'

//code
(Label:String) myKeyValuePair = key:'Value';
myValue String = myKeyValuePair.key;
// myValue becomes: 'Value'

//title
Converting

//text
The __:__ operator can be used to to convert variables to key value pairs. 
To convert an existing variable write __:__ after any variable.
The key will be a name of the variable and the value will be the value of the variable.

//code
String myString = 'Hello World!';
(Label:String) myKeyValuePair = myString:;

//title
Unpacking

//text
Unpacking key value pairs can be used to map the key and value to in individual variables.
To unpack a key value pair write any variable declaration followed by a __:__ and ending with another variable declaration.

//code
(Int:String) myKeyValuePair = 13135:'Hello World!';
Int myInt:String myString = myKeyValuePair;
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//text
Unpacking both the key and value is not required the key or value can be unpacked individually.

(Int:String) myKeyValuePair = 13135:'Hello World!';
:String myString = myKeyValuePair;
// myString becomes: 'Hello World!'
Int myInt: = myKeyValuePair;
// myInt becomes: 13135

//subtitle
Key matching

//text
Key matching can be used to only unpack a key and value pair when the key matches the key from the key value pair.
To key match write any key value followed by a __:__ and ending with a variable declaration.
When the unpacking a non literal key value pair the value unpacking variable must be nullable.

//code
(Int:String) myKeyValuePair = 13135:'Hello World!';
53131:String? myString = myKeyValuePair;
// myString becomes: null
13135:myString = myKeyValuePair;
// myString becomes: 'Hello World!'

//text
When key matching is applied to collection unpacking the collection will be searched for a matching key and value pair.
Because the collection is searched the key matching unpacking member is not counted as a positional unpacking variable.

//code
['key':String value, Int myInt, 'secondKey':String secondValue] = ['key':'Hello World!', 'secondKey':'Value', 13135];

//code
[key:String,secondKey:String] = [secondKey:'Hello World!', key:'Value'];

//code
[key:[Int myInt,Int mySecondInt],secondKey:String secondValue] = [secondKey:'Hello World!', key:[1,2]];

type MyType = [myString:String,myInt:Int];

MyType myType = [myString: '',myInt:2];

Void myMethod(Int myInt,Int mySecondInt){

}

//chapter
Unpacking

//text
Unpacking can be used to unpack an object its members or elements in seperate variables.
The following objects can be unpacked.

//tablehead
Type`           Brackets

//table
Array`          []
Tuple`          ()
Key value pair` :
Class`          {}          

//text
To unpack an object write the following structure; opening bracket, comma or colon seperated variable declarations, closing bracket.
When unpacking a key value pair the colon is required.
When unpacking a class object the unpacking variable names must match the class member names.

//code
[Int myInt, String myString] = [13135, 'Hello World!'];

(Int myInt, String myString) = (13135, 'Hello World!');

Int myInt:String myString = 13135: 'Hello World!';

class MyClass
{
    Int myInt = 13135;
    String myString = 'Hello World!';
}

{Int myInt, String myString} = MyClass();

//title
Element repeater

//text
The element repeater can be used to unpack multiple members or elements of the same type in a collection.
To define an element repeater write the following any integer followed by __..__.

//code
[..3 Int[] myArray, String myString] = [13135, 53131, 'Hello World!'];

(..3 Int() myTuple, String myString) = (13135, 53131, 'Hello World!');

//text
The item repeater can also be used to skip values of positional collections.

//code
[..2, String myString] = [13135, 53131, 'Hello World!'];

(..2, String myString) = (13135, 53131, 'Hello World!');

//text
The ellips operator __..__ can be used to collect any number of elements.

//code
[..Int[] myArray, String myString] = [13135,53131,'Hello World!'];

(..Int() myTuple, String myString) = (13135,53131,'Hello World!');

class MyClass
{
    Int myInt = 13135;
    Int mySecondInt = 53131;
    String myString = 'Hello World!';
}

{..myRest, String myString} = MyClass();


//title
Default type

//text
The default type can be used to apply a predefined type to unpacking elements that do not have a type defined.
The defualt type is defined before the unpacking brackets

//code
Int[myInt, mySecondInt, String myString] = [13135,53131,'Hello World!'];

Int(myInt, mySecondInt, String myString) = (13135,53131,'Hello World!');

class MyClass
{
    Int myInt = 13135;
    Int mySecondInt = 53131;
    String myString = 'Hello World!';
}

Int{myInt, mySecondInt, String myString} = MyClass();

//title
Skipping values

//text
Skipping values can be used to skip un wanted values.
To skip a value just keep an unpacking element empty or define the type you want to skip.
Values can only be skiped in ordered collections or key value pairs.

//code
[Int, , String myString] = [13135, 53131, 'Hello World!'];

(Int, , String myString) = (13135, 53131, 'Hello World!');

:String myString =  13135:'Hello World!';
Int:String myString =  13135:'Hello World!';

//text
The item repeater can be used to skip multiple values.
Only orderd collection unpacking can make use of the item repeater.

//code
[2.., String myString] = [13135, 53131, 'Hello World!'];

(2.., String myString) = (13135, 53131, 'Hello World!');

//title
Defined key

//text
When the key is defined in the unpacking scope the variable will only be unpacked when the key matches.

//code
Int:String myKeyValuePair = 13135:'Hello World!';
53131:String? myString = myKeyValuePair;
// myString becomes: null
13135:String? myString = myKeyValuePair;
// myString becomes: 'Hello World!'

//title
Default values

//text
Defualt values can be used to indicate that a certain element does not have to be populated with a value.

//code
[Int? myInt, String myString, Bool myBoolean = false] = [];

(Int? myInt, String myString, Bool myBoolean = false) = ();

{Int? myInt, String myString, Bool myBoolean = false} = {};

Int? myInt:String myString = :;

class MyClass
{
    Int? myInt;
    Bool? myBoolean;
    String? myString;
}

{Int? myInt, String myString, Bool myBoolean = false} = MyClass();

//title
Stacking

//text
The unpacking scopes can be stacked any level of depth.

[Int myInt,({Bool myBoolean, :Double myDouble}, String myString)] = [13135,({true, :53131.0},'Hello World!')];

//title
Functions binding

//text
Collection unpacking scopes can binded to any function.

//code
Void myMethod(Int myInt, String myString){
    // Your method code.
}

Void Func(Int, String) myFunction = myMethod;

myMethod(13135, 'Hello World!');

//code
Void myMethod[Int myInt, String myString]{
    // Your method code.
}

Void Func[Int, String] myFunction = myMethod;

myMethod[13135, 'Hello World!'];

//code
Void myMethod{Int myInt, String myString}{
    // Your method code.
}

Void Func{myInt Int, myString String} myFunction = myMethod;

myMethod{myInt = 13135, myString = 'Hello World!'};

//title
Asynchronous

//chapter
Asynchronous functions (async)

//text
The __async__ keyword can be used to make asynchronous functions.
These are methods with a promise as return value.
When the promise is resolved, it is returned and the attached code is run.
Note that the error object is always a enum.

//code
async String myMethod(){
	return "Hello World!";
}
myMethod()
.then( function(myReturnValue){ print(myReturnValue); } )
.catch( function(myError){ print("Error: " + myError.message); } );

//chapter
Promise (promise)

//text
The __promise__ keyword can be used in any function to create a promise.

//code
String myMethod(){
	return promise.resolve("Hello World!");
}

//chapter
Await (await)

//text
The __await__ keyword can be used to pause code when resolving a promise before continuing other code.
The __await__ keyword can only be used in a asynchronous function.

//code
async String myMethod(){
	return "Hello World!";
}
String myString = await myMethod().catch( function(myError){ print("Error: " + myError.message); } );

abstract class MyClass{
    Int myInt = 13135;

    String toString(){
        return '13135';
    }
}

//chapter
Null and Void

//text
Void is a primitive type that can only store the value void.

//code
Void myVoid = void;

//text
Null is a primitive type that can only store the value null.

//code
Null myNull = null;

//title
Relation between Null and Void

//text
The values __null__ and __void__ will be exacly the same, but you can still check if they are different by checking their type.
This adds the ease use so you do not have to worry about if the value is __null__ or __void__, they act mostly the same.

//code
Bool myBoolean = void == null;
// myBoolean becomes: true

myBoolean = null == Void;
// myBoolean becomes: false;
myBoolean = void == Void;
// myBoolean becomes: true;

//text
Because __void__ will be equal to __null__ the null operators will also work on void values.

//code
Int | Void myInt = void;
myInt ??= 13135;
// mySecondInt becomes: 13135

Int[] | Void myArray = void;
myArray?.add(13135); 

Int? myInt = myArray?[0];

//title
Automatic void

//text
Void mostly represents that a value is missing or unasigned.
In the following places empty or missing values be converted to __void__.

//subtitle
Uninitialized variables

//text
Any uninitialized variable will by default get the value __void__ assigned.
When the variable is nullable or can contain __void__ the variable can be accessed without initialization.

//code
Int | Void myInt;
// Same as: 
Int | Void myInt = void;

//subtitle
Ternary operator

//text
The last two operhands of the ternary operator will default to return __void__ when one operhand is missing.

//code
Int? myInt = myBoolean ? : 13135;
// Same as: 
Int? myInt = myBoolean ? void : 13135;

//subtitle
return, yield, break return statements

//text
Any return, yield or break return statement without specifing a value will use the __void__ value by default.

//code
return;
yield;
break return; 
// Same as:
return void; 
yield void;
break return void;

//subtitle
Missing return statements

//text
When an (async)method or control expression does not end a branch with a __return__ statement, it will return __void__ by default.
When a for or while expression that must return a single value not does end a branch with a __break return__ statement, it will break return __void__ by default. 
Note that iterator or stream methods, or control expressions will not return or yield any value by default.

//code
// Method
Void myMethod(){}
// Same as:
Void myMethod(){ return void; }

// Control expression
Int? myInt = if(myBoolean){ } else 13135;
// Same as:
Int? myInt = if(myBoolean){ return void; } else 13135;

Int? myInt = if(myBoolean) 13135;
// Same as: 
Int? myInt = if(myBoolean) 13135 else void;

// Loop
Int? myInt = for(Int i in 0..10){};
// Same as:
Int? myInt = for(Int i in 0..10){ break return void; };

//title
Implicit casting

//text
The value __void__ can be implicitly casted to __null__ when the expected type cannot contain __void__.
If the expected type can contain __void__, the value __void__ will be stored instead of casting it to __null__. 

//code
String? myString = void;
// myString becomes: null

Void myMethod(){}
Int? myInt = myMethod();
// myInt becomes: null

Bool? | Void myBoolean = void;
// myBoolean becomes: void

//text
When __void__ is added to a collection literal and the collection can not contain void the void value will be ignored.
This functinallity only occurs if the part of the collection can a variable amount of values.
Note that when the collection can contain __void__, __void__ will be stored instead of ignored.
This also implies that the value __void__ cannot be implicitly casted to __null__ in any collection.

//code
Int[] myArray = [13135, void, 53131];
// myArray becomes: [13135, 53131]

Int[] myArray = [13135, if(myBoolean) 53131];
// myArray becomes: [13135, 53131] if myBoolean is true else: [13135]

(Int | Void)[] myArray = [13135, if(myBoolean) 53131];
// myArray becomes: [13135, 53131] if myBoolean is true else: [13135, void]

//text
When a collection object is used and a default value is defined the __void__ value will be replaced by the default value.
Note that even if the variable can contain void the defualt value will be assigned.

//code
[Int myInt = 13135, String myString] myArray = [void, 'Hello World!'];
// myArray becomes: [13135, 'Hello World!']

[Int myInt = 13135, String myString] myArray = [if(myBoolean) 53131, 'Hello World!'];
// myArray becomes: [53131, 'Hello World!'] if myBoolean is true else: [13135, 'Hello World!']

[Int | Void myInt = 13135] myArray = [void];
// myArray becomes: [13135]

//title
Operators

//Text
When the value __void__ is used in any binary operation it will be ignored.
If one of the operhands is __void__ the other operhand will be returned.
If both operators are __void__ the value __void__ will be returned. 

//code
Int myInt = 13135 + void;
// myInt becomes: 13135

myInt = 53131 + (void * void);
// myInt becomes: 53131


//SOME BASIC CLASS LITERAL EXPIRIMENTATION TO REMEMBER

//text
The definition and unpacking of class literals (public by default).
Class literals can only contain method and variable members.
Methods will be able to acces the members directly using the name or using the this keyword.

//code
// Definition
{String myString, Int myInt, Bool myBoolean} myClassLiteral = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

// Unpacking (Types van be inferred)
{String myString, myInt, Bool myBoolean} = myClassLiteral;

//text
Default value if unasinged or void is assigned

// Defintion
{String myString = 'Hello World!', Int myInt = 13135, Bool myBoolean} myClassLiteral = {myInt = void, myBoolean = false};
// myClassLiteral becomes: {myString = 'Hello World!',  Int myInt = 13135, myBoolean = false}

// Unpacking
{String myString = 'Hello World!', Int myInt = 13135, Bool myBoolean} = {myInt = void, myBoolean = false};

//Default value (If unasigned)
{String myString, Int myInt = 13135} = {myString = 'Hello World!'};

//Nullable or void types have optional assigment
{String? myString, Int | void myInt = 13135} = {};

// The defaut and null behaviour will work on the definition as wel

//To class
class MyClass
{
    String myString;
    Int myInt;
}
MyClass myClass = {myString = 'Hello World!', myInt = 13135};

//Unpacking (Values are accesable in the current scope)
{String myString, Int myInt, Bool myBoolean} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Inferd types
{myString, myInt, myBoolean} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Rename/define types and modifiers
{myString = myAlias, myInt = Long mySecondAlias, const myBoolean} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Rest (Contains all the known non specified unpacking memers)
{myString, ..myRest} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Rest without alias (injects the members in the current scope)
{..} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Hidden members counts as specified member (Injects all but myString)
{.., myString=} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Nested unpacking (Rest can also be nested)
//The rest operator will be the type of the current unpacking scope
{myString = [myChar, mySecondChar], ..{myBoolean}} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Classes can also be unpacked just like class literals
class MyClass
{
    String myString = 'Hello World!';
    Int myInt = 13135;
}
{myString = [myChar, mySecondChar], myInt} = MyClass();

//Global Define types and modifiers (Appies to all one level deep unpacking memers witout when they are not defined)
const {myString, myInt, myBoolean} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};

//Override one
init {myString, myInt, const myBoolean} = {myString = 'Hello World!', myInt = 13135, myBoolean = true};   

//One is still mutable using clever rest syntax trick
const {myString, myInt, ..{myBoolean}} =  {myString = 'Hello World!', myInt = 13135, myBoolean = true};       

//Ref keyword could be usefull to keep an active reference to the internal member
myLiteral = {x = 1, y = 5}
ref {x, y} = myLiteral;
//This will change the inner members from myLiteral
x = 7
y = 0;
// myLiteral becomes: {x = 7, y = 0}
// Could be very usefull for imports aswel

Sometimes you want to have nested unpacking and at the same time unpack the object itself as a whole.
The member can be unpacked twice or more if it has either a different alias or nested unpacking.
In short just i different way of unpacking that specific member.

// Definition
class myClassLiteral = {myArray = [1, 3 ,5], myInt = 13135, myBoolean = false};
// Unpacking

{
    myArray = [myMember, mySecondMember],
    myArray,

    myInt,
    myInt = myAlias,
    myInt = mySecondAlias,
} = myArray;


// Maybe types will be displayed in angle brackets with commas separated
<String> same String
<String, Int> same String | Int

Int myInt = myString<Int>;
//Can result in runtime exception

Int myInt = try myString<Int> catch 13135;
//When resulting in runtime error the catch value will be returned