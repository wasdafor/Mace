/*
The MACE syntax file
====================

This file will explain all syntax used in v1.0

Spaces, tabs and curly brackets are consistent throughout the file.
After namespaces, classes and switches comes an enter followed by curly brackets.
After all other code scopes come curly brackets without an enter.

First we will define the syntax that makes it possible to convert this file easily to an HTML page.
No tags are used inside other tags.

The shortcodes are:

//chapter
Your chapter here


//title
Your title here


//subtitle
Your subtitle here


//text
Your text here


//code
Your code here


//comment
Your comment here (this text should not be compiled to html)

//tablehead
Your table titles here

//table
Your table elements here seperate collums by a comma

__Your label here__

*/

//start

//chapter
Namespaces

//title
Creating Namespaces (namespace)

//text
The __namespace__ keyword is used to create a __namespace__.
To create a __namespace__ write the __namespace__ keyword, followed by the name of the __namespace__ ending with __{}__.
When defining multiple namespaces with the same name, the members of these namespaces will be merged.
Use access modifiers to define where the members of the namespace can be used.

//table head
Access modifier`    Can be access where?

//table
__public__`         Inside any namepace.
__private__`        Inside the namespace itself.
__protected__`      Inside namespaces with the same name.

By default the members of a namespace will be private.

The following members can be defined in a __namespace__:

//table
class
extension class
enum
interface
functions
variables

//code
namespace MyNamespace
{
    // Your namespace members.
}

//text
Namespace with members

//code
namespace MyNamespace
{
    int myInt = 0;

    void myMethod(){
        // Your method code.
    }

    class MyClass
    {
        // Your fields and methods.
    }
}

//title
Using Namespaces (using)

//text
The __using__ keyword is used to use the members of a namespace. 
To use a namespace write __using__ followed by the path to the location of the namespace.

//code
using ./MyNamespace;
// Print public or protected member from MyNamespace.
print(myMember);

//subtitle
Using members (from)

//text
The __,__ can be used to use specific members of a namespace.
To use specific members add your members separated by commas followed by __from__, ending with the path to your namespace.
To access a member of a namespace, use the name of the member you want to use.

//code
using myFirstMember, mySecondMember from ./MyNamespace;
// Print public or protected members from MyNamespace.
print(myFirstMember);
print(mySecondMember);

//subtitle
Namespace name (as)

//text
The __as__ keyword can be used to add a name to a namespace. 
To add a name to your namespace write __as__ after your namespace path followed by a given namespace name.
To access a member of a namespace with a name, write the given name followed by a member.

//code
using ./MyNamespace as MyNamedNamespace;
// Print public or protected member from MyNamespace named MyNamedNamespace.
print(MyNamedNamespace.myFirstMember);

using myFirstMember, mySecondMember from ./MySecondNamespace as MySecondNamedNamespace;
// Print public or protected member from MyNamespace named MySecondNamedNamespace.
print(MySecondNamedNamespace.mySecondMember);

//subtitle
Rename members (as)

//text
The __as__ keyword can be used to rename namespace members. 
To rename namespace members, write __as__ after the member followed with a new name;
To access a renamed member, use the new name of the member.

//code
using myFirstMember as myFirstRenamedMember, mySecondMember as mySecondRenamedMember from ./MyNamespace;
// Print renamed public or protected members from MyNamespace 
print(myFirstRenamedMember);
print(mySecondRenamedMember);

using myFirstMember as myFirstRenamedMember from ./MySecondNamespace as MySecondNamedNamespace;
// Print renamed public or protected members from MySecondNamespace named MySecondNamedNamespace.
print(MySecondNamedNamespace.myFirstRenamedMember);

//title
Using system namepaces (system)

//text
The __system__ keyword is used to use any namespace from the Mace system namespaces.
To use the system namepaces, write __system__ before your __using__ statement. 
This wil start your namespace path in the system directory. This means that adding the __./__ prefix in your namespace path is not required.

//code
system using Networking/RequestManager;
// Print return value from the getURL method from RequestManager.
print(getURL("https://google.com"));

//chapter
Classes

//text
The __class__ keyword is used to create a class.
To create a class write __class__ followed by the name of the class and ending with __{}__.
Classes can contain any variable, function, getter or setter, these are called class members.
Classes can only be declared in a namepace and will be private by default.

Use access modifiers to define where the members of a class can be used.

//tablehead
Access modifier`    Can be used where?

//table
__public__`         Outside of the class.
__private__`        Inside the class itself.
__protected__`      Inside the class itself or derived classes.

//code
namespace MyNamespace
{
    class MyClass
    {
       // Your class members.
    }

    class MySecondClass
    {
        int myInt = 0;

        void myMethod(){
            // Your method code.
        }
    }
}

//text
To create an instance of a class use the class name followed by __()__.

//code
// Your constructors used.
MyClass myClass = MyClass();
MySecondClass mySecondClass = MySecondClass();

//title
Inheritance (extend)

//text
The __extend__ keyword is used to inherit a class from another class.
To inherit a class from another class write __extend__ after the name of the child class followed by the name of the class you want to inherit from.
When a class inherits from another class you can access the public or protected members of the parent class.

//code
class MyClass
{
    public int myInt = 0;

    public void myMethod(int value){
        // Your method code.
    }
}

class MySecondClass extend MyClass
{
    MySecondClass(){
        myMethod(myInt);
        // Your constructor code.
    }
}

//title
Abstraction (abstract)

//text
The __abstract__ keyword is used to create abstract classes or class members.
To create an abstract class or member write __abstract__ before your class or class member.
When a class or class member is abstract it means that it cannot be used on its own.

//subtitle
Classes

//text 
When a class is abstract the class can only be inherited by another class.
Abstract classes can not be instanciated.

//code
abstract class MyClass
{
    public int myInt = 0;

    public void myMethod(int value){
        // Your method code.
    }
}

class MySecondClass extend MyClass
{
    MySecondClass(){
        myMethod(myInt);
        // Your constructor code.
    }
}

//subtitle
Class members

//text
Only abstract classes and interfaces can contain abstract members. 
When a member is abstract this means that they need to be implemented in the child class.
To implement an abstract member write __override__ before the member.

It is important that the field you want to implement has the same access modifier, type and identifier as the one you want to override.
Abstract fields may have a default value.
When the child class defines the field it overrides the default value, if the child class only declares the field the default value of the parent class will be used.

The same applies for methods, the implemented method needs to have the same access modifier, return type, identifier and parameters as the method you want to override.
Abstract methodsmay have a body.
When the child class defines the method it overrides the method body, if the child class only declares the method, the code of the parent class is used.
Note that initialisation of a method must happen, in the parent or child class, or in both.

//code
abstract class MyClass
{
    public abstract int myInt = 0;

    abstract string myString = 'Value';

    protected abstract double myDouble;

    public abstract void myMethod(int value){
        print(value);
        // Your abstract method code.
    }

    abstract void mySecondMethod(string value){
        print(value);
        // Your abstract method code.
    }

    protected abstract void myThirdMethod(double value);
}

class MySecondClass extend MyClass
{
    public override int myInt;

    override string myString = 'Overwritten value';

    protected override double myDouble = 3.3;
    
    public override void myMethod(int value);
    
    override void mySecondMethod(string value){
        print(value + "Overwritten");
        // Your overwritten method code.
    }

    protected override void myThirdMethod(double value){
        print(value);
        // Your overwritten method code.
    }
}

//title
Sealing (sealed)

//text
The __sealed__ keyword is used to create a sealed class.
To create a sealed class write __sealed__ before your class.
When a class is __sealed__, the class cannot be inherited/be a super class.
A sealed class cannot contain abstract members.

//code
sealed class MyClass
{
    int myInt;

    void myMethod(int value){
        // Your method code.
    }
}

//title
Static (static)

//text
The __static__ keyword is used to create static classes or class members.
To create a static class write __static__ before your class.
static classes can only contain static members.
When a class is __static__, the class cannot inherited/be super class or instanciated.

//code
static class MyClass
{
    static int myInt;

    static void myMethod(int value){
        // Your method code.
    }
}

//title
Super class (super) and This class (this)

//text
When using the same class member identifier in the child class as in the parent class, the child class will override the parent identifier.
Use the __this__ keyword to access the memebers of class itself and inherited classes.
Use the __super__ keyword to only access the members of the inherited classes.

//code
class MyClass
{
    public int myInt = 0;

    public void myMethod(int value){
        // Your method code.
    }
}

class MySecondClass extend MyClass
{
    MySecondClass(){
        myMethod();
        super.myMethod(myInt);
        this.myMethod(myInt);
        // Your constructor code.
    }

    public void myMethod(int value){
        // Your method code.
    }
}

//title
Class extension (extend)

//text
The __extend__ keyword can be used to add members to an already defined class.
To create a class extension write __extend__ followed by a class name and ending with __{}__.
extension classes work almost the same as a normal classes and can only be defined inside a namespace.
The constructor and the destructor of the original class can not be overwritten/redefined/overloaded.
Multiple extensions can be created for the same class.
Optional use the __this__ keyword to access public members from the original class or from extensions.

//code
extend string
{
    public char[] myString = "";
    public set<string> toSet(){
        // Code that converts a string to a set.
    }
}

string myString = 'Hello World!';
print(myString.toSet());

//text
The extended members can also be used in inheritance.

//code
class MyClass
{
    public int myInt = 0;
    // Your class members
}

extend MyClass
{
    public void printMyInt(){
        print(this.myInt);
        // Your method code.
    }
}

class MySecondClass extend MyClass
{
    MySecondClass(){
        printMyInt();
        // Your constructor code.
    }
    // Your class members
}

MySecondClass mySecondClass = MySecondClass();
mySecondClass.printMyInt();

//title
Constructor

//text
Constructors can be used to run a method when an instance of a class is created.
To create a constructor write the class name followed by __()__ ending with __{}__.
To create a named constructor write __.__ followed by the name of the constructor after the class name of a normal constructor.

//code
class MyClass
{
    MyClass(){
        // Your constructor code.
    }

    MyClass.MyNamedConstructor(){
        // Your named constructor code.
    }
}

// Your constructor used.
MyClass myClass = MyClass();
// Your named constructor used.
myClass = MyClass.MyNamedConstructor();

//text
Linked constructors can be used to call other constructors via a constructor.
To call a linked constructor write __:__ followed by __this__ and ending with __()__ after the parameter body of any constructor.
To call a named linked constructor write __.__ followed by the name of the constructor after the __this__ keyword of a normal linked constructor.

//code
class MyClass
{
    MyClass() : this.MySecondNamedConstructor(){
        // Your constructor code.
    }

    MyClass.MyNamedConstructor() : this(){
        // Your named constructor code.
    }

    MyClass.MySecondNamedConstructor(){
        // Your second named constructor code.
    }
}

//title
Destructor (~)

//text
The destructor can be used to run a method when an instance of a object is deleted.
Adding a destructor to a class is not required.
No parameters can be added to the destructor parameter body.

//code
class MyClass
{
    ~MyClass{
         // Your destructor code.
    }
}

//title
Methods

//text
To create a constant or read only variable in your class, but you want to initialize it in the constructor, use the keyword __initialize__.
The variable can also be initialized via short assignment.
The variable can only be overwritten in the constructor scope. 

//code
class MyClass
{
    initialize const int myInt;
    initialize readonly string myString = "Hello World!";

    MyClass(this.myInt, myString){
        this.myString = myString;
        // Your constructor code.
    }
}

//subtitle
Getters (get) and Setters (set)

//text
Getters and setters are methods that will be run when the specific field is accessed.
To create a setter or getter write the following structure; __get__ or __set__, the name of any field, __()__ and __{}__.
Access modifiers can be added to the getter and setter. These access modifiers override the default getter and setter of the field.
Getters and setters can only be defined if their field is declared in the same class or extension class.
When defining the getter a value with the same type as the field must be returned.
When defining the setter one parameter of any type is required.
Note that in the example the integer was initialially private, but has become public because of the getter and setter.

//code
class MyClass
{
    private int myInt;

    MyClass(this.myInt){
        // Your constructor code.
    }

    public get myInt{
        // Your getter code.
        return myInt + 1;
    }

    public set myInt(int myInt){
        this.myInt = myInt - 1;
        // Your setter code.
    }
}

//text
If only the access modifiers of a field needs to be changed the shorthand can be used.
To write the access modifier shorthand hand write any access modifier followed by get or set.
You are not required to use both the getter and setter on the same field. If one is omitted it becomes private.

//code
class MyClass
{
    private set public get bool? myBoolean;
}

//text
The __only__ keyword can be used to create read only or write only fields.
When using the only keyword the getter or setter can only be used by itself.

//code
class MyClass
{
    public get only string? myString;
            
    public set only bool? myBoolean;
}

//text
The getter and setter can also be used to access the class with __[]__.
To create such a getter or setter write the following structure; __get__ or __set_, __this__, __[]__ and __{}__.
The getter can only have one parameter while the setter can have two.

//code
class MyMap<T,S>
{
    get this[T index]{
        return '';
        // Return a value depending on the index given.
    }

    set this[T index, S value]{
        // Save a value depending on the given index and value.
    }
}

MyMap<string,int> myMap = MyMap<string,int>();

myMap['value'] = 4;
// Setting a value via an index

print(myMap['value']);
// Getting a value via an index

//chapter
Interfaces (interface)

//text
The __interface__ keyword is used to create an interface.
To create an interface write __interface__ followed by the name of the interface and ending with __{}__.
Interfaces can be compared to abstract classes with only abstract members.
The members of an interface are abstract by default so the abstract keyword can omitted. 
Interfaces can contain declared fields and body less methods.
interfaces can ony be declared inside of a namespace.

//code
interface MyInterface
{
    int myInt;

    void myMethod();
}

//title
implementation (implement)

//text
The __implement__ keyword is used to implement the members of an interface inside of a child class.
To implement the members of an interface write implement after the name of the child class followed by the name of the interface.
When inplementing an interface all the members of the interface must be overwritten inside of the child class.

//code
interface MyInterface
{
    int myInt;

    void myMethod();
}

class MyClass implement MyInterface
{
    override int myInt = 0;

    override void myMethod(){
        // Your implemented method code.
    }
}

//title
Inheritance (extend)

//text
The __extend__ keyword can be used to inherit interface members from other interfaces.
To inherit members from other interfaces write __extend__ after the child interface followed by comma separated interface names.
Note no members can have the same name.

//code
interface MyInterface
{
    int myInt;
}

interface MySecondInterface
{
    void myMethod();
}

interface myThirdInterface extend MyInterface, MySecondInterface
{
    // The members of MyInterface and MySecondInterface are inherited in this interface.
    string myString;
}

//chapeter
Enumerations (enum)

//text
The __enum__ keyword is used to create an __enum__.
To create an __enum__ write __enum__ followed by the name of the enum ending with __{}__.
enums can be compared with a static classes that only contain constant fields.
The fields inside of an enum are comma separated.
Note that no keywords can be added to the fields inside an enum.
Enums can only be defined inside of a namepace.

//code
enum MyEnum
{
    FirstEnumField,
    SecondEnumField,
    ThirdEnumField
}

//text
To access an enum write the enum name followed by the field name.

//code
MyEnum myEnum = MyEnum.FirstEnumField;

if(myEnum == MyEnum.SecondEnumField){
    // You code
}

//title
Inheritance (extend)

//text
The __extend__ keyword can be used to inherit enum fields from other enums.
To inherit fields from other enums write __extend__ after the child enum followed by comma separated enum names.
Note that the enum type must be the same type as the child enum and no fields can have the same name.

//code
enum MyEnum
{
    FirstEnumField,
}

enum MySecondEnum
{
    SecondEnumField,
}

enum MyThirdEnum extend MyEnum, SecondEnumField
{
    // The fields of MyEnum and MySecondEnum are inherited in this enum.
    ThirdEnumField
}

//chapter
Methods

//title
Data types

//text
To store a method in a variable use the method data type.

//code
class GoogleMaps
{
    void func(GoogleMapsController googleMapsController) onInit;

    public GoogleMaps(this.onInit){
        System.sleep(5);
        onInit(GoogleMapsController());
    }
}

class GoogleMapsController
{
    void goToXY(){

    }
}

GoogleMaps googleMaps = GoogleMaps((GoogleMapsController googleMapsController){
    googleMapsController.goToXY();
});

//title
Lambda funtions

//text
There are multiple ways to define a method.

//code
int addTwoNumbers0(int a, int b){
    return a + b;
}
int addTwoNumbers1(int a, int b) => a + b;
int func(int a, int b) addTwoNumbers2 = (int a, int b) {return a + b};
int func(int a, int b) addTwoNumbers3 = (int a, int b) => a + b;

//chapter
Primitive variables

//text
Mace has the following primitive data types.
To declare a variable write a variable type followed by a unique identifier;
To define a declared variable write a __=__ followed by a value of the type of the variable after the variable name.

//tablehead
Primitive`  Meaning

//table
string`     Stores any array of characters.
char`       Stores any singular character.
short`      Stores any whole number between -32,768 and 32,767    
int`        Stores any whole number between -2,147,483,648 and 2,147,483,647.
long`       Stores any whole number between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807.
float`      Stores any floating point number, between           
double`     Stores any floating point number, between -1.7*10^308 and 1.7*10^308.
bool`       Stores true or false.
percent`    Stores a fraction.

//title
Strings (string)

//text
A string is an object that stores an array of characters.
You can define a string by using __''__ or __""__.

//code
string myString = "Hello World!";
myString = 'Hello World!';

//subtitle
Concatenation

//text
To concatenate two strings use the plus operator.
You can concatenate literal strings and string variables.

//code
string myString = 'Hello ' + "World!";
// myString becomes: 'Hello World!'
string myDoubleString = myString + myString;
// myDoubleString becomes: 'Hello World!Hello World!'

//subtitle
Escape characters (\)

//text
Use escape characters to use characters that would normaly have a different meaning or to give a character a different meaning.
To use escape character use __\__.
Escape characters can be used in a string or char.

//tablehead
Escape chapter` Meaning

//table
\n`             New line
\b`             Backspace
\t`             Tab
\$`             A literal __$__
\\`             A literal __\__
\'`             A literal __'__
\"`             A literal __"__

//code
string myNewLine = 'This is on line one,\nAnd this on line two';
/*
// When printed:
'This is on line one,
And this on line two'
*/      
string myBackspace = 'This removes the last character from this string\b';
// When printed: 'This removes the last character from this strin'
string myTab = 'This adds a tab\tin this string';
// When printed: 'This adds a tab   in this string'
string myDollarSign = 'This escapes the use of the \$ for using interpolation';
// myDollarSign becomes: 'This escapes the use of the $ for using interpolation'
string myBackslash = 'This escapes the use of the \\ for escaping characters';
// myBackslash becomes: 'This escapes the use of the \ for escaping characters'
string mySingleQuote = 'This escapes the use of the \' for creating a string or char';
// mySingleQuote becomes: 'This escapes the use of the ' for creating a string or char'
string myDoubleQuote = "this escapes the use of the \" for creating a string or char";
// myDoubleQuote becomes: 'this escapes the use of the " for creating a string or char'

//subtitle
Interpolation

//text
To use string interpolation use a __$__ or use __${}__.
When only using the __$__ you need to have a space between the variable and the next part of the string 

//code
string myName = 'Jack';

string myString = 'Hello $myName how are you doing?'
// myString becomes: 'Hello Jack how are you doing?'
myString = 'Hello ${myName + " how"} are you doing?'
// myString becomes: 'Hello Jack how are you doing?'

//subtitle
Indexing

//text
Read a character from a string by using __[]__.
Indexing starts at index 0.

//code
string myString = 'Hello World!';
char myChar = myString[6];
// myChar becomes: 'W'

//title
Characters (char)

//text
A __char__ is a primitive that stores just one character.
You can define a __char__ by using __''__ or __""__.

//code
char myChar = "H";
myChar = '!';

//subtitle
Concatenation

//text
If you want to concatenate two characters you need to store them in a __string__.

//code
string myTwoChars = 'H' + "!";
// myTwoChars becomes: 'H!'

//subtitle
Escape characters (\)

//text
To use escape characters in a string use __\__.
Escape characters can be used in a string or char.

//code
char mySingleQuoteChar = '\'';
// mySingleQuoteChar becomes: '''
char myDoubleQuoteChar = "\"";
// myDoubleQuoteChar becomes: '"'

//title
Integers (short), (int), (long)

//text
An __int__ is a primitive that can store any whole number between -2,147,483,648 and 2,147,483,647.

//code
int myInt = 13135;

//subtitle
Int with a different base

//text
When using a number from a different base use one of the following prefixes.

//tablehead
Prefix` Meaning`    Base

//table
0b`     Binary`     2
0o`     Octal`      8
0x`     Hexadecimal`16

//code
int myBinaryInt = 0b01010;
// myBinaryInt becomes: 20
int myOctalInt = 0o37461;
// myOctalInt becomes: 16177
int myHexadecimalInt = 0xD24AF;
// myHexadecimalInt becomes: 861359

//subtitle
Indexing

//text
To get a digit from an __int__, access the __int__ in the same way as how you would get a __char__ from a string.
Indexing starts at index 0.
// https://www.geeksforgeeks.org/find-first-last-digits-number/#:~:text=To%20find%20first%20digit%20of%20a%20number%20we%20divide%20the,left%20with%20the%20first%20digit.
// ^aproach 2

//code
int myInt = 13135;
int myIndexedInt = myInt[2];
// myInexedInt becomes: 1

//title
Doubles (double)

//text
A __double__ is a primitive that can store any floating point number, between -1.7*10^308 and 1.7*10^308 with a precision of 15 digits.
To define a __double__ use a dot where the decimal digits should be.
Note that a __double__ is not perfectly precise when used in calculations.

//code
double myDouble = 13135.13135;

//text
Literal int values and numbers from different bases are allowed to be assigned to a double.

//code
double myIntegerDouble = 13135;
// myIntegerDouble becomes: 13135.0
double myBinaryDouble = 0b01010;
// myBinaryDouble becomes: 20.0
double myOctalDouble = 0o37461;
// myOctalDouble becomes: 16177.0
double myHexadecimalDouble = 0xD24AF;
// myHexadecimalDouble becomes: 861359.0

//subtitle
Exponent of 10 (e)

//text
multiply a number to 10 to the power of any integer number by use the suffix __e__.
You can use a positive or negative integer exponent.

//code
double myDouble = 4.3e5;
// myDouble becomes: 430000.0
myDouble = 3.8e-2;
// myDouble becomes: 0.038

//title
Booleans (bool), (true), (false)

//text
A __bool__ is a primitive that can store either a zero or a one.
Because there are only two states, the 0 is also equal to __false__, and the 1 is equal to __true__;
All datatypes that are empty or null are false if casted to an boolean.
If they contain a value they are true.

//tablehead
Datatype`       Empty value

//table
int`            0
double`         0.0
string`         '' or ""
string[]`       []
Map<string,int>`{}
Set<string>`    Set.empty
List<string>`   []

//code
bool myBoolean = true;
myBoolean = (bool)0
// myBoolean becomes: false

myBoolean = (bool)13135
// myBoolean becomes: true

//chapter
Operators

//title
Arithmetic

//text
Arithmetic operators are mostly used so to apply mathematical equations to values.
Some of these operators can be used on strings, arrays, maps, sets and lists.

//tablehead
Operator`   Name`                       Example

//table
+`          Addition`                   myInt + 5
++`         Increment`                  ++myInt    
-`          Negation or Subtraction`    myInt - 5    
--`         Decrement`                  --myInt    
*`          Multiplication`             myInt * 5
/`          Division`                   myInt / 5
**`         Exponentiation`             myInt ** 5
!`          Factorization`              myInt!
%`          Modulation`                 myInt % 5          

//subtitle
Addition (+)

//text
The __+__ operator is used when any two numbers need to be added to each other.

//code
int myInt = 1 + 3;
// myInt becomes: 4

//text
The __+__ can also be used to concatenate strings, arrays, sets, maps or lists.
Concatenating strings, arrays, sets, maps or lists will add the values together and return a new string, array, sets, maps or lists.

//code
string myString = 'Hello ' + 'World!';
// myString becomes: 'Hello World!'
int[] myArray = [1,3] + [2,4];
// myArray becomes: [1,3,2,4]
Map<string,int> myMap = {'firstValue': 1} + {'secondValue': 2};
// myMap becomes: {'firstValue': 1, 'secondValue': 2}
Set<int> mySet = {1,4,2} + {2,3,8};
// mySet becomes: {1,4,2,3,8}
List<int> myList = [1,3] + [2,4];
// myList becomes: [1,3,2,4]

//subtitle
Increment (++)

//text
The __++__ operator is used to increment a number variable by 1 before using it;

//code
int myInt = 0;
myInt = ++myInt;
// myInt becomes: 1

//subtitle
Negation or Subtraction (-)

//text
The __-__ operator is used when a number needs to be negated or two numbers need to be subtracted from each other.

//code
int myInt = -1;
myInt = 4 - 3;
// myInt becomes: 1
myInt = 3 -4;
// myInt becomes: -1

//text
The __-__ operator can also be used to subtract strings, arrays, maps, sets or lists.
When subtracting a string from another string, the order of the characters is important.
Note here that only one substring that is equal to the right hand string will be removed.
When subtracting an array from another array, the order of the elements is important. The same applies for lists.
Note here that all the elements in the right hand array will be removed from the left hand array if they exist.
When subtracting a map from another map, the order of the elements is not important. The same applies for sets.
Searching and removing will start at the end.

//code
string myString = 'Hello World!' - ' World!';
// myString becomes: 'Hello'
int[] myArray = [1,2,4,3] - [2,4];
// myArray becomes: [1,3]
Map<string,int> myMap = {'firstValue': 1, 'secondValue': 2} - {'firstValue': 1};
// myMap becomes: {'secondValue': 2}
Set<int> mySet = {1,4,2} - {2,3,8};
// mySet becomes: {1,4}
List<int> myList = [1,2,4,3] - [2,4];
// myList becomes: [1,3]

//subtitle
Decrement (--)

//text
The __--__ operator is used to decrement a number variable by 1 before using it;

//code
int myInt = 0;
myInt = --myInt;
// myInt becomes: -1

//subtitle
Multiplication (*)

//text
The __*__ operator is used when any two numbers need to be multiplied.

//code
int myInt = 3 * 4;
//myInt becomes: 12

//text
The __*__ operator can also be used to multiply strings, sets or arrays.
Multiplying a string, set or array will repeat the values inside and return a new string, set or array.
Note you must use an integer value when multiplying with a number.
When multiplying an array or a set with another array or set, the result will be a cartesian product.

//code
string myString = 'Hello World!' * 2;
// myString becomes: 'Hello World!Hello World!'
int[] myArray = [1,2,3,4] * 2;
// myArray becomes: [1,2,3,4,1,2,3,4]
List<int> myList = [1,2,3,4] * 2;
// myList becomes: [1,2,3,4,1,2,3,4]
Set<int[]> mySet = {1,2,3,4} * {5,6,7,8};
// mySet becomes: {[1,5],[1,6],[1,7],[1,8],[2,5],[2,6],[2,7],[2,8],[3,5],[3,6],[3,7],[3,8],[4,5],[4,6],[4,7],[4,8]}

//subtitle
Division (/)

//text
The __/__ operator is used when any two numbers need to be divided by each other.

//code
int myInt = 4 / 2;
// myInt becomes: 2

//text
The __/__ operator can also be used to divide strings, arrays or lists.
Dividing a string, array or list by a value will count the occurrences of the given value and returns an int.
Note that the order matters.

//code
int countString = 'Hello World!' / 'l';
// countString becomes: 3
int countArray = [1,2,3,4,2,3] / [2,3];
// countArray becomes: 2
countArray = [3,3,3] / [3,3];
// countArray becomes: 1
int countList = [1,2,3,4,2,3] / [2,3];
// countList becomes: 2

//subtitle
Exponentiation (**)

//text
The __**__ operator is used when a number needs to be exponented by an other number.

//code
int myInt = 3 ** 2;
// myInt becomes: 9

//subtitle
Factorization (!)

//text
The __!__ operator is used when the factorial needs te be found of a number.

//code
int myInt = 5!;
// myInt becomes: 120

//subtitle
Modulation (%)

//text
The __%__ operator is used when the remainder of a number needs te be found after subtraction by an other number just before it becomes negative.

//code
int myInt = 5 % 2;
// myInt becomes: 1

//text
The __%__ operator can also be used to modulate strings or arrays.
Modulating a string or array will remove all the occurrences of the value(s) of the right hand side from the left hand side and return a new string or array.
Note that the order matters.

//code
string myString = 'Hello World!' % 'l';
// myString becomes: 'Heo Word!'
int[] myArray = [1,2,3,4,2,3] % [2,3];
// myArray becomes: [1,4]
myArray = [3,3,3] & [3,3];
// myArray becomes: [3]
List<int> myList = [1,2,3,4,2,3] % [2,3];
// myList becomes: [1,4]

//title
Matrix arithmetic

//text
The following table shows all possible operations that can be applied on matrices or vertices.

//code
int[] a = [0,1,2];
int[] b = [3,4,5];
int[][] c = [[6,7,8]];
int[] myArray;
int myScalar = 9;
int myInt;

//tablehead
Operator`   Name`                           Example`                  Same as

//table
#+`         Matrix addition`                myArray = a #+ b;`                          myArray = [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
#-`         Matrix subtraction`             myArray = a #- b;`                          myArray = [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
#*`         Matrix scalar multiplication`   myArray = a #* myScalar;`                   myArray = [a[0]*myScalar, a[1]*myScalar, a[2]*myScalar];
#/`         Matrix scalar division`         myArray = a #/ myScalar;`                   myArray = [a[0]/myScalar, a[1]/myScalar, a[2]/myScalar];
#**`        Matrix dot product`             myArray = c #** a; or myArray = a #** b;`   myArray = [[c[0]*a[0], c[0]*a[1], c[0]*a[2]],[c[1]*a[0], c[1]*a[1], c[1]*a[2]],[c[2]*a[0], c[2]*a[1], c[2]*a[2]]]; or myArray = [a[0]*b[0]+a[1]*b[1]+a[2]*b[2]];
##`         Matrix cross product`           myArray = a ## b;`                          myArray = [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
#-`         Matrix negation`                myArray = #-a;`                             myArray = [a[0]*-1, a[1]*-1, a[2]*-1];
#^`         Matrix norm`                    myInt = #^a;`                               myInt = sqrt(a[0]**2 + a[1]**2 + a[2]**2);
#%`         Matrix unit`                    myArray = #%a;`                             myArray = a #/ #^a;

//subtitle
Matrix addition (#+)

//text
The __#+__ operator is used when two matrices need to be added to each other.
Every number on a position of the first matrix will be added to the number on the same position of the second matrix.
Note that the size of the two does not matter, but they do need to be the same, both must have the same amount of rows and the same amount of columns.

//code
myArray = a #+ b;
myArray = [0+3,1+4,2+5];
myArray = [3,5,7];

//subtitle
Matrix subtraction (#-)

//text
The __#-__ operator is used when one matrix needs to be subtracted from another.
Every number on a position of the first matrix will be added to the number on the same position of the second matrix.
Note that the size of the two does not matter, but they do need to be the same, both must have the same amount of rows and the same amount of columns.

//code
myArray = a #- b;
myArray = [0-3,1-4,2-5];
myArray = [-3,-3,-3];

//subtitle
Matrix scalar multiplication (#*)

//text
The __#*__ operator is used when a matrix needs to be multiplied with a scalar.
Every number on a position of the matrix will be multiplied with a number.
Note that the size of the matrix does not matter.

//code
myArray = a #* myScalar;
myArray = [0*6,1*6,2*9];
myArray = [0,9,18];

//subtitle
Matrix scalar division (#/)

//text
The __#/__ operator is used when a matrix needs to be divided by a scalar.
Every number on a position of the matrix will be divided with a number.
Note that the size of the matrix does not matter.

//code
myArray = a #/ myScalar;
myArray = [0/9,1/9,2/9];
myArray = [0,0,0];

//subtitle
Matrix dot product (#**)

//text
The __#**__ operator is used when two matrices need to be multiplied with each other.
The resulting matrix will have the number of rows of the first matrix and the number of columns of the second matrix.
Every position of the resulting matrix will be the sum of 
each element of the corresponding row in the first matrix multiplied with each element of the corresponding column in the second matrix.
Note that the size of the two does not matter, but the number of columns of the first matrix need to be the same as the number of rows in the second matrix.

//code
myArray = c #** a;
myArray = [[6*0, 6*1, 6*2],[7*0, 7*1, 7*2],[8*0, 8*1, 8*2]];
myArray = [[0, 6, 12],[0, 7, 14],[0, 8, 16]];

//subtitle
Matrix cross product (##)

//text
The __##__ operator is used when the cross product of two matrices needs to be found.
Note that this operator can only be used on two matrices that both have 3 rows and 1 column.

//code
myArray = a ## b;
myArray = [1*5-2*4, 2*3-0*5, 0*4-1*3];
myArray = [5-8, 6-0, 0-3];
myArray = [-3, 6, -3];

//subtitle
Matrix negation (#-)

//text
The __#-__ operator is also used when the negated matrix needs to be found.
Every number in the matrix will be multiplied with -1.

//code
myArray = #-a;
myArray = [0*-1, 1*-1, 2*-1];
myArray = [0, -1, -2];

//subtitle
Matrix norm (#^)

//text
The __#^__ operator is used when the length of a matrix needs to be found.
The resulting number will be the square root of the sum of every number in the column squared.
Note that this operator can only be used on a matrix that has only 1 column.

//code
myInt = #^a;
myInt = sqrt(0**2 + 1**2 + 2**2);
myInt = sqrt(0 + 1 + 4);
myInt = sqrt(5);
myInt = 2;

//subtitle
Matrix unit (#%)

//text
The __#^__ operator is used when the matrix with the same direction but with a length of 1 needs to be found.
The resulting matrix will be the same matrix but every number will be divided by the length of the original matrix.
Note that this operator can only be used on a matrix that has only 1 column.

//code
myArray = #%a;
myArray = a #/ #^a;
myArray = [0/sqrt(0**2 + 1**2 + 2**2),1/sqrt(0**2 + 1**2 + 2**2),2/sqrt(0**2 + 1**2 + 2**2)];
myArray = [0/sqrt(5), 1/sqrt(5), 2/sqrt(5)];
myArray = [0,0,0];

//title
Bitwise depended

//text
Depended bitwise operators can be used to manipulate two bit sequences in relation to each other.
The result will be a combination of the two via specific rules.

//tablehead
Operator`   Name

//table
&`          Bitwise AND
|`	        Bitwise OR
^`	        Bitwise XOR

//subtitle
Bitwise AND (&)

//text
The __&__ operator is used to check if both bits are one. 
If both bits are one, a one will be returned in the new bit sequence.
If one or both bits are zero, a zero will be returned in the new bit sequence.

//code
int myInt = 0b00000000000000000000000000001100 & 0b00000000000000000000000000001010;
// myInt becomes: 0b00000000000000000000000000001000 which is 8

myInt = 12 & 10;
// myInt becomes: 8

//text
The __&__ operator can also be used to get the intersect of two strings, arrays, lists, sets or types.
Note that the order does not matter.

//code
string myString = '1235' & '245';
// myString becomes: '25'

int[] myArray = [1,2,3,5] & [2,4,5];
// myArray becomes: [2,5]

List<int> myList = [1,2,3,5] & [2,4,5];
// myList becomes: [2,5]
 
Set<int> mySet = {1,2,3,5} & {2,4,5};
// mySet becomes: {2,5}

type MyType =  (string | double) & (int | double)
// MyType becomes: double

//subtitle
Bitwise OR (|)

//text
The __|__ operator is used to check if one or both bits are one. 
If one or both bits are one, a one will be returned in the new bit sequence.
If both bits are zero, a zero will be returned in the new bit sequence.

//code
int myInt = 0b00000000000000000000000000001100 | 0b00000000000000000000000000001010;
// myInt becomes: 0b00000000000000000000000000001110 which is 14

myInt = 12 | 10;
// myInt becomes: 14

//text
The __|__ operator can also be used to get the union of two strings, arrays, lists, sets or types.

//code
string myString = '1235' | '245';
// myString becomes: '12345'

int[] myArray = [1,2,3,5] | [2,4,5];
// myArray becomes: [1,2,3,4,5]

List<int> myList = [1,2,3,5] | [2,4,5];
// myList becomes: [1,2,3,4,5]
 
Set<int> mySet = {1,2,3,5} | {2,4,5};
// mySet becomes: {1,2,3,4,5}

type MyType = string | int;
// MyType becomes: string | int

//subtitle
Bitwise XOR (^)

//text
The __^__ operator is used to check if one of both bits is one. 
If one of both bits is one, a one will be returned in the new bit sequence.
If one or both bits are zero, a zero will be returned in the new bit sequence.

//code
int myInt = 0b00000000000000000000000000001100 ^ 0b00000000000000000000000000001010;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 ^ 10;
// myInt becomes: 6

//text
The __^__ operator can also be used to get the symmetric difference of two strings, arrays, lists, sets or types.

//code
string myString = '1235' ^ '245';
// myString becomes: '134'

int[] myArray = [1,2,3,5] ^ [2,4,5];
// myArray becomes: [1,3,4]

List<int> myList = [1,2,3,5] ^ [2,4,5];
// myList becomes: [1,3,4]
 
Set<int> mySet = {1,2,3,5} ^ {2,4,5};
// mySet becomes: {1,3,4}

type MyType = (string | double) ^ (int | double);
// MyType becomes: string | int


//title
Bitwise independed

//text
Independed bitwise operators can be used to manipulate a single bit sequence.

//tablehead
Operator`   Name

//table
~`	        Bitwise NOT
>>`	        Bitwise signed right shift
<<`	        Bitwise signed left shift
>>>`        Bitwise unsigned right shift
<<<`        Bitwise unsigned left shift
@>>>`       Bitwise unsigned right shift loop         
@<<<`       Bitwise unsigned left shift loop

//subtitle
Bitwise NOT (~)

//text
The __~__ operator is used to flip the bits of the operand. 

//code
int myInt = ~0b00000000000000000000000000001100;
// myInt becomes: 0b11111111111111111111111111110011 which is -13

myInt = ~12;
// myInt becomes: -13

//subtitle
Bitwise signed right shift (>>)

//text
The __>>__ operator is used to shift every bit in a bit sequence a given amount of places to the right.
The most right bits will be lost and the empty spaces after the MSB at the left are filled with zeros if the MSB is a zero and with ones of the MSB is a one.

//code
int myInt = 0b00000000000000000000000000001100 >> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 >> 2;
// myInt becomes: 3

myInt = 0b11111111111111111111111111110100 >> 1;
// myInt becomes: 0b11111111111111111111111111111010 which is -6

myInt = -12 >> 2;
// myInt becomes: -3

//subtitle
Bitwise signed left shift (<<)

//text
The __<<__ operator is used to shift every bit in a bit sequence a given amount of places to the left.
The most left bits after the MSB will be lost and the empty spaces at the right are filled with zeros.

//code
int myInt = 0b00000000000000000000000000001100 << 1;
// myInt becomes: 0b00000000000000000000000000011000 which is 24

myInt = 12 << 2;
// myInt becomes: 48

myInt = 0b11111111111111111111111111110100 << 1;
// myInt becomes: 0b11111111111111111111111111101000 which is -24

myInt = -12 << 2;
// myInt becomes: -48

//subtitle
Bitwise unsigned right shift (>>>)

//text
The __>>>__ operator is used to shift every bit in a bit sequence a given amount of places to the right.
The most right bits will be lost and the empty spaces at the left are filled with zeros.

//code
int myInt = 0b00000000000000000000000000001100 >>> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 >>> 2;
// myInt becomes: 3

myInt = 0b11111111111111111111111111110100 >>> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 2147483642

myInt = -12 >>> 2;
// myInt becomes: 1073741821

//text
The __>>>__ operator can also be used to remove characters from the end of strings or items from the end of arrays or lists.

//code
string myString = '12345' >>> 1;
// myString becomes: '1234'

int[] myArray = [1,2,3,4,5] >>> 1;
// myArray becomes: [1,2,3,4]

List<int> myList = [1,2,3,4,5] >>> 1;
// myList becomes: [1,2,3,4]

//subtitle
Bitwise unsigned left shift (<<<)

//text
The __<<<__ operator is used to shift every bit in a bit sequence a given amount of places to the left.
The most left bits will be lost and the empty spaces at the right are filled with zeros.

//code
int myInt = 0b00000000000000000000000000001100 <<< 1;
// myInt becomes: 0b00000000000000000000000000011000 which is 24

myInt = 12 <<< 2;
// myInt becomes: 28

myInt = 0b11111111111111111111111111110100 <<< 1;
// myInt becomes: 0b11111111111111111111111111101000 which is -24

myInt = -12 <<< 2;
// myInt becomes: -48

//text
The __<<<__ operator can also be used to remove characters from the start of strings or items from the start of arrays or lists.

//code
string myString = '12345' <<< 1;
// myString becomes: '2345'

int[] myArray = [1,2,3,4,5] <<< 1;
// myArray becomes: [2,3,4,5]

List<int> myList = [1,2,3,4,5] <<< 1;
// myList becomes: [2,3,4,5]

//subtitle
Bitwise unsigned right shift loop (@>>>)

//text
The __@>>>__ operator is used to loop every bit in a bit sequence a given amount of places to the right.
The most right bits will be moved to the left.
Note that the MSB will be moved.

//code
int myInt = 0b00000000000000000000000000001100 @>>> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 @>>> 2;
// myInt becomes: 3

myInt = 0b11111111111111111111111111110100 @>>> 1;
// myInt becomes: 0b1011111111111111111111111111010 which is 1610612730

myInt = -12 @>>> 2;
// myInt becomes: 1342177277

//text
The __@>>>__ operator can also be used to loop every character or item in a string, array or list a given amount of places to the right.
The most right items or characters will be moved to the left.

//code
string myString = '12345' @>>> 1;
// myString becomes: '51234'

int[] myArray = [1,2,3,4,5] @>>> 1;
// myArray becomes: [5,1,2,3,4]

List<int> myList = [1,2,3,4,5] @>>> 1;
// myList becomes: [5,1,2,3,4]

//subtitle
Bitwise unsigned left shift (@<<<)

//text
The __@<<<__ operator is used to loop every bit in a bit sequence a given amount of places to the left.
The most left bits will be moved to the right.

//code
int myInt = 0b00000000000000000000000000001100 @<<< 1;
// myInt becomes: 0b00000000000000000000000000011000 which is 24

myInt = 12 @<<< 2;
// myInt becomes: 48

myInt = 0b11111111111111111111111111110100 @<<< 1;
// myInt becomes: 0b11111111111111111111111111101001 which is -23

myInt = -12 @<<< 2;
// myInt becomes: -45

The __@<<<__ operator can also be used to loop every character or item in a string, array or list a given amount of places to the left.
The most left items or characters will be moved to the right.

//code
string myString = '12345' @<<< 1;
// myString becomes: '23451'

int[] myArray = [1,2,3,4,5] @<<< 1;
// myArray becomes: [2,3,4,5,1]

List<int> myList = [1,2,3,4,5] @<<< 1;
// myList becomes: [2,3,4,5,1]

//title
Null safety

//text
Null safety operators are used to manage null values in your program to avoid runtime errors.

//tablehead
Operator`   Name`                   Example

//table
?`          Nullability indicator`  int? myInt = null;
?`          Optional chaining`      myObject?.toString(); or myArray?[1]; or myMap?['key'];
??`         Null-coalescing`        myString ?? 'Default value';

//subtitle
Nullability indicator (?)

//text
The __?__ operator can be used to indicate that a type is nullable.
To indicate that a type is nullable write a __?__ after the variable type.
When a variable has a nullable type the variable can store null.

//code
string myString = null;
// Results in an error because myString cannot be null.
string? myString = 'Hello World!';
// Indicating that myString can be null.

//text
To indicate that array memebers are nullable write any type followed by a __?__ ending with __[]__.

//code
int[] myArray = null;
// Results in an error because myArray cannot be null.
int[] myArray = [1,4,null];
// Results in an error because myArray cannot contain null values.

//code
int[]? myArray = null;
// Indicating that myArray can be null.
int?[] myArray = [1,4,null];
// Indicating that myArray can contain null values.

//text
To indicate that the return type of a method is nullable write any a __?__ after the return type.

//code
string myMethod(){
    return null;
}
// Results in an error because the return type of myMethod cannot be null.

//code
string? myMethod(){
    return null;
}
// Indicating that the return type of myMethod can be null.

//code
string func() myMethod = null;
// Results in an error because myMethod cannot be null.
string func() myMethod = (){
    return null;
}
// Results in an error because the return type of myMethod cannot be null.

//code
string func()? myMethod = null;
// Indicating that myMethod can be null.
string? func() myMethod = (){
    return null;
}
// Indicating that the return type of myMethod can be null.

//code
string func() myMethod = {
    return null;
}
// Results in an error because the return type of myMethod cannot be null.

//code
string? func() myMethod = {
    return null;
}
// Indicating that the return type of myMethod can be null.

//subtitle
Optional chaining (?)

//text
The __?__ operator can be used on nullable variables to indicate optional chaining.
When null occurs in a statement the statement will be exited while an expression also returns null.

//subtitle
Members

//text
To access an object member write any object variable followed by __?.__ ending with any member.

//code
int? myInt = null;
string? myString = myInt?.toString();
// myString becomes: null.
myInt = 13135;
myString = myInt?.toString();
// myString becomes: '13135'.


//code
class MyClass
{
    int? myInt;
}

MyClass myClass = null;
myClass?.myInt = 13135;
// Statement exits after myClass
myClass = MyClass();
myClass?.myInt = 13135;
// myClass.myInt becomes: 13135

//subtitle
Functions

//text
To call a function write any function variable followed by __?__ ending with any parameter body.
Any array, tuple or anonymous object parameter body can be used.

//code
string func()? myMethod = null;
string? myString = myMethod?();
// myString becomes: null
myMethod = () {
    return 'Hello World!';
};
string? myString = myMethod?();
// myString becomes: 'Hello World!'

//code
class MyClass
{
    void func()? myMethod;
}

MyClass myClass = MyClass();

myClass.myMethod?();
// Statement exits after myClass
myClass.myMethod = (){
    print('Hello World!');
}
myClass.myMethod?();
// Statement prints: 'Hello World!'

//subtitle
Cascading

//text
To access cascading members write any variable followed by __?__ ending with __{}__.

//code
class MyClass
{
    public int? myInt;
    public string? myString;
}

MyClass? myClass = null;

myClass?{
    myInt = 13135;
    myString = 'Hello World!';
    myMethod();
};
// Statement exits after myClass
myClass = MyClass();
myClass?{
    myInt = 13135;
    myString = 'Hello World!';
    myMethod();
};
// myClass.myInt becomes: 13135
// myClass.myString becomes: 'Hello World!'
// myClass.myMethod gets called

//subtitle
Indexing

//text
To access index members write any variable followed by __?__ ending with __[]__.

//code
string[]? myArray = null;
myArray?[0] = 'Hello World!';
// Statement exits after myArray
myArray = [];
myArray?[0] = 'Hello World!';
// myArray[0] becomes: 'Hello World!'

//code
string[]? myArray = null;
string? myString = myArray?[0];
// myString becomes: null.
myArray = [];
myArray?[0] = 'Hello World!';
// myString becomes: 'Hello World!'

//subtitle
Null-coalescing (??)

//text
The __??__ operator can be used to add default values to nullable variables.

//code
string mySecondString = myString ?? 'Default value';
// mySecondString becomes the value of myString when myString is not null.
// When myString is null mySecondString becomes 'Default value'.

//title
Ternary (? :)

//text
The __? :__ operators are used to create an if statement that can ben used inside of expressions.
To use the ternary operator write to following structure; a boolean expression, __?__, an expression of any type, __:__, an expression of any type.

//code
myBoolean = false;
string myString = myBoolean ? 'True' : 'False';
// myString becomes: 'False'

//title
Assignment

//text
Assignment operators are used to assign or for reassigning a value to a variable.
For more information about combined assignment operators check their chapters.

//tablehead
Operator`   Name`                                       Combined operator`  Example`            Same as

//table
=`          Assignment`                                 None`               myInt = 0;`         None
+=`         Addition assignment`                        +`                  myInt += 5;`        myInt = myInt + 5; 
++`         Increment assignment`                       ++`                 myInt++;`           myInt = ++myInt; or myInt = myInt + 1;
-=`         Negation or Subtraction assignment`         -`                  myInt -= 5;`        myInt = myInt - 5; 
--`         Decrement assignment`                       --`                 myInt--;`           myInt = --myInt; or myInt = myInt - 1;
*=`         Multiplication assignment`                  *`                  myInt *= 5;`        myInt = myInt * 5; 
/=`         Division assignment`                        /`                  myInt /= 5;`        myInt = myInt / 5; 
**=`        Exponentiation assignment`                  **`                 myInt **= 5;`       myInt = myInt ** 5; 
!!!`        Factorization`                              !`                  myInt!!!;`          myInt = myInt!; 
%=`         Modulation assignment`                      %`                  myInt %= 5;`        myInt = myInt % 5;
&=`         Bitwise AND assignment`                     &`                  myInt &= 5;`        myInt = myInt & 5; 
|=`         Bitwise OR assignment`                      |`                  myInt |= 5;`        myInt = myInt | 5; 
^=`         Bitwise XOR assignment`                     ^`                  myInt ^= 5;`        myInt = myInt ^ 5; 
~~`         Bitwise NOT assignment`                     ~`                  myInt~~;`           myInt = ~myInt;
>>=         Bitwise signed right shift assignment`      >>`                 myInt >>= 5;`       myInt = myInt >> 5; 
<<=`        Bitwise signed left shift assignment`       <<`                 myInt <<= 5;`       myInt = myInt << 5; 
>>>=        Bitwise signed right shift assignment`      >>>`                myInt >>>= 5;`      myInt = myInt >>> 5;  
<<<=`       Bitwise unsigned left shift assignment`     <<<`                myInt <<<= 5;`      myInt = myInt <<< 5; 
@>>>=       Bitwise signed right shift loop assignment` @>>>`               myInt @>>>= 5;`     myInt = myInt @>>> 5;  
@<<<=`      Bitwise unsigned left shift loop assignment`@<<<`               myInt @<<<= 5;`     myInt = myInt @<<< 5; 
??=`        Null-coalescing assignment`                 ??`                 myInt ??= 5;`       myInt = myInt ?? 5; or myInt = myInt == null ? 5 : myInt;
&&=`        Logical AND assignment`                     &&`                 myBoolean &&= true;`myBoolean = myBoolean && true;
||=`        Logical OR assignment`                      ||`                 myBoolean ||= true;`myBoolean = myBoolean || true;
^^=`        Logical XOR assignment`                     ^^`                 myBoolean ^^= true;`myBoolean = myBoolean ^^ true;
!!`         Logical NOT assignment`                     !`                  myBoolean!!;`       myBoolean = !myBoolean;

//subtitle
Assignment (=)

//text
The __=__ is used to assign a literal value or variable to a variable.

//code
int myInt = 0;
int mySecondInt = myInt + 5;
// mySecondInt becomes: 5

//title
Comparison

//text
Comparison operators are used to compare two values with each other to return a boolean.

//tablehead
Operator`   Name`                       Example

//table
==`         Equal to`                   myInt == 6
!=`         Not equal to`               myInt != 6
>`          Greater than`               myInt > 6
>=`         Greater than or equal to`   myInt >= 6
<`          Less than`                  myInt < 6
<=`         Less than or equal to`      myInt <= 6

//subtitle
Equal to (==)

//text
The __==__ operator can be used to check if two values are equal.

//code
if(myInt == 5){
    // Code that executes when myInt is equal to 5.
}

//subtitle
Not equal to (!=)

//text
The __!=__ operator can be used to check if two values are not equal.

//code
if(myInt != 5){
    // Code that executes when myInt is not equal to 5.
}

//subtitle
Greater than (>)

//text
The __>__ operator can be used to check if the left operand is greater than the right operand.

//code
if(myInt > 5){
    // Code that executes when myInt greater than 5.
}

//text
The __>__ operator can also be used on two strings, arrays, lists or sets to check if the left operand is a proper superset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
bool myBoolean = '12' > '2';

myBoolean = [1,2] > [2];

myBoolean = {1,2} > {2};

//subtitle
Greater than or equal to (>=)

//text
The __>=__ operator can be used to check if the left operand is greater than or equal to the right operand.

//code
if(myInt >= 5){
    // Code that executes when myInt greater than or equal to 5.
}

//text
The __>=__ operator can also be used on two strings, arrays, lists or sets to check if the left operand is a superset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
bool myBoolean = '12' >= '2';
myBoolean = '12' >= '12';

myBoolean = [1,2] >= [2];
myBoolean = [1,2] >= [1,2];

myBoolean = {1,2} >= {2};
myBoolean = {1,2} >= {1,2};

//subtitle
Less than (<)

//text
The __<__ operator can be used to check if the left operand is less than the right operand.

//code
if(myInt < 5){
    // Code that executes when myInt less than 5.
}

//text
The __<__ operator can also be used on two strings, arrays, lists or sets to check if the left operand is a proper subset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
bool myBoolean = '2' < '12';

myBoolean = [2] < [1,2];

myBoolean = {2} < {1,2};

//subtitle
Less than or equal to (<=)

//text
The __<=__ operator can be used to check if the left operand is less than or equal to the right operand.

//code
if(myInt <= 5){
    // Code that executes when myInt less than or equal to 5.
}

//text
The __<=__ operator can also be used on two strings, arrays, lists or sets to check if the left operand is a subset of the right operand.
Note that the order matters when the operator is used on orderd sequences.

//code
bool myBoolean = '2' <= '12';
myBoolean = '12' <= '12';

myBoolean = [2] <= [1,2];
myBoolean = [1,2] <= [1,2];

myBoolean = {2} <= {1,2};
myBoolean = {1,2} <= {1,2};

//title
Logical

//text
Logical operators are used to compare two booleans with each other to return one boolean.

//tablehead
Operator`   Name`           Example

//table
&&`         Logical AND`    true && true     
||`         Logical OR`     false || true
^^`         Logical XOR`    false ^^ true
!`          Logical NOT`    !false

//subtitle
Logical AND (&&)

//text
The __&&__ operator is used to evaluate two boolean expressions. When both expressions are evaluated to true the logical AND expression is evaluated to true.
To use the logical AND operator, write a boolean expression followed by __&&__ and ending with another boolean expression.

//code
if(myBoolean && mySecondBoolean){
    // Code that executes when myBoolean and mySecondBoolean are true.
}

//subtitle
Logical OR (||)

//text
The __||__ operator is used to evaluate two boolean expressions. When at least one expression is evaluated to true the logical OR expression is evaluated to true.
To use the logical OR operator, write a boolean expression followed by __||__ and ending with another boolean expression.

//code
if(myBoolean || mySecondBoolean){
    // Code that executes when myBoolean and/or mySecondBoolean is true.
}

//subtitle
Logical XOR (^^)

//text
The __^^__ operator is used to evaluate two boolean expressions. When only one expression is evaluated to true the logical XOR expression is evaluated to true.
To use the logical XOR operator, write a boolean expression followed by __^^__ and ending with another boolean expression.

//code
if(myBoolean ^^ mySecondBoolean){
    // Code that executes when myBoolean or mySecondBoolean is true.
}


//subtitle
Logical NOT (!)

//text
The __!__ operator can be used to negate/invert a boolean value.
To use the logical not operator, write __!__ followed by a boolean expression.

//code
if(!myBoolean){
    // Code that executes when myBoolean is false.
}

//title
Logical Comparison

//text
Logical Comparison operators are used to compare two values with each other.
These operators are different to normal comparison because Logical Comparison operators let you chain multiple comparison operations to the same value.

//tablehead
Operator`   Name`                           Example`            Same as

//table
&==`        And equal to`                   myInt > 5 &== 7`    myInt > 5 && myInt == 7
&!=`        And not equal to`               myInt > 5 &!= 7`    myInt > 5 && myInt != 7 
&>`         And greater than`               myInt < 7 &> 5`     myInt < 5 && myInt > 7 
&>=`        And greater than or equal to`   myInt < 7 &>= 5`    myInt < 5 && myInt >= 7 
&<`         And less than`                  myInt > 5 &< 7`     myInt > 5 && myInt < 7 
&<=`        And less than or equal to`      myInt > 5 &<= 7`    myInt > 5 && myInt <= 7
|==`        Or equal to`                    myInt > 5 |== 3`    myInt > 5 || myInt == 3
|!=`        Or not equal to`                myInt > 5 |!= 3`    myInt > 5 || myInt != 3
|>`         Or greater than`                myInt < 7 |> 5`     myInt < 5 || myInt > 7
|>=`        Or greater than or equal to`    myInt < 7 |>= 5`    myInt < 5 || myInt >= 7
|<`         Or less than`                   myInt > 5 |< 3`     myInt > 5 || myInt < 3
|<=`        Or less than or equal to`       myInt > 5 |<= 3`    myInt > 5 || myInt < 3
^==`        Xor equal to`                   myInt > 5 ^== 3`    myInt > 5 ^^ myInt == 3
^!=`        Xor not equal to`               myInt > 5 ^!= 3`    myInt > 5 ^^ myInt != 3
^>`         Xor greater than`               myInt < 7 ^> 5`     myInt < 5 ^^ myInt > 7
^>=`        Xor greater than or equal to`   myInt < 7 ^>= 5`    myInt < 5 ^^ myInt >= 7
^<`         Xor less than`                  myInt > 5 ^< 3`     myInt > 5 ^^ myInt < 3
^<=`        Xor less than or equal to`      myInt > 5 ^<= 3`    myInt > 5 ^^ myInt < 3                 

//title
Bullet expression

//text
Bullet expressions can be used to define short logic inside another expression.
Bullet expressions are only evaluated when the given boolean is true.
The following operators can be used with bullet expressions to define short logic.

//tablehead
Operator`   bullet expression operator(s)

//table
=`          <?                                              
+=`         <? 
-=`         <? 
*=`         <? 
/=`         <? 
**=`        <? 
%=`         <?
&=`         <? 
|=`         <? 
^=`         <?
>>=`        <?
<<=`        <?
>>>=`       <? 
<<<=`       <?
@>>>=`      <? 
@<<<=`      <?
+`          <? or >? 
-`          <? or >? 
*`          <? or >? 
/`          <? or >? 
**`         <? or >? 
%`          <? or >? 
|`          <? or >? 
^`          <? or >? 
>>`         <? or >?
<<`         <? or >? 
>>>`        <? or >?
<<<`        <? or >? 
@>>>`       <? or >?  
@<<<`       <? or >? 
,`          <? or >? 

//subtitle
Left bullet expression (<?)

//text
The __<?__  operator is used to define a bullet expression with the operator on the left hand side.
To use a left bullet expression write a valid operator followed by a boolean expression and the bullet operator and ending with a literal value or variable.

When the boolean expression is evaluated to true the value will be included in the expression.
When the boolean expression is evaluated to false the operand and the operator before the boolean expression will be ignored.

//code
int? myInt = myBoolean <? 7;
// myInt becomes: 7 when myBoolean is true
// myInt becomes: null when myBoolean is false

myInt = 5 + myBoolean <? 7;
// myInt becomes: 12 when myBoolean is true
// myInt becomes: 5 when myBoolean is false

myString = myBoolean <? 'Hello World!';
// myString becomes: "Hello World!" when myBoolean is true
// myString keeps the current value when myBoolean is false

//text
The __<?__ operator can also be used on a __,__ to optionaly add values to collections.

int[] myArray = [1,2,myBoolean <? 3]
// myArray becomes: [1,2,3] when myBoolean is true
// myArray becomes: [1,2] when myBoolean is false

//subtitle
Right bullet expression (>?)

//text
The __>?__  operator is used to define a bullet expression with the operator on the right hand side.
To use a right bullet expression write a boolean expression and the bullet operator followed by a literal value or variable and ending with a valid operator.

When the boolean expression is evaluated to true the value will be included in the expression.
When the boolean expression is evaluated to false the operand and the operator after operand will be ignored.

//code
int myInt = myBoolean >? 7 + 5;
// myInt becomes: 12 when myBoolean is true
// myInt becomes: 5 when myBoolean is false

myString = myBoolean >? 'Hello ' + 'World!';
// myString becomes: "Hello World!" when myBoolean is true
// myString becomes: "World!" when myBoolean is false

//text
The __>?__ operator can also be used on a __,__ to optionaly add values to collections.

int[] myArray = [myBoolean >? 1,2,3]
// myArray becomes: [1,2,3] when myBoolean is true
// myArray becomes: [2,3] when myBoolean is false

//chapter
Control statements

//text
Control statements are statements that direct the flow of your code to a desired path.

//title
Branching

//text
Branching statements are used when you want to branch your code in a well defined path.

//subtitle
If (if)

//text
The __if__ keyword is used when a specific block of code can only be executed under a specfied conditition.
To create an __if__ statement write __if__ followed by __()__ and ending with __{}__.
The body of an if statement only gets executed when the expression inside the __()__ is evaluated to __true__.

//code
if(myBoolean){
    // Code that executes when myBoolean is true.
}

if(myInt > 5){
    // Code that executes when myInt is greater than 5.
}

//subtitle
Else (else)

//text
The __else__ keyword can be used when a specfied block of code can only be executed when the parent if expression is evaluated to false.
To create an __else__ statement write __else__ followed by a __{}__.
Note that any __else__ statement must be bounded to an if, else if, while or for statement.

//code
if(myBoolean){
    // Code that executes when myBoolean is true.
}else{
    // Code that executes when myBoolean is false.
}

//text
The __else__ statement can also be bounded to any else if statement.
Note that the else statement only gets executed when the if and all the else if expressions are evaluated to false. 

//code
if(myBoolean){
    // Code that executes when myBoolean is true.
}else if(mySecondBoolean){
    // Code that executes when myBoolean is false and mySecondBoolean is true.
}else{
    // Code that executes when myBoolean is false and mySecondBoolean is false.
}

//text
The __else__ statement can also be bounded to any for or while loop or switch.
Note that the else statement only gets executed when the loop or switch finishes without executing a break.

//code
for(int value in values){
    // Code that executes for every value of values.
}else{
    // Code that executes when the loop ended.
}

while(myBoolean){
    // Code that executes for as long as myBoolean is true.
}else{
    // Code that executes when the loop ended.
}

switch (myInt)
{
    case(5){
        // Code that executes when myInt is 5.
        break;
    }
    case(6){
        // Code that executes when myInt is not 5 and is 6.
        break;
    }
}else{
    // Code that executes when the switch finishes.
}


//subtitle
Else if (else if)
The __else if__ keywords are used when a specfied block of code can only be executed when the parent if expression is returned to false and another expression is evaluated to true.
To create an __else if__ statement write __else if__ followed by __()__ and ending with __{}__.
Note that any __else if__ statement must be bounded to an if or else if statement.

//code
if(myBoolean){
    // Code that executes when myBoolean is true.
}else if(mySecondBoolean){
    // Code that executes when myBoolean is false and mySecondBoolean is true.
}

//text
The __else if__ statements can be stacked as many times as needed.

//code
if(myBoolean){
    // Code that executes when myBoolean is true.
}else if(mySecondBoolean){
    // Code that executes when myBoolean is false and mySecondBoolean is true.
}else if(myThirdBoolean){
    // Code that executes when myBoolean is false and mySecondBoolean is false and myThirdBoolean is true.
}

//subtitle
Switch (switch), (case), (default), (break)

//text
The __switch__ keyword is used to check a certain value for many cases.
To create a __switch__ statement write __switch__ followed by __()__ and ending with __{}__.
Inside the __()__ enter any value.

The __case__ keyword is used to define a block of code that gets executed when the value from the switch is equal to the value(s) in the switch statement.
To create a case write __case__ followed by __()__ and ending with __{}__ inside the __{}__.
Inside the __()__ enter any value with the same type as the value from the switch statement.
Any number of case statements is allowed.

//code
switch(myInt)
{
    case(5){
        // Code that executes when myInt is 5.
    }
    case(6){
        // Code that executes when myInt is 6.
    }
}

//text
The __,__ can be used to define multiple values in one switch statement.
These comma separated values work like a logical or operator.

//code
switch(myInt)
{
    case(5,6){
        // Code that executes when myInt is 5 or 6.
    }
}

//text
The __break__ keyword can be used to break out of the switch statement and stops checking any other cases.

//code
switch(myInt)
{
    case (5){
        // Code that executes when myInt is 5.
        break;
    }
    case (6){
        // Code that executes when myInt is 6.
        break;
    }
}

//text
The __else__ statement can be used to define a block of code that only gets executed when the switch finishes without encountering a __break__ statement.

//code
switch (myInt)
{
    case(5){
        // Code that executes when myInt is 5.
        break;
    }
    case(6){
        // Code that executes when myInt is not 5 and is 6.
        break;
    }
}else{
    // Code that executes when myInt is not 5 and is not 6.
}

//title
Looping

//text
Loops are used to iterate over sequences of code that need to run for a specified amount of times.

//subtitle
For (for), (in), (with)

//text
The __for__ keyword is used to define a block of code that can be executed multiple times.
To create a for loop write __for__ followed by __()__ and ending with __{}__.

The __in__ keyword is used to bind variable(s) to a given collection of items.
To create an in statement write one or two comma separated variable declarations followed by __in__ ending with a collection.

Note that in statements can only be defined between the __()__ of a __for loop__.

//code
for(string value in myArray){
    print(value);
    // Code that executes for every value of the myArray array.
}

Map<string,int> myMap = {'FirstValue':4,'SecondValue':9};
for(string key, int value in myMap){
    print(index);
    print(value);
    // Code that executes for every value of the myArray array.
}

//text
The __with__ keyword is used to bind an integer variable to the index of a __for in loop__.
To use the __with__ statement, write after the content in the __()__ __with__ followed by an integer variable declaration.

//code
for(string value in myArray with int index){
    print(value);
    print(index);
    // Code that executes for every value of the myArray array.
}

//text
The __for loop__ can also be used to loop a defined amount of times by defining two code statements and one boolean expression.
To create such a __for loop__ write inside the __()__ of the for loop a code statement followed by a boolean expression and ending with another code statement.
The first code statement wil only be executed once when the loop gets executed.
The boolean expression will be executed before each iteration. When evaluated to true the code block of the __for loop__ wil be executed.
The second code statement will be executed at the end of every iteration.

//code
for(int i = 0; i < 10; i++){
    // Code that executes for as long as i is less than 10.
}

//subtitle
While (while), (do)

//text
The __while__ keyword is used to define a block of code that gets executed while a boolean expression is evaluated to __true__.
To create a __while loop__ write __while__ followed by __()__ and ending with __{}__.
Note that when myBoolean is __false__ before the __while loop__ is executed, the codeblock of the __while loop__ never gets executed.

//code
while(myBoolean){
    // Code that executes as long as myBoolean is true.
}

//text
The __do__ keyword is used to move the code block from the while loop to above the while loop so the code block always gets executed at least once.
To create a __do while loop__ write __do__ then __{}__ followed by __while__ and ending with __()__.
Between the __()__ a boolean expression is required.
Note that when myBoolean is __false__ before the __do while loop__ is executed, the code block of the __do while loop__ gets executed once.

//code
do{
    // Code that executes at least once, after which it executes as long as myBoolean is true.
}while(myBoolean)


//subtitle
Else after loops (else)

//text
The __else__ keyword can be used to bind a block of code to any loop. This code gets executed when the loop finishes without encountering a __break__ statement.
To bind the __else__ statement write __else__ followed by __{}__.

//code
for(string value in myArray){
    // Code that executes for every value of the myArray array.
}else{
    // Code that executes when the for loop finishes.
}

for(int i = 0; i < 10; i++){
    // Code that executes for as long as i is less than 10.
}else{
    // Code that executes when the for loop finishes.
}

do{
    // Code that executes at least once, after which it executes as long as myBoolean is true.
}while(myBoolean)else{
    // Code that executes when the do while loop finishes.
}

//text
When using the __break__ statement inside a loop the else statement wil not be executed.

//code
for(string value in myArray){
    break;    
}else{
    // Code gets never executed because the break statement is used.
}

//subtitle
Break (break)

//text
The __break__ keyword is used to exit/break out of any loop.
To use a __break__ statement write __break__ and ending with a __;__.
Note that code after a break statement does not get executed.

//code
for(int i = 0; i < 10; i++){
    // Code that executes for as long as i is less than or equal to 5.
    if(i == 5){
        break;
        // Code that never gets executed.
    }
    // Code that executes for as long as i is less than 5.
}

//text
When using the __break__ statement the else statement of any loop wil not be executed.

//code
for(string value in myArray){
    break;    
}else{
    // Code that never gets executed because the break statement is used.
}


//subtitle
Continue (continue)

//text
The continue keyword is used to stop/break out of the current iteration of the loop, and continue to the next iteration of said loop.
To use a continue statement write __continue__ followed by a __;__.
Note that code after a continue statement does not get executed.

//code
for(int i = 0; i < 10; i++){
    // Code that executes for as long as i is less than or equal to 5.
    if(i == 5){
        continue;
        // Code that never gets executed.
    }
    // Code that executes for every iteration except when i is equal to 5.
}

//title
Error handling

//subtitle
Try catch (try), (catch)
//Misschien then toevoegen?

//text
The __try catch__ keywords are used to catch and handle errors that can occur at runtime.
Use the __try__ statement to create a block of code that can pass errors to the catch statement.
Use the __catch__ statement to bind a block of code to the try statement to catch and handle its errors.
To use a __try catch__ statement write the following structure; __try__, __{}__, __catch__, __()__, __{}__.
Note that between the __()__ of the catch statement you must define an exception parameter.

//code
try{
    // Code that gets checked for errors at runtime to pass them to the catch statement.
}catch(Exception e){
    // Code that executes when an error has occurred in the try statement.
}

//title
Null safety handling

//chapter
Types

//title
Literal types

//text
Literal types are build in types with a more generic or specific meaning.
Mace has the following literal types.

//table
void
class
interface
enum
object
func
dynamic
type

//subtitle
Void (void)

//text
The __void__ literal type can be used to to store null.
A void literal type can never be used by itself.

//code
void func() myMethod = (){
    // Your method code.
};

//code
string | void myString = null;
myString = 'Hello World!';

//text
The __?__ operator can be used as a shorthand to create nullable types.

//code
string? myString = null;
// The type of myString becomes: string | void
myString = 'Hello World!';

//subtitle
Class (class)

//text
The __class__ literal type can be used to store any class object that did not inherit an interface.

//code
class MyClass
{
    // Your class members.
}

class myClass = MyClass();

//subtitle
Interface (interface)

//text
The __interface__ literal type can be used to store any class object that inherited an interface.

//code
interface MyInterface
{
    // Your interface members.
}

class MyClass extend MyInterface
{
    // Your class members.
}

interface myClass = MyClass();

//subtitle
Enum (enum)

//text
The __enum__ literal type can be used to store any enum object.

//code
enum MyEnum
{
    MyEnumValue
}

enum MyEnum = MyEnum.MyEnumValue;

//subtitle
Object (object)

//text
The __object__ literal type is be used to store any class, interface or enum object.

//code
class MyClass
{
    // Your class members.
}

object myObject = MyClass();

//code
interface MyInterface
{
    // Your interface members.
}

class MyClass extend MyInterface
{
    // Your class members.
}

object myObject = MyClass();

//code
enum MyEnum
{
    MyEnumValue
}

object myObject = MyEnum.MyEnumValue;

//subtitle
Function (func)

//text
The __func__ literal type can be used to store any function or method.

//code
void myMethod(){
    // Your method code.
}

func myStoredMethod = myMethod;

//code
void func() myMethod = (){
    // Your method code.
};

func myStoredMethod = myMethod;

//code
void func() myMethod = {
    // Your method code.
};

func myStoredMethod = myMethod;

//subtitle
Dynamic (dynamic)

//text
The __dynamic__ literal type is be used to store any value except null.

//code
class MyClass
{
    // Your class members.
}

dynamic myDynamic = MyClass();

myDynamic = 13135;
myDynamic = true;
myDynamic = 'Hello World!'

//subtitle
Type (type)

//text
The __type__ literal type is used to create custom types from currently existing types.
To create a custom type write the following structure; __type__, unique type name, __=__, type expression.
Custom types can only be defined inside a namespace.

//code
type MyType = string | int;

//text
Custom types can be used at any place where a normal type can be used.

//code
type MyType = string | int;
MyType myType = 13135;
// myType can now contain int or string values.
myType = 'Hello World!'

//title
Type expressions

//text
Type expressions can be used to create more complex types.
These expressions can be used to create custom types, or they can be used at any place where a normal type can be used.
The following operators can be used in type expressions.

//tablehead
Operator`   Name`                   Example`                       Usage

//table
[]`         Array indicator`        string[] myArray`              Convert type to array type
()`         Method indicator`       string() myMethod`             Convert type to method type
?`          Nullability indicator`  string? myString`              Convert type to nullable type
*`          Pointer indicator`      string* myPointer`             Convert type to pointer type
&`          Reference indicator`    string& myReference`           Convert type to reference type
|`          Bitwise OR`             int | string myIntString`      Create union of two types   
&`          Bitwise AND`            (int | string) & int myInt`    Create intersect of two types                 
^`          Bitwise XOR`            (int | string) ^ int myString` Create symmetric difference of two types

//subtitle
Array indicator ([])

//text
The __[]__ operator can be used to indicate that a type is an array type.
To create an array type write any type followed by __[]__.

//code
int[] myArray = [1,2,3,4,5];

int myInt = myArray[3];
// myInt becomes: 4

//text
The __[]__ operator can stacked to create multidimensional arrays.

//code
int[][] = myMultidimensionalArray = [[1,2],[3,4]];

int[] myArray = myMultidimensionalArray[0];
// myArray becomes: [1,2]
int myInt = myMultidimensionalArray[0][1];
// myInt becomes: 2

//text
To specify the length of an array write any integer between the __[]__.

//code
int[5] myArray = [1,2,3,4,5];

//code
int[5] myArray = [1,2,3,4,5,6];
// Results in error.

//subtitle
Method indicator (())

//text
The __()__ operator can be used to indicate that a type is a method type.
To create a method type write any type followed by __()__.

//code
string func() myMethod = (){
    // Your method code.
    return 'Hello World!';
};

string myString = myMethod();
// myString becomes: 'Hello World!'

//text
The __()__ operator can be stacked to create higher order functions.

//code
string func()() myHigherOrderFunction = (){
    // Your method code.
    return (){
        // Your higher order function code.
        return 'Hello World!';
    };
};

string func() myMethod = myHigherOrderFunction();
// myMethod becomes: string(){ return 'Hello World!'; }
string myString = myHigherOrderFunction()();
// myString becomes: 'Hello World!'.

//subtitle
Nullability indicator (?)

//text
The __?__ operator can be used to indicate that a type is a nullable type.
To create a nullable type write any type followed by __?__.

//code
string? myString = null;
// The type of myString becomes: string | void
myString = 'Hello World!';

//subtitle
Pointer indicator (*)

//text
The __*__ operator can be used to indicate that a type is a pointer type.
To create a pointer type write any type followed by __*__.

//code
string myString = 'Hello World!';
string* myPointer = &myString;

string mySecondString = *myPointer;
// mySecondString becomes: 'Hello World!'

//text
The __*__ operator can be stacked to create chain pointers.

//code
string myString = 'Hello World!';
string* myPointer = &myString;
string** myChainPointer = &myPointer;

string* mySecondPointer = *myChainPointer;
// mySecondPointer becomes: the value of myPointer
string mySecondString = **myChainPointer;
// mySecondString becomes: 'Hello World!'

//subtitle
Reference indicator (&)

//text
The __&__ operator can be used to indicate that a type is a reference type.
To create a reference type write any type followed by __&__.

//code
string myString = 'Hello World!';

string& myReference = myString;
// myReference becomes: 'Hello World!' 

//subtitle
Bitwise OR (|)

//text
The __|__ operator can be used to get the union of two types.

//code
type MyType = int | string;

MyType myIntString = 5
// myIntString can now contain int or string values.
myIntString = 'Hello World!';

//subtitle
Bitwise AND (&)

//text
The __&__ operator can be used to get the intersect of two types.

//code
type MyType = (int | char | string) & (double | int | string);
// MyType becomes: int | string

MyType myIntString = 5;
// myIntString can now contain int or string values.
myIntString = 'Hello World!';

//subtitle
Bitwise XOR (^)

//text
The __^__ operator can be used to get the symmetric difference of two types.

//code
type MyType = (double | char | int) ^ (double | string | char);
// MyType becomes: int | string

MyType myIntString = 5;
// myIntString can now contain int or string values.
myIntString = 'Hello World!';

//title
Generics (<>)

//text
Generic types are custom types that can be defined as parameters.
To declare generic types write the flowing structure; __<__, comma separated unique types, __>__.
To define generic types use the same structure with existing types as parameters.
When using a data structure with generic types the types may be omitted to use the type itself.
Generic types can be added to the following data structures.

//table
class
interface
function
method
type

//subtitle
Class (class)

//text
Generic types can be declared after the created class name.
Define the generic types after the class name when using the class type or when creating an instance of the class.
The generic types can be used inside the class or they can be used to define generic types from inherited classes or implemented interfaces.

//code
class MyClass<MyGeneric>
{
    MyGeneric? myGeneric;
}

MyClass<string> myClass = MyClass<string>();
MyClass mySecondClass = MyClass<int>()

//code
interface MyInterface<MyGeneric>
{
    // Your interface members.
}

class MyClass<MyGeneric> extend MyInterface<MyGeneric>
{
    // Your class members.
}

class MySecondClass extend MyClass<string>
{
    // Your class members.
}

//subtitle
Interface (interface)

//text
Generic types can be declared after the created interface name.
Define the generic types after the interface name when implementing or inheriting the interface.
The generic types can be used inside the interface or they can be used to define generic types from implemented interfaces.

//code
interface MyInterface<MyGeneric>
{
    MyGeneric? myGeneric;
}

class MyClass extend MyInterface<string>
{
    // Your class members.
}

interface MySecondInterface<MyGeneric> implement MyInterface<MyGeneric>
{
    // Your interface memebers.
}

//subtitle
Function (func)

//text
Generic types can be declared before the __()__ when creating a method or function.
Define the generic types before the __()__ when calling a method or function or when using the method or function type.
The generic types can be used as return type, parameter type or inside the function or method.

//code
void myMethod<MyGeneric>(){
    // Your method code.
}

void func<MyGeneric>() myMethod = {
    // Your method code.
};

//code
MyGeneric myMethod<MyGeneric>(MyGeneric myParameter){
    MyGeneric myGeneric = myParameter;
    return myGeneric;
}

MyGeneric func<MyGeneric>(MyGeneric myParameter) myMethod = {
    MyGeneric myGeneric = myParameter;
    return myGeneric;
};

//subtitle
Type (type)

//text
Generic types can be declared after the created type name.
Define the generic types after the type name when using the type.
The generic types can be used in the type expression on the right hand side of the assignment.

//code
type MyType<MyGeneric> = List<MyGeneric> | string;

MyType<string> myType = List<string>();

//subtitle
Default type (=)

//text
The __=__ operator can be used to set a default type for a generic type.
To set a default type for a generic type write your generic type followed by __=__ ending with any type.
When a generic type has a default type the type can optionaly be omitted.

//code
class MyClass<MyGeneric = string>
{
   // Your class members.
}

MyClass myClass = MyClass();
// MyGeneric of myClass becomes: string
myClass<int> myClassSecond = MyClass<int>()
// MyGeneric of myClassSecond becomes: int

//subtitle
Constraint type

//text
Constraint types indicate that the generic type can only contain types of the constraint type.
To set a constraint type for a generic type write any type before your generic type.

//code
class JsonValue<(string | int) JsonType>
{
    initialize JsonType value;
    JsonType(JsonType value){
        this.value = value;
    }
}

JsonValue<string> jsonStringValue = JsonValue<string>('Hello World!');
// jsonStringValue.value becomes: 'Hello World!'
JsonValue<int> jsonIntValue = JsonValue<int>(13135);
// jsonIntValue.value becomes: 13135

JsonValue<bool> jsonIntValue = JsonValue<bool>(true);
// Results in error.

//title
Auto (auto)

//text
The __auto__ keyword can be used to use reference an expected type.
When defining any value the value is required to have a declared type.
This type can be referenced with the __auto__ keyword.

//code
Map<string,int> myMap = auto();
Map mySecondMap = auto<string,int>();

//code
void func() myMeyhod = auto(){};
void func(string myString) mySecondMethod = auto(string myString){};

//code
int[] myArray = auto[];
[int,string] mySecondArray = auto[13135, 'Hello World!']

//subtitle
Return

//text
The auto keyword can also be used to declare variable inside of functions this will referencing the return type of the function.

//code
Map<string,int> myMethod(){
    auto myMap = auto();

    return myMap;
}

//code
[string myString,int myInt] myMethod(){
    auto myArray = [13135, 'Hello World!'];

    return myArray;
}

//title
Type casting

//text
The __<>__ operator can be used to cast any value to a given type.
To cast a value write any type between __<>__ followed by any value.

//code
int myInt = 13135;
string myString = <string>myInt;
// myString becomes: '13135'

//code
string myString = '13135';
int myInt = <int>myString;
// myInt becomes: 13135

//subtitle
Defining

//text
Type casting methods can be declared in the class that needs to be casted to a different type.
To declare a type cast method write the following structure; __this__, __<__, type to cast to __>__, __{}__.
A value of the given type cast type must be returned.

//code
class MyClass
{
    this<string>{
        // You type casting code
        return 'Hello World!';
    }
}

MyClass myClass = MyClass();
string myString = <string>myClass;
// myString becomes: 'Hello World!';

//subtitle
Default value

//text
The __default__ keyword can be used to retrive the default value of the type when the typ casting was not successfull.

//code
string myString = 'Hello World!';
int myInt = <default int>myString;
// myInt becomes: 0

//title
References and Pointers

//tablehead
Operator`   Name

//table
&`          Reference or Address-of operator
*`          Pointer or Dereference operator

//chapter
References

//text
The __&__ can be used to create a reference to a variable.
To create a reference write any datatype followed directly by __&__.
The reference can be used in the same way as a variable because it points to the same value at the same address.
Note that because the variable and the reference point to the same value, if the value of the variable is changed, the value of the reference is also changed.

//code
int myInt = 0;
int& myIntReference = myInt;
// myIntReference becomes: 0
myInt = 3;
// myIntReference becomes: 3

//text
A reference can be used in methods as a parameter.
This allowes manipulation of variables without creating new/temporary values.

//code
int myInt = 0;
void addTwo(int& myIntReference){
    myIntReference += 2;
}
addTwo(myInt);
// myInt becomes: 2

//subtitle
Address-of operator

//text
The __&__ can also be used to get the address of a variable.

//chapter
Pointers

//text
The __*__ can be used to create a pointer to an address of a variable.
To create a pointer write any datatype followed directly by __*__.
Note that because the pointer points to an address, when assigning a pointer, an address must be given.

//code
int myInt = 0;
int* myPointer = &myInt;
// myPointer becomes: 0x61feb4

//subtitle
Dereference operator

//text
The __*__ can also be used to get the value of a given address.
The dereference operator makes it possible to work with pointers until the value is needed.
Note that if the value is a pointer as well, that pointer will be returned.

//code
int myInt = 0;
int* myPointer = &myInt;
int mySecondInt = *myPointer;
myInt = 3;
// mySecondInt becomes: 0

//text
To create a pointer to another pointer use the corresponding amount of __*__.

//code
int myInt = 0;
int* myPointer = &myInt;
int** myDoublePointer = &myPointer;
int*** myTriplePointer = &myDoublePointer;
int mySecondInt = ***myTriplePointer;
// mySecondInt becomes: 0

//chapter
Unpacking ([]), ({})

//text
Unpacking is used to unpack the values from an object to seperate variables.
When the unpacking variables have the same (sub)type any array,tuple or anonymous object with that type can be unpacked.
When the sub(type) do not match only literal arrays or anonymous objects can ben unpacked.
There are two variable types that can be unpacked.

//tablehead
Type`               Scope brackets`

//table
Array`              []`               
Tuple`              ()`
Anonymous object`   {}`
Classes`            {}`

//text
To unpack an object write the following structure; opening bracket, comma separated variable declarations, closing bracket.

//code
[int myInt, string myString] = [13135, 'Hello World!'];
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//code
(int myInt, string myString) = (13135, 'Hello World!');
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//code
{int myInt, string myString} = {myInt: 13135, myString: 'Hello World!'};
// myInt becomes: 13135
// mySecondInt becomes: 53131

//code
class MyClass
{
    public int myInt = 13135;
    public string myString = 'Hello World!';
}

{int myInt, string myString} = MyClass();
// myInt becomes: 13135
// mySecondInt becomes: 53131

//title
Default type

//text
When unpacking an object a default type can be defined.
To define a default type add the type before the brackets of the unpacking scope.
The default type can be overwritten by defining the variable type.

//code
int[myInt, string myString, mySecondInt] = [13135, 'Hello World!', 53131];
// myInt becomes: 13135
// myString becomes: 'Hello World!'
// mySecondInt becomes: 53131

//code
int(myInt, string myString, mySecondInt) = (13135, 'Hello World!', 53131);
// myInt becomes: 13135
// myString becomes: 'Hello World!'
// mySecondInt becomes: 53131

//code
int{myInt, string myString, mySecondInt} = {myInt: 13135, myString: 'Hello World!', mySecondInt: 53131};
// myInt becomes: 13135 
// myString becomes: 'Hello World!'
// mySecondInt becomes: 53131

//code
class MyClass
{
    public int myInt = 13135;
    public int mySecondInt = 53131;
    public string myString = 'Hello World!';
}

int{myInt, string myString, mySecondInt} = MyClass();
// myInt becomes: 13135 
// myString becomes: 'Hello World!'
// mySecondInt becomes: 53131

//title
Spread assignment

//text
The unpacking syntax can also be used to assign the same value to multiple variables.
All the unpacking variables must have the same (sub)type.

//code
[int myInt,int mySecondInt] = 13135;
// myInt and mySecondInt become: 13135

//code
(int myInt,int mySecondInt) = 13135;
// myInt and mySecondInt become: 13135

//code
{int myInt,int mySecondInt} = 13135;
// myInt and mySecondInt become: 13135


//subtitle
Sub types

//code
type MyType = string | int;
type MySecondType = int | bool;

[MyType myType,MySecondType mySecondType] = 13135;
// myType and mySecondType become: 13135

//code
(MyType myType,MySecondType mySecondType) = 13135;
// myInt and mySecondInt become: 53131

//code
{MyType myType,MySecondType mySecondType} = 13135;
// myType and mySecondType become: 13135

//title
Swapping value

//text
Unpacking can be used to swap two or more values.

//code
int myInt = 13135;
int mySecondInt = 53131;

[myInt,mySecondInt] = [mySecondInt,myInt];
// myInt becomes: 53131
// mySecondInt becomes: 13135

//code
(myInt,mySecondInt) = (mySecondInt,myInt);
// myInt becomes: 13135
// mySecondInt becomes: 53131

//code
{myInt,mySecondInt} = {myInt: mySecondInt,mySecondInt: myInt};
// myInt becomes: 53131
// mySecondInt becomes: 13135

//title
Functions binding

//text
Unpacking scopes can binded to any function.

//code
void myMethod(int myInt, string myString){
    // Your method code.
}

void func(int, string) myFunction = myMethod;

myMethod(13135, 'Hello World!');

//code
void myMethod[int myInt, string myString]{
    // Your method code.
}

void func[int, string] myFunction = myMethod;

myMethod[13135, 'Hello World!'];

//code
void myMethod{int myInt, string myString}{
    // Your method code.
}

void func{int, string} myFunction = myMethod;

myMethod{myInt: 13135, myString: 'Hello World!'};

//title
Stacking

//text
Unpacking can be stacked to access nested objects.
When the object is unorderd a name is required.

//code
[int myInt,[string myString]] = [13135,['Hello World!']];
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//code
(int myInt,(string myString)) = (13135,('Hello World!'));
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//code
{int myInt,myNested{string myString}} = {myInt: 13135,myNested:{myString: 'Hello World!'}};
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//code
class MyClass
{
    public int myInt = 13135;
    MySecondClass myNested = MySecondClass();
}

class MySecondClass
{
    string myString = 'Hello World!';
}

{int myInt,myNested{string myString}} = MyClass();
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//subtitle
Combining

//text
The unpacking of arrays and anonymous objects can be used interchangeably.

//code
[int myInt,{string myString,tuple(int mySecondInt)}] = [13135,{myString: 'Hello World!', tuple: (53131)}];
// myInt becomes: 13135
// myString becomes: 'Hello World!'
// mySecondInt becomes: 53131

//title
Optional

//text
Optional unpacking can be accomplished in three difference ways.

//table
Nullable
Default value
Default type value

//subtitle
Nullable (?)

//text
When an unpacking variable is nullable the value can optionaly be omitted.

//code
[int myInt, string? myString] = [13135];
// myInt becomes: 13135
// myString becomes: null

//code
(int myInt, string? myString) = (13135);
// myInt becomes: 13135
// myString becomes: null

//code
{int myInt, string? myString} = {myInt: 13135};
// myInt becomes: 13135
// myString becomes: null

//subtile
Default value (=)

//text
The __=__ is used to add a default value to an unpacking variable.
To add a default value write __=__ followed by any default value after the field name.

//code
[int myInt = 53131, string myString = 'Default value'] = [13135];
// myInt becomes: 13135
// myString becomes: 'Default value'

//code
(int myInt = 53131, string myString = 'Default value') = (13135);
// myInt becomes: 13135
// myString becomes: 'Default value'

//code
{int myInt = 53131, string myString = 'Default value'} = {myInt: 13135};
// myInt becomes: 13135
// myString becomes: 'Default value'

//subtitle
Default type value (default)

//text
The __default__ keyword can be used to fill the value of an unpacking variable with the class default value.

//code
[int myInt, default string myString] = [13135];
// myInt becomes: 13135
// myString becomes: ''

//code
(int myInt, default string myString) = (13135);
// myInt becomes: 13135
// myString becomes: ''

//code
{int myInt, default string myString} = {myInt: 13135};
// myInt becomes: 13135
// myString becomes: ''

//title
Skipping values (,)

//text
The __,__ operator can used be on array unpacking to skip values.

//code
[int myInt,,string myString] = [1,true,'Hello World!'];
// myInt becomes: 1
// myString becomes: 'Hello World!'

//code
(int myInt,,string myString) = (1,true,'Hello World!');
// myInt becomes: 1
// myString becomes: 'Hello World!'

//title
Collection spare values

//text
The __collect__ keyword can be used to keep the left over values.

//chaper
Anonymous objects

//text
The __object__ keyword can be used to create anonymous objects.

//title
Dynamic

//code
object int{int myInt,string myString} myObject = {myInt: 13135,myString: 'Hello World!'};

print(myObject.myInt);
print(myObject.myString);

//text
To create a dynamic anonymous object write the following structure; __object__, __{__, one or more field declarations, __}__, __=__, a literal anonymous object.

//title
Static

//text
To create a static anonymous object write the following structure; __object__, any type, __{__, one or more field names, __}__, __=__, a literal anonymous object.

//code
object int{myInt,mySecondInt} myObject = {myInt:13135,mySecondInt:53131};

print(myObject.myInt);
print(myObject.myString);

//chapter
Arrays ([])

//text
Arrays are variables that can contain multiple values.
To declare a standard array write any type followed by __[]__.
To define an array write __[__ followed by comma separated values and ending with __]__.
The defined elements must have the same type as the defined array (sub)type. 

//code
int[] myArray = [1,3,1];

//code
(int | double)[] myArray = [1,3.1];

//title
Indexing

//text
Array Indexing can be used to read or update elements inside of an array.
To index a value from an array variable write __[__ followed by any integer value ending with __]__.
Note that indexing starts at index 0.

//subtitle
Getting value

//code
int[] myArray = [1,3,1];

int myInt = myArray[1];
// myInt becomes: 3

//subtitle
Setting value

//code
int[] myArray = [1,3,1];

myArray[1] = 7;
// myArray becomes: [1,7,1]

//title
Sized

//text
Sized arrays can be used to create arrays with a specific numbers of elements.
To declare a sized array write the following structure; any type, __[__, any integer value, __]__.

//code
int[2] myArray = [1,3];

//code
int[1] myArray = [1];
// Results in error.

//code
int[2] myArray = [1,3,1];
// Results in error.

//title
Dynamic

//text
Dynamic arrays can be used to create small arrays with different types.
To create a dynamic array write __[__ followed by comma separated types ending with __]__.
Dynamic arrays must have at least two members.

//code
[int,string] myArray = [13135, 'Hello World!'];

//code
[int] myArray = [13135];
// Results in error.

//code
[int,string] myArray = [13135];
// Results in error.

//subtitle
Labels

//text
Labels can be added to dynamic array types to add an alternative method to index an array element.
Labels must be unique from one and other.

//code
[int myInt,string myString] myArray = [13135, 'Hello World!'];

string myString = myArray.myString;
// myString becomes: 'Hello World!'

myArray.myInt = 53131;
int myInt = myArray[0]
// myInt becomes: 13135

//subtitle
Default type

//code
Default types can be used to indicate that multiple array elements have the same type.
To declare an array with a default type add the type before the __[]__.
Use labels or omitted types to indicate where the default type needs to be applied.
When the type is not omitted this will override the default type.

//code
int[,,string myString] myArray = [1,3,'Hello World!'];

//code
int[myInt,mySecond,string myString] myArray = [1,3,'Hello World!'];

//text
Combining labels and omitted values is allowed.

int[myInt,,string myString] myArray = [1,3,'Hello World!'];

//text
When omitting types the default type will applied to the to omitted types around the commas.

//code
int[,] = [1,3];

//code
int[,] = [1];
// Results in error, expected two values.

//title
Spread assignment

//text
Spread assignment can be used to populate all elements of an array with the same value.
To use the spread assigning define the array with a value that has the same (sub)type as the array elements.

//code
int[5] myArray = 5;
// myArray becomes [5,5,5,5,5]

//code
[string,string] myArray = 'Hello World!';
// myArray becomes: ['Hello World!','Hello World!']

//code
type MyType = int | string;
type MySecondType = bool | int;

[MyType,MySecondType] myArray = 5;
// myArray becomes [5,5]

//title
Optional elements

//text
When defining an array with a literal array some array elements may omitted.
The omitted elements will become null if the element type is nullable else the element will become the default value of the element type.
If the element type is not nullable or does not have a default value the defined value can not be omitted.

//code
[int,int?,string] myArray = [13135,,'Hello World!'];
// myArray becomes: [13135,null,'Hello World!']

//chapter
Short assignment

//text
Short assignment can be used to replace variable declaration for an already declared variable.
When using short assignment the actual parameters or unpacking values are automatically assigned to the variables.
The keywords __this__ or __super__ may be used when using short assigning in classes.
Short assignment can be used in the following places:

//table
Parameter body
Array unpacking
Anonymous object unpacking

//title
Parameter body

//code
class MyClass
{
    string? myString;
    int? myInt;

    MyClass(this.myString, myInt){
        // Your constructor code.
    }

    void myMethod(myString, this.myInt){
        // Your method code.
    }
}

MyClass myClass = MyClass(13135,'Hello World!');
// myClass.myInt becomes: 13135
// myClass.myString becomes: 'Hello World!'

myClass.myMethod(53131,'Updated value!');
// myClass.myInt becomes: 53131
// myClass.myString becomes: 'Updated value!'

//text
When only using short assignment in a function or constructor parameter body the body may be omitted.

class MyClass
{
    string? myString;
    int? myInt;

    MyClass(this.myString, myInt);

    void myMethod(myString, this.myInt);
}

//title
Array unpacking

//code
int? myInt;
string? myString;

[myInt, myString] = [13135,'Hello World!'];
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//title
Anonymous object unpacking

//code
int? myInt;
string? myString;

{myInt, myString} = {myInt:13135,myString:'Hello World!'};
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//chaper
Tuples

//text
Tuples can be used to create small orderd sequences of objects with a specfied type.
A tuple must have at least two elements.

//code
(int,string) myTuple = (13135,'Hello World!');

//title
Indexing

//text
The __[]__ operator can be used to index values from a tuple.

//subtile
Getting value

//code
(int,string) myTuple = (13135,'Hello World!');
int myInt = myTuple[0];
// myInt becomes: 13135
string myString = myTuple[1];
// mySecondString becomes: 'Hello World!'

//title
Default type

//text
A default type can be added to tuples if multiple elements have the same type,
an empty element can be used to reference the default type.

//code
int(,string) myTuple = (13135,'Hello World!');

//title
Label

//text
Labels can optionaly be added to tuples element types the element at that index can now be access via the label.

//code
(int,string myString) myTuple = (13135,'Hello World!');
string mySecondString = myTuple.myString;
// mySecondString becomes: 'Hello World!'

//title
Sized

//text
Sized tuples can be created by adding a default type and an integer between the __()__.

//code
int(5) myTuple = (1,3,1,3,5); 

//text
Add a literal integer after any type in unpacking to repeat that type;

//code
(int 5,string 2) myTuple = (1,3,1,3,5,'Hello World!','Hello World!');

//chaper
Default and empty values

//text
The __default__ keyword can be used to populate variables or elements of a collection that are not defined.
To use default write __default__ before any type to indicate that is needs to be populated with the default value when empty.
//maybe base, def
//code
default int myInt;
// myInt becomes: 0

default double myDouble;
// myDouble becomes: 0.0

default string myString;
// myString becomes: ''

default bool myBoolean;
// myBoolean becomes: false

//code
default string[] myArray = ['Hello World!',];
// myArray becomes: ['Hello World!','']

default string[] myArray = [,];
// myArray becomes: ['','']

int default[] myArray;
// myArray becomes: []

default int default[5] myArray;
// myArray becomes: [0,0,0,0,0]

//code
default string default int{} myMap = {'Hello World!':13135,};
// myMap becomes: {'Hello World!':13135,'':0}

default string default int{} myMap = {,};
// myMap becomes: {'':0,'':0}

string int default{} myMap;
// myMap becomes: {}

//code
(int,default string) myTuple = ('Hello World!',);
// myTuple becomes: ('Hello World!','')

(default int,default string) myTuple = (,);
// myTuple becomes: (0,'')

default(default int,default string) myTuple;
// myTuple becomes: (0,'')

//text
When the return type of a method is default the method does not need to return a value the default value will be returned

//code
default string func() myMethod = (){};
string myString = myMethod();
// myString becomes: ''

default string default func() myMethod;
// myMethod becomes: (){}
string myString = myMethod();
// myString becomes: ''

//text
An empty return can also be used to return the default value;
default string myMethod(bool myBoolean){
    if(myBoolean){
        return;
    }
}

//text
Use default types as values

//code
int myInt = default int;
// myInt becomes: 0

double myDouble = default double;
// myDouble becomes: 0.0

string myString = default string;
// myString becomes: ''

bool myBoolean = default bool;
// myBoolean becomes: false

//text 
Defining default constuctor
Default constructors work the same way as any other constructor

//code
class MyClass
{
    default(){
        // You default constructor code
    }
}

//Literal value ideas

//Array
int[][/*values*/]
int[4][/*values*/]
[string,int][13135, 'Hello World!']
int[,string][13135, 'Hello World!']

type MyType = [string,int,bool?] | [string,int,char?];
MyType myType = [string,int,char?]['Test',121,null];

//Method
void func()(){/*code*/}
void func(string,int)(myString, myInt){/*code*/}

//Set
int{}{/*values*/}
int{4}{/*values*/}

//Map
int string{}{}
{int myInt, string myString}{myInt:13135,myString,'Hello World!'}



//String
''
''''''
""
""""""

//Int
23123
123e231
0x2131
0o1232457
0b1010011

//Double
23123.1
123e231.4
0x2131.7
0o1232457.5
0b1010011.9

//Bool
true
false

//Char
'c'
"C"

//Void
null
//these voids will act different
[int,]//One void 
[,]//Two voids

//Future
async int
async int[]

Methods test

//code
void myMethod(){

}
void func() myMethod = (){}
myMethod();

//code
void myMethod[]{

}
void func[] myMethod = []{}
myMethod[];

//code
void myMethod{string myString}{

}
void func{myString string} myMethod = {string myString}{}
myMethod{myString: 'Hello World!'};

use the value keyword for the setters.

//chapter
Labels (label)

//text
The __label__ keyword is used to store variable names.

//code
label myLabel = labelValue;
// myLabel becomes: labelValue
myLabel = myLabel;
// myLabel becomes: labelValue

//text
The __$__ can be used to store the label from an existing variable.

//code
label myLabel = labelValue;
// myLabel becomes: labelValue
myLabel = $myLabel;
// myLabel becomes: myLabel

//title
Get values

//text
The __$__ operator can be used to get the value from a variable with the value of a label.
Note that type casting is required.

//code
string myString = 'Hello World!';
label myLabel = $myString;

string myLabelString = <string>myLabel$;
// myLabelString becomes: 'Hello World!'

//text
The memebers of and object can also be access.

//code
class MyClass
{
    string myString = 'Hello World!';
    int myInt = 13135;
}

MyClass myClass = MyClass();

label myLabel = myString;
string myString = <string>myClass.myLabel$;
// myString becomes: 'Hello World!'

myLabel = myInt;
int myInt = <int>myClass.myLabel$;
// myInt becomes: 13135

//title
Label class methods

//text
The label class method can be used to catch memeber accessing if the member does not exist in the class.

//code
class MyClass
{
    this label{
        if(value = $stringMember){
            return 'Hello World!';
        }
        else if(value = $intMember){
            return 13135;
        }
    }
}

MyClass myClass = MyClass();
string myString = <string>myClass.stringMember;
//myString becomes: 'Hello World!'
int myInt = <int>myClass.intMember;
// myInt becomes: 13135

//chapter
Key and value pairs (:)

//text
The __:__ operator can be used to create a key and value pair.
To create a key and value pair write any type followed by __:__ and ending with another type.
The key propery can by access by the key memeber.
The value can be access trough the value member or index or label method.

//code
string:string myKeyAndValuePair = 'Key':'Value';
string myKey = myKeyAndValuePair.key;
// myKey becomes: 'Key'
string myValue = myKeyAndValuePair.value;
// myValue becomes: 'Value'

//code
string:string myKeyAndValuePair = 'Key':'Value';
myValue string = myKeyAndValuePair['Key'];
// myValue becomes: 'Value'

//code
label:string myKeyAndValuePair = key:'Value';
myValue string = myKeyAndValuePair.key;
// myValue becomes: 'Value'

//title
Converting

//text
Variables can be converted to key and value pairs the key will be a name of the variable and the value will be the value of the variable.
Add a __:__ after an existing variable to convert it.

//code
string myString = 'Hello World!';
label:string myKeyAndValuePair = myString:;

//title
Unpacking

//code
int:string myKeyAndValuePair = 13135:'Hello World!';
int myInt:string myString = myKeyAndValuePair;
// myInt becomes: 13135
// myString becomes: 'Hello World!'

//text
Only unpacking one value

int:string myKeyAndValuePair = 13135:'Hello World!';
:string myString = myKeyAndValuePair;
// myString becomes: 'Hello World!'
int myInt: = myKeyAndValuePair;
// myInt becomes: 13135

//title
Collection
//Moet beter worden uitgezocht om ook op andere data types te zoeken

//text
When the key is a label you you can unpack the key and value pair if the name of the variable is equal to the label of the key.
When this type of unpacking is placed inside of collections the value will be searched.

//code
['key':string value, 'secondKey':string secondValue] = ['key':'Hello World!', 'secondKey':'Value'];

//text
When collection key and value pair unpacking and the key is a label the variable name does not have to be declared.
[key:string value,secondKey:string secondValue] = [secondKey:'Hello World!', key:'Value'];
[key:[int myInt,int mySecondInt],secondKey:string secondValue] = [secondKey:'Hello World!', key:[1,2]];
//These are the same

key:int[] asdf
//title

void myMethod(int myInt,int mySecondInt){

}

int() mySet = (1,6);
mySet[0];
myMethod(...mySet);


this [int start:int end:int step]{
    
}

int[] myArray = [1,2,3,4,5];
int[] mySecondArray = myArray[0:5:-1]
[1,2]

Sets ({})

//text
When key and value pairs are added to sets the keys must be unique.

//code
label:string{} mySet = {key:'Value',secondKey:'Second value'};

//code
label:string{} mySet = {key:'Value',key:'Second value'};
//Results in error

key and value pairs have a special propery when added to sets.
A key and value pair is different in sets when the key is difference form the other keys not the key or value.

The new keyword label can be used in these casses to add extra functinallity.
And when the label is the type of the key in a key and value pair the value can be access trough the label value or via indexing with string
label:string myKeyAndValuePair = myString:'Hello World!';
string myString = myKeyAndValuePair.myString;
myString = myKeyAndValuePair['myString'];
myString = myKeyAndValuePair[myString];

When a key and value pair is added to sets and the key is of type label the value can be access by calling the label.
The reason why this functinallity can only be applied to sets is because key only in sets the key is always unique while in any other collection it is not.
Values of key and value pairs in sets can always be access like accessing a value form a key and value pair.

label:string mySet = {myString:'Hello World!'};
string myString = mySet.myString;
myString['']

//chapter
Collections

//title
Sized

string:int{} obj

//text
Any collection can be used to create small objects with pre defined types and size.

//code
[int,string] myArray = [13135, 'Hello World!'];
(int,string) myTyple = (13135, 'Hello World!');
{int,string} mySet = {13135, 'Hello World!'};
{label:int,label:string} myMap = {myInt: 13135,myString: 'Hello World!'};

//title
Labels

//text
Labels can be added to any collection type.
Labels do not add any functinallity to the the collection object they serve the perpose to indicate what the value means.

//code
[int myInt,string myString] myArray = [13135, 'Hello World!'];
(int myInt,string myString) myTyple = (13135, 'Hello World!');
{int myInt,string myString} mySet = {13135, 'Hello World!'};
{label:int myInt,label:string myString} myMap = {myInt: 13135,myString: 'Hello World!'};


//

//default value
int[] myArray
int() myTuple  
int{} mySet
label int{} myMap  





//chapter
Cascading scope

//text
The __{}__ brackets can be used to add cascading scope to any value.
To add cascading scope write __{}__ after any value.
Inside the __{}__ of the cascading scope the memebers of the value can accessed.
The __.__ operator is not needed to accessed the members of an object.

//code
class MyClass
{
    public int? myInt;
    public string? myString;

    public void myMethod(){
        // You method code.
    }
}

MyClass myClass = MyClass(){
    myInt = 13135;
    myString = 'Hello World!';
    myMethod();
};

myClass.myInt = 13135;
myClass.myString = 'Hello World!';
myClass.myMethod();

//text
The cascading scope can also be added to functions to call them multiple times.

//code
List<int> myList = List<int>();

myList.add{
    (1);
    (3);
    (1);
    (3);
}

//subtitle
Continuing

//text
After the cascading scope the expression can be continued.

//code
class MyClass
{
    public int? myInt;
    public string? myString;

    public void myMethod(){
        // You method code.
    }
}

string myString = MyClass(){
    myInt = 13135;
    myString = 'Hello World!';
    myMethod();
}.myString;
// myString becomes: 'Hello World!'

//subtitle
Variable declaration

//text
The cascading scope can be added to any type or keyword that is used to declare variables or functions.
The type or keywords will be added to the statement inside the cascading scope.
//I don't exacly know how this will work (Wich keywords can or can not be used. and can they be combined?).


int(,string,) myTuple = (1,'',2);
int(5) mysecondtuple = (1,1,1,1,1);
(int 2,bool 2,string 3);
[int 2,bool 2,string 3]
{int 2,bool 2,string 3}
int[][][]{}()
int[] asdf = Arrays.listas(2,2,2);
int[] array = auto[1,2,3,6];
MySuperLongClassName[] myArray = [auto(1),auto(5),auto(127)];


void myMethod(double myNamedDouble, double mySecondDouble, (search string myString as mynamedString)){
}

void myMethod(double myNamedDouble, double mySecondDouble map string myString as mynamedString){

}

void myMethod(search string myString){

}

void myMethod(myInt:int, double myDouble, myString:string myNamedString){

}
myMethod(myInt: 53,myString: 'Hello World!',4.54);

//code
class MyClass
{
    public{
        string? myString;
        bool? myBoolean;

        int{
            myInt = 13135;
            mySecondInt = 53131;

            | string dwdw = '';

            ? dwdw = null;
          
            myMethod(){
                // You method code
            }
        }
    }
}

//subtitle
Nested

//text
Cascading scopes can be defined on any value this includes values in cascading scopes.
This unlocks the possibility to have nested cascading scopes.

//code
class MyClass
{
    public int? myInt;
    public string? myString;
    List<int> myList = List<int>();

    void myMethod(){
        // You method code.
    }
}

MyClass myClass = MyClass(){
    myInt = 13135;
    myString = 'Hello World!';
    myList.add{
        (1);
        (3);
        (1);
        (3);
    }
    myMethod();
};

//title
Asynchronous

//chapter
Asynchronous functions (async)

//text
The __async__ keyword can be used to make asynchronous functions.
These are methods with a promise as return value.
When the promise is resolved, it is returned and the attached code is run.
Note that the error object is always a enum.

//code
async string myMethod(){
	return "Hello World!";
}
myMethod()
.then( function(myReturnValue){ print(myReturnValue); } )
.catch( function(myError){ print("Error: " + myError.message); } );

//chapter
Promise (promise)

//text
The __promise__ keyword can be used in any function to create a promise.

//code
string myMethod(){
	return promise.resolve("Hello World!");
}

//chapter
Await (await)

//text
The __await__ keyword can be used to pause code when resolving a promise before continuing other code.
The __await__ keyword can only be used in a asynchronous function.

//code
async string myMethod(){
	return "Hello World!";
}
string myString = await myMethod().catch( function(myError){ print("Error: " + myError.message); } );


