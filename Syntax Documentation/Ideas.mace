// Datatypes
Int
Float
String
Bool
Char
//optional
percent

//operators
*
-
+
/
^
^.5
!
%

//boolean operators
==
!=
>
>=
<
<=
&

&&
||
!()

//matrix math start with #

//With this syntax you can have multiple checks on one value
(10 > 5 &> 6)
('Test'.length > 5 &<= 10)

//Array
string[] myArray = [];

//Last item
myArray[-1]

//If else structure
if (){
}
else if (){
}
else{
}

for(Int j = 0; i<5; i++)

for(Int integer in intlist){
	
}


//Normal function (void is no return type)
Int Calc(){
	return 6;
}

//Flexible return type function
<Int asdf,String myString> Test<T>(string myString)
{
	//Edit return values using the return. notation
	return.myString = myString;
	return;
}

//funtion invokation of multiple return type method
//use predefined values or define when function used
Int var1;
<var1,String var2> = Test('dadwad');
Int result = Calc();

//Build in functions
puke();
inhale();
void firstBreath(){
}

//Read file

//Graphics

//const with if

TODO - warning
System.
system math
10e10 1_000

//title
Percentage (percent)

//text
miss meer een system function / math function?
bedoel je dit?:
https://www.best-microcontroller-projects.com/arduino-map.html
of dit?:

//text
A __percentage__ is a primitive that can store a floating point number between 0 and 100.
If a fraction is given as value to the this primitive, __percentage__ will convert it to the corresponding percentage.

//code
percent myPercent = 40%;
myPercent = 71.428571428;

----------------------- null checks and pointers

Int? myInt;
Int? mySecondInt;
Int*?[] myThirdInt;

denullify /
unnullify ({myInt:5},{mySecondInt:5}){
    Int mySecondInt = myInt;
}


Double[5] balance = [1000.0, 2.0, 3.4, 17.0, 50.0];
Double[5] balance2 = balance;

Double *p;
Double[]

deep copy
shallow copy
reference
pointer


cpp
A pointer in C++ is a variable that holds the memory address of another variable.
A reference is an alias for an already existing variable. Once a reference is initialized to a variable, it cannot be changed to refer to another variable.


negate signed byte
-------------
signed
0b00000110 = 6
flip all numbers
0b11111001
add binary one
0b11111010
msb staat aan dus is -128
-128 + 64 + 32 + 16 + 8 + 0 + 2 + 0 = -6
----------- twos compliment method

~myInt + 1 == -myInt



-not

---

0b10000110 >> 1
-128 + 6 = -122

0b11111001
-128 + 64 + 32 + 16 + 8 + 0 + 0 + 1 = -7

signed:
0b10000001
-128 + 1 = -127
pas toe: << 1
0b10000010 = -128 + 2 = -126
pas toe: <<< 1
0b00000010 = 2




Int i,j
j = 1
if ((Bool)(i & 1)){
    
}

34 @>>> 3;
i @>>>= 1;
savedBits = 34 & 0000000000000111;
0011 & 000000000000000001
modulus 2
savedBits <<<= 16 - 3;
newValue = 34 >>> 3;
newValue |= savedBits;

underscores, the operator structure, operand

range
meerdere datatypes


type JsonValue = Int | String | Bool;
Int[] default: -1 myArray = [1,2,3];
Int myValue = myArray[1];

Map<String,JsonValue>
Map<String, Object>
String value = object
//warning typecast is not certain
Int Func() | Int test = (){}

reference
ref
flag / tag

void print(...dynamic[] values){

}
print('',43,'');



//startnotes
MyGeneric<MyGeneric>(MyGeneric myGeneric) myMethodVar = myMethod<MyGeneric>;
type MyType = MyGeneric<MyGeneric>(MyGeneric myGeneric);
MyType myType = MyGeneric<MyGeneric>(MyGeneric myGeneric)
Mytype<String> myMethod = myMethod<String>;
string(String stuff) myMethodVar = myMethod<String>;

type myMethod<T> = myMethod<T>;

type MyType<MyGeneric> = MyGeneric<MyGeneric>(MyGeneric myGeneric);
MyType myType = myMethod<int>;

class Map<T,S>
{

}

Map<String,Int> myMap = {};
type MyType = Map<String,Int>;
type MyType<T,S> = Map<T,S>;
MyType myType<String, Int> = {'Index': 5};
//endnotes


int*?[]?*?<T>()?*? myArray = &[null,&3,null]


--------------generics with methods:


enum MyEnum myEnum = {};  
class MyClass<T,S> myClass = { String myString;};
MyClass<String,Int> myClassInstance = MyClass<T,S>();
if(){
    myClass = {Int myInt;};
}
else{
    myClass = {Double myInt;};
}

typeid(clasquestionmark).name();
// "class"

class MyClass = <T,S>(){};

save method as value in variable

// int i = 0;
---
void myMethod<T>(T test){
    return test;
}
function void<T>(T test) myMethod = {return test;};

void display<S>(Int dimensions){
    Double Func<T>(int i) display = {T?[i] data = T?[i]; for(T value in data with int index){print(index + '\n');}};
    for (j = 0; j< 5; j++){
        display<S>(j);
        if (j>2){
            display = {T[i][i] data; for(T row in data){for(T value in data with int index){print(index);}print('\n');}};
        }
    }
}
---

Double Func(Int i) recursion = {return i % 2;};
for (j = 0; j< 500; j++){
    recursion(j);
    if (j>200){
        recursion = {return 1 - (i % 2);};
    }
}
recursion();
recursion = {if (i == 5){j=1;} i++;};


Double Func<Int | Double T, Int | Double S>(T firstValue, S secondValue) addOrMultiply = {return (Double)(firstValue + secondValue)};
addOrMultiply = {return (Double)(firstValue * secondValue)};

String Func(string,int) myMethod = (String myString,Int myInt){};


Int i = 0;
Void Func<T,S>() inceremeter = {i++;};
myMethod = {i++;};


myMethod = 
String Func<String,Int>() mySecondMethod = myBoolean ? myMethod : mySecondMethod;


matrix operator

//title
Matrix arithmetic

//text
The following table shows all possible operations that can be applied on matrices or vertices.

//tablehead
Operator`   Name`                           Example`                  Same as

//table
#+`         Matrix addition`                myArray = a #+ b;`                          myArray = [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
#-`         Matrix subtraction`             myArray = a #- b;`                          myArray = [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
#*`         Matrix scalar multiplication`   myArray = a #* myScalar;`                   myArray = [a[0]*myScalar, a[1]*myScalar, a[2]*myScalar];
#/`         Matrix scalar division`         myArray = a #/ myScalar;`                   myArray = [a[0]/myScalar, a[1]/myScalar, a[2]/myScalar];
#**`        Matrix dot product`             myArray = c #** a; or myArray = a #** b;`   myArray = [[c[0]*a[0], c[0]*a[1], c[0]*a[2]],[c[1]*a[0], c[1]*a[1], c[1]*a[2]],[c[2]*a[0], c[2]*a[1], c[2]*a[2]]]; or myArray = [a[0]*b[0]+a[1]*b[1]+a[2]*b[2]];
##`         Matrix cross product`           myArray = a ## b;`                          myArray = [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
#-`         Matrix negation`                myArray = #-a;`                             myArray = [a[0]*-1, a[1]*-1, a[2]*-1];
#^`         Matrix norm`                    myInt = #^a;`                               myInt = sqrt(a[0]**2 + a[1]**2 + a[2]**2);
#%`         Matrix unit`                    myArray = #%a;`                             myArray = a #/ #^a;

//subtitle
Matrix addition (#+)

//text
The __#+__ operator is used when two matrices need to be added to each other.
Every number on a position of the first matrix will be added to the number on the same position of the second matrix.
Note that the size of the two does not matter, but they do need to be the same, both must have the same amount of rows and the same amount of columns.

//code
myArray = a #+ b;
myArray = [0+3,1+4,2+5];
myArray = [3,5,7];

//subtitle
Matrix subtraction (#-)

//text
The __#-__ operator is used when one matrix needs to be subtracted from another.
Every number on a position of the first matrix will be added to the number on the same position of the second matrix.
Note that the size of the two does not matter, but they do need to be the same, both must have the same amount of rows and the same amount of columns.

//code
myArray = a #- b;
myArray = [0-3,1-4,2-5];
myArray = [-3,-3,-3];

//subtitle
Matrix scalar multiplication (#*)

//text
The __#*__ operator is used when a matrix needs to be multiplied with a scalar.
Every number on a position of the matrix will be multiplied with a number.
Note that the size of the matrix does not matter.

//code
myArray = a #* myScalar;
myArray = [0*6,1*6,2*9];
myArray = [0,9,18];

//subtitle
Matrix scalar division (#/)

//text
The __#/__ operator is used when a matrix needs to be divided by a scalar.
Every number on a position of the matrix will be divided with a number.
Note that the size of the matrix does not matter.

//code
myArray = a #/ myScalar;
myArray = [0/9,1/9,2/9];
myArray = [0,0,0];

//subtitle
Matrix dot product (#**)

//text
The __#**__ operator is used when two matrices need to be multiplied with each other.
The resulting matrix will have the number of rows of the first matrix and the number of columns of the second matrix.
Every position of the resulting matrix will be the sum of 
each element of the corresponding row in the first matrix multiplied with each element of the corresponding column in the second matrix.
Note that the size of the two does not matter, but the number of columns of the first matrix need to be the same as the number of rows in the second matrix.

//code
myArray = c #** a;
myArray = [[6*0, 6*1, 6*2],[7*0, 7*1, 7*2],[8*0, 8*1, 8*2]];
myArray = [[0, 6, 12],[0, 7, 14],[0, 8, 16]];

//subtitle
Matrix cross product (##)

//text
The __##__ operator is used when the cross product of two matrices needs to be found.
Note that this operator can only be used on two matrices that both have 3 rows and 1 column.

//code
myArray = a ## b;
myArray = [1*5-2*4, 2*3-0*5, 0*4-1*3];
myArray = [5-8, 6-0, 0-3];
myArray = [-3, 6, -3];

//subtitle
Matrix negation (#-)

//text
The __#-__ operator is also used when the negated matrix needs to be found.
Every number in the matrix will be multiplied with -1.

//code
myArray = #-a;
myArray = [0*-1, 1*-1, 2*-1];
myArray = [0, -1, -2];

//subtitle
Matrix norm (#^)

//text
The __#^__ operator is used when the length of a matrix needs to be found.
The resulting number will be the square root of the sum of every number in the column squared.
Note that this operator can only be used on a matrix that has only 1 column.

//code
myInt = #^a;
myInt = sqrt(0**2 + 1**2 + 2**2);
myInt = sqrt(0 + 1 + 4);
myInt = sqrt(5);
myInt = 2;

//subtitle
Matrix unit (#%)

//text
The __#^__ operator is used when the matrix with the same direction but with a length of 1 needs to be found.
The resulting matrix will be the same matrix but every number will be divided by the length of the original matrix.
Note that this operator can only be used on a matrix that has only 1 column.

//code
myArray = #%a;
myArray = a #/ #^a;
myArray = [0/sqrt(0**2 + 1**2 + 2**2),1/sqrt(0**2 + 1**2 + 2**2),2/sqrt(0**2 + 1**2 + 2**2)];
myArray = [0/sqrt(5), 1/sqrt(5), 2/sqrt(5)];
myArray = [0,0,0];




//labeld for loop for continue and break statements

myLoop for(int i = 0; i < 10 i++,){
    mySecondLoop for(int i = 0; i < 10 i++,){
        break myLoop;
        break mySecondLoop;
    }
}

this [Int start:Int end:Int step]{
    
}

Int[] myArray = [1,2,3,4,5];
Int[] mySecondArray = myArray[0:5:-1]
// mySecondArray becomes: [1,2]

Sets ({})

//text
When key value pairs are added to sets the keys must be unique.

//code
Label:String{} mySet = {key:'Value',secondKey:'Second value'};

//code
Label:String{} mySet = {key:'Value',key:'Second value'};
//Results in error

key and value pairs have a special propery when added to sets.
A key and value pair is different in sets when the key is difference form the other keys not the key or value.

And when the label is the type of the key in a key and value pair the value can be access trough the label value or via indexing with string
Label:String myKeyValuePair = myString:'Hello World!';
String myString = myKeyValuePair.myString;
myString = myKeyValuePair['myString'];
myString = myKeyValuePair[myString];

When a key and value pair is added to sets and the key is of type label the value can be access by calling the label.
The reason why this functinallity can only be applied to sets is because key only in sets the key is always unique while in any other collections it is not.
Values of key and value pairs in sets can always be access like accessing a value form a key and value pair.

Label:String mySet = {myString:'Hello World!'};
String myString = mySet.myString;
myString['']

MyClass myClass = auto();
myClass[];

String myString = '23';
Int mySecondInt = <!int>myString;

!Int myInt;
Int myInt = Int!;


(String myString:, :Int iest)  = ('dwdw':true)
(String myString, , Int myInt) = ('',true,2121);

String myString:String dwwdw = myString:'dwdwd';
// dwwdw becomes: 'dwdwd';
Int:?String var = null;
Int?:?String? var = null;
null:'dwdwd'
// dwwdw becomes: 'dwdwd';
myString:?String dwwdw = myString:'dwdwd';
// dwwdw becomes: myString:'dwdwd'

Int: myKeyValuePair String = 23:'';
Int:String myKeyValuePair = 23:'';
Int : String myValue = 23:'';
Int::String{} sfesfe = 23:"";
//instanciate / define
(Int?:String) wdwd = :'test';
232:null;
//unpack
(myString:?String dwwdw) = myString:'dwdwd';

(Int? myInt,String? myString)? = null;
cant get stuff from null


void myMethod(){

}

myMethod;

Int?:?String? test = null:null | null;

void myMethod(myInt:?Int myInt, mySecondInt, String myString, myBoolean:Bool myBoolean){
    // Your method code
}

void myMethod(myInt:Int|Int myInt, String myString, myBoolean:Bool myBoolean){
    // Your method code
}

void myMethod(!{String myString}){
    // Your method code
}

String myString = 'Hello Wo';
String[5 Hello,Char 1, 6 World,...] = myString;

[Int 5,Int 1,Int 6] myArray = [1,2,3,4,5,0,1,2,3,4,5,6];
[Int[] 5 first,Int 1,Int[] 6 second] = myArray;

~ ! @ # $ % * - + \ <> . /
` ^ & ( ) _ = { } [ ] | "" '' , ? \ ;


String myString!;
String? myString = null;
String mySecondString = myString!;

(Int | String)() myTuple = (1212,'Hello World!',12);
Int | String(myInt,myString,...) = myTuple;
(Int myInt,String myString,...) = myTuple;

//text
Other class assignment.

class MyClass
{
    String myString;
    Int myInt;
}

MyClass myClass = MyClass{myString = 'Hello World!',myInt = 13135};
MyClass myClass = auto{myString = 'Hello World!',myInt = 13135};
MyClass myClass = {myString = 'Hello World!',myInt = 13135};
MyClass myClass = {'Hello World!',13135};

//text
Return as variable

String myMethod(){
    return = 'Hello World!';
    print(return);
    return;
}

String myString = myMethod();
// myString becomes: 'Hello World!'

(String! myString,Int! myInt)! myMethod(){
    return.myString = 'Hello World!';
    return.myInt = 13135;
}

//Literal value ideas

//Array
Int[][/*values*/]
Int[4][/*values*/]
[String,Int][13135, 'Hello World!']
Int[,String][13135, 'Hello World!']

type MyType = [String,Int,Bool?] | [String,Int,Char?];
MyType myType = [String,Int,Char?]['Test',121,null];

//Method
Void Func()(){/*code*/}
Void Func(String,Int)(myString, myInt){/*code*/}

//Set
Int{}{/*values*/}
Int{4}{/*values*/}

//Map Set
(Int:String){}{}
{Int myInt, String myString}{myInt:13135,myString,'Hello World!'}

//String
''
''''''
""
""""""

//Int
23123
123e231
0x2131
0o1232457
0b1010011

//Double
23123.1
123e231.4
0x2131.7
0o1232457.5
0b1010011.9

//Bool
true
false

//Char
'c'
"C"

//Void
null
//these voids will act different
[Int,]//One void 
[,]//Two voids

//Future
async Int
async Int[]

Methods test

//code
Void myMethod(){

}
Void Func() myMethod = (){}
myMethod();

//code
Void myMethod[]{

}
Void Func[] myMethod = []{}
myMethod[];

//code
Void myMethod{String myString}{

}
Void Func{myString String} myMethod = {String myString}{}
myMethod{myString: 'Hello World!'};

use the value keyword for the setters.

//title
Bullet expression

//text
Bullet expressions can be used to define short logic inside another expression.
Bullet expressions are only evaluated when the given boolean is true.
The following operators can be used with bullet expressions to define short logic.

//tablehead
Operator`   bullet expression operator(s)

//table
=`          <?                                              
+=`         <? 
-=`         <? 
*=`         <? 
/=`         <? 
**=`        <? 
%=`         <?
&=`         <? 
|=`         <? 
^=`         <?
>>=`        <?
<<=`        <?
>>>=`       <? 
<<<=`       <?
@>>>=`      <? 
@<<<=`      <?
+`          <? or >? 
-`          <? or >? 
*`          <? or >? 
/`          <? or >? 
**`         <? or >? 
%`          <? or >? 
|`          <? or >? 
^`          <? or >? 
>>`         <? or >?
<<`         <? or >? 
>>>`        <? or >?
<<<`        <? or >? 
@>>>`       <? or >?  
@<<<`       <? or >? 
,`          <? or >? 

//subtitle
Left bullet expression (<?)

//text
The __<?__  operator is used to define a bullet expression with the operator on the left hand side.
To use a left bullet expression write a valid operator followed by a boolean expression and the bullet operator and ending with a literal value or variable.

When the boolean expression is evaluated to true the value will be included in the expression.
When the boolean expression is evaluated to false the operand and the operator before the boolean expression will be ignored.

//code
Int? myInt = myBoolean <? 7;
// myInt becomes: 7 when myBoolean is true
// myInt becomes: null when myBoolean is false

myInt = 5 + myBoolean <? 7;
// myInt becomes: 12 when myBoolean is true
// myInt becomes: 5 when myBoolean is false

myString = myBoolean <? 'Hello World!';
// myString becomes: "Hello World!" when myBoolean is true
// myString keeps the current value when myBoolean is false

//text
The __<?__ operator can also be used on a __,__ to optionaly add values to collections.

Int[] myArray = [1,2,myBoolean <? 3]
// myArray becomes: [1,2,3] when myBoolean is true
// myArray becomes: [1,2] when myBoolean is false

@>>>`       Bitwise unsigned right shift loop         
@<<<`       Bitwise unsigned left shift loop

//subtitle
Right bullet expression (>?)

//text
The __>?__  operator is used to define a bullet expression with the operator on the right hand side.
To use a right bullet expression write a boolean expression and the bullet operator followed by a literal value or variable and ending with a valid operator.

When the boolean expression is evaluated to true the value will be included in the expression.
When the boolean expression is evaluated to false the operand and the operator after operand will be ignored.

//code
Int myInt = myBoolean >? 7 + 5;
// myInt becomes: 12 when myBoolean is true
// myInt becomes: 5 when myBoolean is false

myString = myBoolean >? 'Hello ' + 'World!';
// myString becomes: "Hello World!" when myBoolean is true
// myString becomes: "World!" when myBoolean is false

//text
The __>?__ operator can also be used on a __,__ to optionaly add values to collections.

Int[] myArray = [myBoolean >? 1,2,3]
// myArray becomes: [1,2,3] when myBoolean is true
// myArray becomes: [2,3] when myBoolean is false

//subtitle
Bitwise unsigned right shift loop (@>>>)

//text
The __@>>>__ operator is used to loop every bit in a bit sequence a given amount of places to the right.
The most right bits will be moved to the left.
Note that the MSB will be moved.

//code
Int myInt = 0b00000000000000000000000000001100 @>>> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 @>>> 2;
// myInt becomes: 3

myInt = 0b11111111111111111111111111110100 @>>> 1;
// myInt becomes: 0b1011111111111111111111111111010 which is 1610612730

myInt = -12 @>>> 2;
// myInt becomes: 1342177277

//text
The __@>>>__ operator can also be used to loop every character or item in a __String__, array or list a given amount of places to the right.
The most right items or characters will be moved to the left.

//code
String myString = '12345' @>>> 1;
// myString becomes: '51234'

Int[] myArray = [1,2,3,4,5] @>>> 1;
// myArray becomes: [5,1,2,3,4]

List<Int> myList = [1,2,3,4,5] @>>> 1;
// myList becomes: [5,1,2,3,4]

//subtitle
Bitwise unsigned left shift (@<<<)

//text
The __@<<<__ operator is used to loop every bit in a bit sequence a given amount of places to the left.
The most left bits will be moved to the right.

//code
Int myInt = 0b00000000000000000000000000001100 @<<< 1;
// myInt becomes: 0b00000000000000000000000000011000 which is 24

myInt = 12 @<<< 2;
// myInt becomes: 48

myInt = 0b11111111111111111111111111110100 @<<< 1;
// myInt becomes: 0b11111111111111111111111111101001 which is -23

myInt = -12 @<<< 2;
// myInt becomes: -45

The __@<<<__ operator can also be used to loop every character or item in a __String__, array or list a given amount of places to the left.
The most left items or characters will be moved to the right.

//code
String myString = '12345' @<<< 1;
// myString becomes: '23451'

Int[] myArray = [1,2,3,4,5] @<<< 1;
// myArray becomes: [2,3,4,5,1]

List<Int> myList = [1,2,3,4,5] @<<< 1;
// myList becomes: [2,3,4,5,1]


abstract with defualt value does not need implementation.
The variable or method can be used directly without the implementation.


//EXPERIMENT with iterators, streams and futures
//Sync
String myMethod(){
    if(myBoolean){
        return 'Hello World!';
    }
    else{
        return 'Else';
    }
}
String myString = myMethod();

//Shorthand
String myString = if(myBoolean){
    return 'Hello World!';
}
else{
    return 'Else';
}

//Async
async Future<String> myFuture(){
    if(myBoolean){
        await // Code that takes a while
        return await // Future string
    }
    else{
        await // Code that takes a while
        return await // Future string
    }
}
Future<String> myFuture = myFuture();

//Shorthand
Future<String> myFuture = async if(myBoolean){
    await // Code that takes a while
    return await // Future string
}
else{
    await // Code that takes a while
    return await // Future string
}

//Use the stash keyword to return an Iterator or a (Steam when the async keyword is used)
//If the yield statement is used or comma seperated values are returned witout using the stash keyword the values will be retuned with comma's seperated and can only be placed in collection types like arrays, tuples and sets.
//When the return keyword is used in an iterator or stream instead of the yield keword the fucking will stop execution after returing this value.
//When the yield keyword is used the methods returns the value and continues execution.

//USING STASH

//Iterator
stash Iterator<Int> myIterator(){
    for(i in 1..10)
        yield i;
}
Iterator<Int> myIterator = myIterator();

//Shorthand
Iterator<Int> myIterator = stash for(i in 1..10) i;

//Stream
async stash Stream<Int> myStream(){
    for(i in 1..10){
        await // Code that takes a while
        yield await i;
    }
}
Stream<Int> myStream = myStream();

//Shorthand
Stream<Int> myStream = async stash for(i in 1..10){
      await // Code that takes a while
      yield await i;
};

//WITHOUT USING STASH

//Iterator
stash Iterator<Int> myMethod(){
    for(i in 1..10)
        yield i;
}
Int[] myArray = [...myMethod()];

//Shorthand
Int[] myArray = [for(i in 1..10) i];

//Stream
async Int myMethod(){
    for(i in 1..10){
        await // Code that takes a while
        yield await i;
    }
}
Int[] myArray = [await myMethod()];

//Shorthand
Int[] myArray = [async for(i in 1..10){
      await // Code that takes a while
      yield await i;
}];

//chapter
Scope labels

//text
The __<>__ brackets can be used to add a label to any scope.
To add a label to any scope write __<__ followed by a label name and ending with __>__.
The label can be used to acces the scope its variables this can be usefull to keep the code readable and claer.
Scope labels can be added to the following scopes:

//table
If statement
Else statement
Else if statement
Switch statement
Case statement
For loop
Function
Array type and value
Tuple type and value
Set type and value
Cascading scope

//code
<myIfScope>
if(myBoolean){
    Int x = 131;
    Int y = 35;
    if(mySecondBoolean){
        Int x = myIfScope.x;
        Int y = myIfScope.y;
    }
}

//text
The label can also be used to access statements or default values/code from cascading scope.
To access these members two dots must be used instead of a singular one.

//code
<myIfScope>
if(myBoolean){
    // The value of the the expression given in the if statement.
    print(myIfScope..result);
    // Reruns the expression in tgiven in the if statement
    print(myIfScope..check());
}
<myElseIfScope>
else if(mySecondBoolean){
}
<myElseScope>
else{
}

//code
<mySwitchScope>
switch(myString){
    <myCaseScope>
    on('Hello World!'){
        switch(myInt){
            on(13135){
                print(myCaseScope..checks);
                print(mySwitchScope..value);
                mySwitchScope..break;
            }
        }
    }
}

//code
<myForScope>
for(Int i in array){
    for(Int i in array){
        print(myForScope.i);
        print(myForScope..iterable);
        if(myBoolean){
            myForScope..break;
        }
        else{
            myForScope..continue;
        }
    }
}

//code
<myMethodScope>
Void myMethod(){
    Void mySecondMethod(){
        myMethodScope..return;
    }
}

//code
<myArrayTypeScope> Int[myArrayTypeScope | String] = <myArrayValueScope> 13135[myArrayValueScope * 53131];

//code
<myTupleTypeScope> Int(myTupleTypeScope | String) = <myTupleValueScope> 13135(myTupleValueScope * 53131);

//code
<mySetTypeScope> Int{mySetTypeScope | String} = <mySetValueScope> 13135{mySetValueScope * 53131};

//code
<myCascadingScope>
myObject.myNestedObject{
    myNestedNestedObject{
        myCascadingScope..myString = 'Hello World!';
        myCascadingScope..myInt = 13135;
    }
}

//subtitle
Default value

//text
The __default__ keyword can be used to retrive the default value of the type when the typ casting was not successfull.

//code
String myString = 'Hello World!';
Int myInt = <default Int>myString;
// myInt becomes: 0


//text
The __as__ keyword can be used to bind new class to a class extension.
This can be achieved by writing __as__ after the extension type followed by a class definition without the class keyword.
When creating an instance of the binded class it will not contain the members from the extended class.

//code
class MyClass
{
    Int myInt = 13135;
    String myString = 'Hello World!';
}

extend MyClass as MySecondClass
{
    Void myMethod(){
        print(myInt);
    }
}

// Accessing the extended method myMethod from the original class
MyClass myClass = MyClass();
myClass.myMethod();

// Accessing the method myMethod from the binded class MySecondClass
MySecondClass mySecondClass = MySecondClass();
mySecondClass.myMethod();

//chapter
Cascading scope

//text
The __{}__ brackets can be used to add cascading scope to any value or variable.
To add cascading scope write __{}__ after any value or variable.
Inside the __{}__ brackets of the cascading scope the __.__ represents the value or variable.
Members of these vales or variables van be directly accessed without an extra __.__ operator.
//Maybe make the __.__ operator optional and replace it the the keyword base for more clearity

//code
class MyClass
{
    public Int? myInt;
    public String? myString;

    public Void myMethod(){
        // Your method code.
    }
}

MyClass myClass = MyClass();

// Without cascading scope.
myClass.myInt = 13135;
myClass.myString = 'Hello World!';
myClass.myMethod();

// With cascading scope
myClass{
    .myInt = 13135;
    .myString = 'Hello World!';
    .myMethod();
};

//title
Functions

//text
The cascading scope can also be added to functions, to call them multiple times.

//code
Int[] myArray = [];

// Without cascading scope.
myArray.add(1);
myArray.add(3);
myArray.add(1);
myArray.add(3);

// With cascading scope
myArray.add{
    .(1);
    .(3);
    .(1);
    .(3);
}

//title
Scope definition

//text
Inside the cascading scope any other code statements can be defined.

//code
Int[] myArray = [];

myArray{
    Bool myBoolean = true;

    if(myBoolean){
        .add(13135);
    }else{
        .add(53131);
    }
}

//title
Optional chaining

//text
When dealing with a nullable variable the __?__ optional chaining operator must be added before the cascading scope.

//code
Int[]? myArray = [];

myArray?{
    .add(13135);
    .add(53131);
};

//title
Assignment

//text
Becuase the __.__ represents a variable that contains the value or variable values can be assigned to them.

//code
String myString = '';

myString{
    if(myBoolean){
       . = 'Hello World!';
    }else{
       . = 'World Hello!';
    }
}

//subtitle
Return value

//text
After the cascading scope the expression can be continued.

//code
class MyClass
{
    public Int? myInt;
    public String? myString;

    public Void myMethod(){
        // Your method code.
    }
}

String myString = MyClass(){
    .myInt = 13135;
    .myString = 'Hello World!';
    .myMethod();
}.myString;
// myString becomes: 'Hello World!'

//subtitle
Variable declaration

//text
The cascading scope can be added to any type or keyword that is used to declare variables or functions.
The type or keywords will be added to the statement inside the cascading scope.
//I don't exacly know how this will work (Wich keywords can or can not be used. and can they be combined?).

//code
class MyClass
{
    public{
        String? myString;
        Bool? myBoolean;

        Int{
            myInt = 13135;
            mySecondInt = 53131;

            . | String dwdw = '';

            .? dwdw = null;
          
            myMethod(){
                // You method code
            }
        }
    }
}

//subtitle
Nested

//text
Cascading scopes can be defined on any value this includes values in cascading scopes.
This unlocks the possibility to have nested cascading scopes.

//code
class MyClass
{
    public Int? myInt;
    public String? myString;
    public Int[] myArray = [];

    Void myMethod(){
        // Your method code.
    }
}

MyClass myClass = MyClass(){
    .myInt = 13135;
    .myString = 'Hello World!';
    .myArray.add{
        .(1);
        .(3);
        .(1);
        .(3);
    }
    .myMethod();
};

class MyClass
{
    public Int{
        max;
        min;
        base[] myArray;
        base | String myIntString;
        
        //Wil throw error
        String myString;
    }

    const Int{
        min = 0;
        max = 13135;
    }
    
    String{
        myMethod(){
            // Your method code.
        }

        mySecondMethod(){
            // Your method code.
        }
    }
}

myObject{
    .myString;
    .myInt;
}

myObject{
    if(myBoolean){
        . = myObject();
    }
    else{
        . = myObject('');
    }
}

String myString = myObject{
    String test = .myObject.myString;
    test.replace('1','2');
    return test;
};