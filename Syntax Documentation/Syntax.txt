// Datatypes
int
float
string
bool
char
//optional
percent

//operators
*
-
+
/
^
^.5
!
%

//boolean operators
==
!=
>
>=
<
<=
&

&&
||
!()

//matrix math start with #

//With this syntax you can have multiple checks on one value
(10 > 5 &> 6)
('Test'.length > 5 &<= 10)

//Array
string[] myArray = [];

//Last item
myArray[-1]

//If else structure
if (){
}
else if (){
}
else{
}

switch(var)
{
	case 'test'{
		break;
	}
	default{
		break;
	}
}



for(int j = 0; i<5; i++)

for(int integer in intlist){
	
}


//Normal function (void is no return type)
int Calc(){
	return 6;
}

//Flexible return type function
<int asdf,string myString> Test<T>(string myString)
{
	//Edit return values using the return. notation
	return.myString = myString;
	return;
}

//funtion invokation of multiple return type method
//use predefined values or define when function used
int var1;
<var1,string var2> = Test('dadwad');
int result = Calc();

//Build in functions
puke();
inhale();
void firstBreath(){
}

//Read file

//Graphics

//const with if

TODO - warning
System.
system math
10e10 1_000

//title
Percentage (percent)

//text
miss meer een system function / math function?
bedoel je dit?:
https://www.best-microcontroller-projects.com/arduino-map.html
of dit?:

//text
A __percentage__ is a primitive that can store a floating point number between 0 and 100.
If a fraction is given as value to the this primitive, __percentage__ will convert it to the corresponding percentage.

//code
percent myPercent = 40%;
myPercent = 71.428571428;

----------------------- null checks and pointers

int? myInt;
int? mySecondInt;
int*?[] myThirdInt;

denullify /
unnullify ({myInt:5},{mySecondInt:5}){
    int mySecondInt = myInt;
}


double[5] balance = [1000.0, 2.0, 3.4, 17.0, 50.0];
double[5] balance2 = balance;

double *p;
double[]

deep copy
shallow copy
reference
pointer


cpp
A pointer in C++ is a variable that holds the memory address of another variable.
A reference is an alias for an already existing variable. Once a reference is initialized to a variable, it cannot be changed to refer to another variable.


negate signed byte
-------------
signed
0b00000110 = 6
flip all numbers
0b11111001
add binary one
0b11111010
msb staat aan dus is -128
-128 + 64 + 32 + 16 + 8 + 0 + 2 + 0 = -6
----------- twos compliment method

~myInt + 1 == -myInt



-not

---

0b10000110 >> 1
-128 + 6 = -122

0b11111001
-128 + 64 + 32 + 16 + 8 + 0 + 0 + 1 = -7

signed:
0b10000001
-128 + 1 = -127
pas toe: << 1
0b10000010 = -128 + 2 = -126
pas toe: <<< 1
0b00000010 = 2




int i,j
j = 1
if ((bool)(i & 1)){
    
}

34 @>>> 3;
i @>>>= 1;
savedBits = 34 & 0000000000000111;
0011 & 000000000000000001
modulus 2
savedBits <<<= 16 - 3;
newValue = 34 >>> 3;
newValue |= savedBits;

underscores, the operator structure, operand

range
meerdere datatypes


type JsonValue = int | string | bool;
int[] default: -1 myArray = [1,2,3];
int myValue = myArray[1];

Map<string,JsonValue>
Map<string, Object>
string value = object
//warning typecast is not certain
int() | int test = int(){}

reference
ref
flag / tag

void print(...dynamic[] values){

}
print('',43,'');



//startnotes
MyGeneric<MyGeneric>(MyGeneric myGeneric) myMethodVar = myMethod<MyGeneric>;
type MyType = MyGeneric<MyGeneric>(MyGeneric myGeneric);
MyType myType = MyGeneric<MyGeneric>(MyGeneric myGeneric)
Mytype<string> myMethod = myMethod<string>;
string(string stuff) myMethodVar = myMethod<string>;

type myMethod<T> = myMethod<T>;

type MyType<MyGeneric> = MyGeneric<MyGeneric>(MyGeneric myGeneric);
MyType myType = myMethod<int>;

class Map<T,S>
{

}

Map<string,int> myMap = {};
type MyType = Map<string,int>;
type MyType<T,S> = Map<T,S>;
MyType myType<string, int> = {'Index': 5};
//endnotes


int*?[]?*?<T>()?*? myArray = &[null,&3,null]


--------------generics with methods:


enum MyEnum myEnum = {};  
class MyClass<T,S> myClass = { string myString;};
MyClass<string,int> myClassInstance = MyClass<T,S>();
if(){
    myClass = {int myInt;};
}
else{
    myClass = {double myInt;};
}

typeid(clasquestionmark).name();
// "class"

class MyClass = <T,S>(){};

save method as value in variable

// int i = 0;
---
void myMethod<T>(T test){
    return test;
}
function void<T>(T test) myMethod = {return test;};

void display<S>(int dimensions){
    function double<T>(int i) display = {T?[i] data = T?[i]; for(T value in data with int index){print(index + '\n');}};
    for (j = 0; j< 5; j++){
        display<S>(j);
        if (j>2){
            display = {T[i][i] data; for(T row in data){for(T value in data with int index){print(index);}print('\n');}};
        }
    }
}
---

double(int i) recursion = {return i % 2;};
for (j = 0; j< 500; j++){
    recursion(j);
    if (j>200){
        recursion = {return 1 - (i % 2);};
    }
}
recursion();
recursion = {if (i == 5){j=1;} i++;};


function double<int | double T, int | double S>(T firstValue, S secondValue) addOrMultiply = {return (double)(firstValue + secondValue)};
addOrMultiply = {return (double)(firstValue * secondValue)};

string(string,int) myMethod = string(string myString,int myInt){};


int i = 0;
function void<T,S>() inceremeter = {i++;};
myMethod = {i++;};


myMethod = 
string<string,int>() mySecondMethod = myBoolean ? myMethod : mySecondMethod;


matrix operator

//title
Matrix arithmetic

//text
The following table shows all possible operations that can be applied on matrices or vertices.

//tablehead
Operator`   Name`                           Example`                  Same as

//table
#+`         Matrix addition`                myArray = a #+ b;`                          myArray = [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
#-`         Matrix subtraction`             myArray = a #- b;`                          myArray = [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
#*`         Matrix scalar multiplication`   myArray = a #* myScalar;`                   myArray = [a[0]*myScalar, a[1]*myScalar, a[2]*myScalar];
#/`         Matrix scalar division`         myArray = a #/ myScalar;`                   myArray = [a[0]/myScalar, a[1]/myScalar, a[2]/myScalar];
#**`        Matrix dot product`             myArray = c #** a; or myArray = a #** b;`   myArray = [[c[0]*a[0], c[0]*a[1], c[0]*a[2]],[c[1]*a[0], c[1]*a[1], c[1]*a[2]],[c[2]*a[0], c[2]*a[1], c[2]*a[2]]]; or myArray = [a[0]*b[0]+a[1]*b[1]+a[2]*b[2]];
##`         Matrix cross product`           myArray = a ## b;`                          myArray = [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
#-`         Matrix negation`                myArray = #-a;`                             myArray = [a[0]*-1, a[1]*-1, a[2]*-1];
#^`         Matrix norm`                    myInt = #^a;`                               myInt = sqrt(a[0]**2 + a[1]**2 + a[2]**2);
#%`         Matrix unit`                    myArray = #%a;`                             myArray = a #/ #^a;

//subtitle
Matrix addition (#+)

//text
The __#+__ operator is used when two matrices need to be added to each other.
Every number on a position of the first matrix will be added to the number on the same position of the second matrix.
Note that the size of the two does not matter, but they do need to be the same, both must have the same amount of rows and the same amount of columns.

//code
myArray = a #+ b;
myArray = [0+3,1+4,2+5];
myArray = [3,5,7];

//subtitle
Matrix subtraction (#-)

//text
The __#-__ operator is used when one matrix needs to be subtracted from another.
Every number on a position of the first matrix will be added to the number on the same position of the second matrix.
Note that the size of the two does not matter, but they do need to be the same, both must have the same amount of rows and the same amount of columns.

//code
myArray = a #- b;
myArray = [0-3,1-4,2-5];
myArray = [-3,-3,-3];

//subtitle
Matrix scalar multiplication (#*)

//text
The __#*__ operator is used when a matrix needs to be multiplied with a scalar.
Every number on a position of the matrix will be multiplied with a number.
Note that the size of the matrix does not matter.

//code
myArray = a #* myScalar;
myArray = [0*6,1*6,2*9];
myArray = [0,9,18];

//subtitle
Matrix scalar division (#/)

//text
The __#/__ operator is used when a matrix needs to be divided by a scalar.
Every number on a position of the matrix will be divided with a number.
Note that the size of the matrix does not matter.

//code
myArray = a #/ myScalar;
myArray = [0/9,1/9,2/9];
myArray = [0,0,0];

//subtitle
Matrix dot product (#**)

//text
The __#**__ operator is used when two matrices need to be multiplied with each other.
The resulting matrix will have the number of rows of the first matrix and the number of columns of the second matrix.
Every position of the resulting matrix will be the sum of 
each element of the corresponding row in the first matrix multiplied with each element of the corresponding column in the second matrix.
Note that the size of the two does not matter, but the number of columns of the first matrix need to be the same as the number of rows in the second matrix.

//code
myArray = c #** a;
myArray = [[6*0, 6*1, 6*2],[7*0, 7*1, 7*2],[8*0, 8*1, 8*2]];
myArray = [[0, 6, 12],[0, 7, 14],[0, 8, 16]];

//subtitle
Matrix cross product (##)

//text
The __##__ operator is used when the cross product of two matrices needs to be found.
Note that this operator can only be used on two matrices that both have 3 rows and 1 column.

//code
myArray = a ## b;
myArray = [1*5-2*4, 2*3-0*5, 0*4-1*3];
myArray = [5-8, 6-0, 0-3];
myArray = [-3, 6, -3];

//subtitle
Matrix negation (#-)

//text
The __#-__ operator is also used when the negated matrix needs to be found.
Every number in the matrix will be multiplied with -1.

//code
myArray = #-a;
myArray = [0*-1, 1*-1, 2*-1];
myArray = [0, -1, -2];

//subtitle
Matrix norm (#^)

//text
The __#^__ operator is used when the length of a matrix needs to be found.
The resulting number will be the square root of the sum of every number in the column squared.
Note that this operator can only be used on a matrix that has only 1 column.

//code
myInt = #^a;
myInt = sqrt(0**2 + 1**2 + 2**2);
myInt = sqrt(0 + 1 + 4);
myInt = sqrt(5);
myInt = 2;

//subtitle
Matrix unit (#%)

//text
The __#^__ operator is used when the matrix with the same direction but with a length of 1 needs to be found.
The resulting matrix will be the same matrix but every number will be divided by the length of the original matrix.
Note that this operator can only be used on a matrix that has only 1 column.

//code
myArray = #%a;
myArray = a #/ #^a;
myArray = [0/sqrt(0**2 + 1**2 + 2**2),1/sqrt(0**2 + 1**2 + 2**2),2/sqrt(0**2 + 1**2 + 2**2)];
myArray = [0/sqrt(5), 1/sqrt(5), 2/sqrt(5)];
myArray = [0,0,0];




//labeld for loop for continue and break statements

myLoop for(int i = 0; i < 10 i++,){
    mySecondLoop for(int i = 0; i < 10 i++,){
        break myLoop;
        break mySecondLoop;
    }
}

this [int start:<int end:int step>>]{
    
}

int[] myArray = [1,2,3,4,5];
int[] mySecondArray = myArray[0:5:-1]
// mySecondArray becomes: [1,2]

Sets ({})

//text
When key value pairs are added to sets the keys must be unique.

//code
label:string{} mySet = {key:'Value',secondKey:'Second value'};

//code
label:string{} mySet = {key:'Value',key:'Second value'};
//Results in error

key and value pairs have a special propery when added to sets.
A key and value pair is different in sets when the key is difference form the other keys not the key or value.

And when the label is the type of the key in a key and value pair the value can be access trough the label value or via indexing with string
label:string myKeyValuePair = myString:'Hello World!';
string myString = myKeyValuePair.myString;
myString = myKeyValuePair['myString'];
myString = myKeyValuePair[myString];

When a key and value pair is added to sets and the key is of type label the value can be access by calling the label.
The reason why this functinallity can only be applied to sets is because key only in sets the key is always unique while in any other collections it is not.
Values of key and value pairs in sets can always be access like accessing a value form a key and value pair.

label:string mySet = {myString:'Hello World!'};
string myString = mySet.myString;
myString['']

MyClass myClass = auto();
myClass[];

string myString = '23';
int mySecondInt = <!int>myString;

!int myInt;
int myInt = int!;


(string myString:, :int iest)  = ('dwdw':true)
(string myString, , int myInt) = ('',true,2121);

string myString:string dwwdw = myString:'dwdwd';
// dwwdw becomes: 'dwdwd';
int:?string var = null;
int?:?string? var = null;
null:'dwdwd'
// dwwdw becomes: 'dwdwd';
myString:?string dwwdw = myString:'dwdwd';
// dwwdw becomes: myString:'dwdwd'

int: myKeyValuePair string = 23:'';
int:string myKeyValuePair = 23:'';
int : string myValue = 23:'';
int::string{} sfesfe = 23:"";
//instanciate / define
<int?:string> wdwd = :'test';
232:null;
//unpack
<myString:?string dwwdw> = myString:'dwdwd';

(int? myInt,string? myString)? = null;
cant get stuff from null


void myMethod(){

}

myMethod;

int?:?string? test = null:null | null;

void myMethod(myInt:?int myInt, mySecondInt, string myString, myBoolean:bool myBoolean){
    // Your method code
}

void myMethod(myInt:int|int myInt, string myString, myBoolean:bool myBoolean){
    // Your method code
}

void myMethod(!{string myString}){
    // Your method code
}

string myString = 'Hello Wo';
string[5 Hello,char 1, 6 World,...] = myString;

[int 5,int 1,int 6] myArray = [1,2,3,4,5,0,1,2,3,4,5,6];
[int[] 5 first,int 1,int[] 6 second] = myArray;

~ ! @ # $ % * - + \ <> . /
` ^ & ( ) _ = { } [ ] | "" '' , ? \ ;


string myString!;
string? myString = null;
string mySecondString = myString!;

(int | string)() myTuple = (1212,'Hello World!',12);
int | string(myInt,myString,...) = myTuple;
(int myInt,string myString,...) = myTuple;

//text
Other class assignment.

class MyClass
{
    string myString;
    int myInt;
}

MyClass myClass = MyClass{myString = 'Hello World!',myInt = 13135};
MyClass myClass = auto{myString = 'Hello World!',myInt = 13135};
MyClass myClass = {myString = 'Hello World!',myInt = 13135};
MyClass myClass = {'Hello World!',13135};

//text
Return as variable

string myMethod(){
    return = 'Hello World!';
    print(return);
    return;
}

string myString = myMethod();
// myString becomes: 'Hello World!'

(string! myString,int! myInt)! myMethod(){
    return.myString = 'Hello World!';
    return.myInt = 13135;
}

//Literal value ideas

//Array
int[][/*values*/]
int[4][/*values*/]
[string,int][13135, 'Hello World!']
int[,string][13135, 'Hello World!']

type MyType = [string,int,bool?] | [string,int,char?];
MyType myType = [string,int,char?]['Test',121,null];

//Method
void func()(){/*code*/}
void func(string,int)(myString, myInt){/*code*/}

//Set
int{}{/*values*/}
int{4}{/*values*/}

//Map Set
<int:string>{}{}
{int myInt, string myString}{myInt:13135,myString,'Hello World!'}

//String
''
''''''
""
""""""

//Int
23123
123e231
0x2131
0o1232457
0b1010011

//Double
23123.1
123e231.4
0x2131.7
0o1232457.5
0b1010011.9

//Bool
true
false

//Char
'c'
"C"

//Void
null
//these voids will act different
[int,]//One void 
[,]//Two voids

//Future
async int
async int[]

Methods test

//code
void myMethod(){

}
void func() myMethod = (){}
myMethod();

//code
void myMethod[]{

}
void func[] myMethod = []{}
myMethod[];

//code
void myMethod{string myString}{

}
void func{myString string} myMethod = {string myString}{}
myMethod{myString: 'Hello World!'};

use the value keyword for the setters.

//title
Bullet expression

//text
Bullet expressions can be used to define short logic inside another expression.
Bullet expressions are only evaluated when the given boolean is true.
The following operators can be used with bullet expressions to define short logic.

//tablehead
Operator`   bullet expression operator(s)

//table
=`          <?                                              
+=`         <? 
-=`         <? 
*=`         <? 
/=`         <? 
**=`        <? 
%=`         <?
&=`         <? 
|=`         <? 
^=`         <?
>>=`        <?
<<=`        <?
>>>=`       <? 
<<<=`       <?
@>>>=`      <? 
@<<<=`      <?
+`          <? or >? 
-`          <? or >? 
*`          <? or >? 
/`          <? or >? 
**`         <? or >? 
%`          <? or >? 
|`          <? or >? 
^`          <? or >? 
>>`         <? or >?
<<`         <? or >? 
>>>`        <? or >?
<<<`        <? or >? 
@>>>`       <? or >?  
@<<<`       <? or >? 
,`          <? or >? 

//subtitle
Left bullet expression (<?)

//text
The __<?__  operator is used to define a bullet expression with the operator on the left hand side.
To use a left bullet expression write a valid operator followed by a boolean expression and the bullet operator and ending with a literal value or variable.

When the boolean expression is evaluated to true the value will be included in the expression.
When the boolean expression is evaluated to false the operand and the operator before the boolean expression will be ignored.

//code
Int? myInt = myBoolean <? 7;
// myInt becomes: 7 when myBoolean is true
// myInt becomes: null when myBoolean is false

myInt = 5 + myBoolean <? 7;
// myInt becomes: 12 when myBoolean is true
// myInt becomes: 5 when myBoolean is false

myString = myBoolean <? 'Hello World!';
// myString becomes: "Hello World!" when myBoolean is true
// myString keeps the current value when myBoolean is false

//text
The __<?__ operator can also be used on a __,__ to optionaly add values to collections.

Int[] myArray = [1,2,myBoolean <? 3]
// myArray becomes: [1,2,3] when myBoolean is true
// myArray becomes: [1,2] when myBoolean is false

@>>>`       Bitwise unsigned right shift loop         
@<<<`       Bitwise unsigned left shift loop

//subtitle
Right bullet expression (>?)

//text
The __>?__  operator is used to define a bullet expression with the operator on the right hand side.
To use a right bullet expression write a boolean expression and the bullet operator followed by a literal value or variable and ending with a valid operator.

When the boolean expression is evaluated to true the value will be included in the expression.
When the boolean expression is evaluated to false the operand and the operator after operand will be ignored.

//code
Int myInt = myBoolean >? 7 + 5;
// myInt becomes: 12 when myBoolean is true
// myInt becomes: 5 when myBoolean is false

myString = myBoolean >? 'Hello ' + 'World!';
// myString becomes: "Hello World!" when myBoolean is true
// myString becomes: "World!" when myBoolean is false

//text
The __>?__ operator can also be used on a __,__ to optionaly add values to collections.

Int[] myArray = [myBoolean >? 1,2,3]
// myArray becomes: [1,2,3] when myBoolean is true
// myArray becomes: [2,3] when myBoolean is false

//subtitle
Bitwise unsigned right shift loop (@>>>)

//text
The __@>>>__ operator is used to loop every bit in a bit sequence a given amount of places to the right.
The most right bits will be moved to the left.
Note that the MSB will be moved.

//code
Int myInt = 0b00000000000000000000000000001100 @>>> 1;
// myInt becomes: 0b00000000000000000000000000000110 which is 6

myInt = 12 @>>> 2;
// myInt becomes: 3

myInt = 0b11111111111111111111111111110100 @>>> 1;
// myInt becomes: 0b1011111111111111111111111111010 which is 1610612730

myInt = -12 @>>> 2;
// myInt becomes: 1342177277

//text
The __@>>>__ operator can also be used to loop every character or item in a __String__, array or list a given amount of places to the right.
The most right items or characters will be moved to the left.

//code
String myString = '12345' @>>> 1;
// myString becomes: '51234'

Int[] myArray = [1,2,3,4,5] @>>> 1;
// myArray becomes: [5,1,2,3,4]

List<Int> myList = [1,2,3,4,5] @>>> 1;
// myList becomes: [5,1,2,3,4]

//subtitle
Bitwise unsigned left shift (@<<<)

//text
The __@<<<__ operator is used to loop every bit in a bit sequence a given amount of places to the left.
The most left bits will be moved to the right.

//code
Int myInt = 0b00000000000000000000000000001100 @<<< 1;
// myInt becomes: 0b00000000000000000000000000011000 which is 24

myInt = 12 @<<< 2;
// myInt becomes: 48

myInt = 0b11111111111111111111111111110100 @<<< 1;
// myInt becomes: 0b11111111111111111111111111101001 which is -23

myInt = -12 @<<< 2;
// myInt becomes: -45

The __@<<<__ operator can also be used to loop every character or item in a __String__, array or list a given amount of places to the left.
The most left items or characters will be moved to the right.

//code
String myString = '12345' @<<< 1;
// myString becomes: '23451'

Int[] myArray = [1,2,3,4,5] @<<< 1;
// myArray becomes: [2,3,4,5,1]

List<Int> myList = [1,2,3,4,5] @<<< 1;
// myList becomes: [2,3,4,5,1]
